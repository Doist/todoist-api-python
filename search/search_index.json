{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This is the official Python SDK for the Todoist API.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install todoist-api-python\n</code></pre> <p>Or add the project as a dependency in <code>pyproject.toml</code>:</p> <pre><code>dependencies = [\n  \"todoist-api-python&gt;=3.1.0,&lt;4\",\n]\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Here's an example of initializing the API client, fetching a task, and paginating through its comments:</p> <pre><code>from todoist_api_python.api import TodoistAPI\n\napi = TodoistAPI(\"YOUR_API_TOKEN\")\n\ntask = api.get_task(\"6X4Vw2Hfmg73Q2XR\")\nprint(f\"Task: {task.content}\")\n\ncomments_iter = api.get_comments(task_id=task.id)\nfor comments in comments_iter:\n    for comment in comments:\n        print(f\"Comment: {comment.content}\")\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<ul> <li>Authentication</li> <li>API client</li> <li>Models</li> </ul>"},{"location":"#api-reference","title":"API reference","text":"<p>For detailed reference documentation, have a look at the API documentation.</p>"},{"location":"api/","title":"API Client","text":"<p>Client for the Todoist API.</p> <p>Provides methods for interacting with Todoist resources like tasks, projects, labels, comments, etc.</p> <p>Manages an HTTP session and handles authentication. Can be used as a context manager to ensure the session is closed properly.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>class TodoistAPI:\n    \"\"\"\n    Client for the Todoist API.\n\n    Provides methods for interacting with Todoist resources like tasks, projects,\n    labels, comments, etc.\n\n    Manages an HTTP session and handles authentication. Can be used as a context manager\n    to ensure the session is closed properly.\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        request_id_fn: Callable[[], str] | None = default_request_id_fn,\n        session: requests.Session | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the TodoistAPI client.\n\n        :param token: Authentication token for the Todoist API.\n        :param request_id_fn: Generator of request IDs for the `X-Request-ID` header.\n        :param session: An optional pre-configured requests `Session` object.\n        \"\"\"\n        self._token = token\n        self._request_id_fn = request_id_fn\n        self._session = session or requests.Session()\n        self._finalizer = finalize(self, self._session.close)\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"\n        Enters the runtime context related to this object.\n\n        The with statement will bind this method's return value to the target(s)\n        specified in the as clause of the statement, if any.\n\n        :return: This TodoistAPI instance.\n        \"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit the runtime context and closes the underlying requests session.\"\"\"\n        self._finalizer()\n\n    def get_task(self, task_id: str) -&gt; Task:\n        \"\"\"\n        Get a specific task by its ID.\n\n        :param task_id: The ID of the task to retrieve.\n        :return: The requested task.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Task dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n        task_data: dict[str, Any] = get(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return Task.from_dict(task_data)\n\n    def get_tasks(\n        self,\n        *,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        label: str | None = None,\n        ids: list[str] | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of active tasks.\n\n        The response is an iterable of lists of active tasks matching the criteria.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: Filter tasks by project ID.\n        :param section_id: Filter tasks by section ID.\n        :param parent_id: Filter tasks by parent task ID.\n        :param label: Filter tasks by label name.\n        :param ids: A list of the IDs of the tasks to retrieve.\n        :param limit: Maximum number of tasks per page.\n        :return: An iterable of lists of tasks.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_PATH)\n\n        params: dict[str, Any] = {}\n        if project_id is not None:\n            params[\"project_id\"] = project_id\n        if section_id is not None:\n            params[\"section_id\"] = section_id\n        if parent_id is not None:\n            params[\"parent_id\"] = parent_id\n        if label is not None:\n            params[\"label\"] = label\n        if ids is not None:\n            params[\"ids\"] = \",\".join(str(i) for i in ids)\n        if limit is not None:\n            params[\"limit\"] = limit\n\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"results\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def filter_tasks(\n        self,\n        *,\n        query: Annotated[str, MaxLen(1024)] | None = None,\n        lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of active tasks matching the filter.\n\n        The response is an iterable of lists of active tasks matching the criteria.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query tasks using Todoist's filter language.\n        :param lang: Language for task content (e.g., 'en').\n        :param limit: Maximum number of tasks per page.\n        :return: An iterable of lists of tasks.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_FILTER_PATH)\n\n        params: dict[str, Any] = {}\n        if query is not None:\n            params[\"query\"] = query\n        if lang is not None:\n            params[\"lang\"] = lang\n        if limit is not None:\n            params[\"limit\"] = limit\n\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"results\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_task(  # noqa: PLR0912\n        self,\n        content: Annotated[str, MinLen(1), MaxLen(500)],\n        *,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        labels: list[Annotated[str, MaxLen(100)]] | None = None,\n        priority: Annotated[int, Ge(1), Le(4)] | None = None,\n        due_string: Annotated[str, MaxLen(150)] | None = None,\n        due_lang: LanguageCode | None = None,\n        due_date: date | None = None,\n        due_datetime: datetime | None = None,\n        assignee_id: str | None = None,\n        order: int | None = None,\n        auto_reminder: bool | None = None,\n        auto_parse_labels: bool | None = None,\n        duration: Annotated[int, Ge(1)] | None = None,\n        duration_unit: Literal[\"minute\", \"day\"] | None = None,\n        deadline_date: date | None = None,\n        deadline_lang: LanguageCode | None = None,\n    ) -&gt; Task:\n        \"\"\"\n        Create a new task.\n\n        :param content: The text content of the task.\n        :param project_id: The ID of the project to add the task to.\n        :param section_id: The ID of the section to add the task to.\n        :param parent_id: The ID of the parent task.\n        :param labels: The task's labels (a list of names).\n        :param priority: The priority of the task (4 for very urgent).\n        :param due_string: The due date in natural language format.\n        :param due_lang: Language for parsing the due date (e.g., 'en').\n        :param due_date: The due date as a date object.\n        :param due_datetime: The due date and time as a datetime object.\n        :param assignee_id: User ID to whom the task is assigned.\n        :param description: Description for the task.\n        :param order: The order of task in the project or section.\n        :param auto_reminder: Whether to add default reminder if date with time is set.\n        :param auto_parse_labels: Whether to parse labels from task content.\n        :param duration: The amount of time the task will take.\n        :param duration_unit: The unit of time for duration.\n        :param deadline_date: The deadline date as a date object.\n        :param deadline_lang: Language for parsing the deadline date.\n        :return: The newly created task.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Task dictionary.\n        \"\"\"\n        endpoint = get_api_url(TASKS_PATH)\n\n        data: dict[str, Any] = {\"content\": content}\n        if description is not None:\n            data[\"description\"] = description\n        if project_id is not None:\n            data[\"project_id\"] = project_id\n        if section_id is not None:\n            data[\"section_id\"] = section_id\n        if parent_id is not None:\n            data[\"parent_id\"] = parent_id\n        if labels is not None:\n            data[\"labels\"] = labels\n        if priority is not None:\n            data[\"priority\"] = priority\n        if due_string is not None:\n            data[\"due_string\"] = due_string\n        if due_lang is not None:\n            data[\"due_lang\"] = due_lang\n        if due_date is not None:\n            data[\"due_date\"] = format_date(due_date)\n        if due_datetime is not None:\n            data[\"due_datetime\"] = format_datetime(due_datetime)\n        if assignee_id is not None:\n            data[\"assignee_id\"] = assignee_id\n        if order is not None:\n            data[\"order\"] = order\n        if auto_reminder is not None:\n            data[\"auto_reminder\"] = auto_reminder\n        if auto_parse_labels is not None:\n            data[\"auto_parse_labels\"] = auto_parse_labels\n        if duration is not None:\n            data[\"duration\"] = duration\n        if duration_unit is not None:\n            data[\"duration_unit\"] = duration_unit\n        if deadline_date is not None:\n            data[\"deadline_date\"] = format_date(deadline_date)\n        if deadline_lang is not None:\n            data[\"deadline_lang\"] = deadline_lang\n\n        task_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Task.from_dict(task_data)\n\n    def add_task_quick(\n        self,\n        text: str,\n        *,\n        note: str | None = None,\n        reminder: str | None = None,\n        auto_reminder: bool = True,\n    ) -&gt; Task:\n        \"\"\"\n        Create a new task using Todoist's Quick Add syntax.\n\n        This automatically parses dates, deadlines, projects, labels, priorities, etc,\n        from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").\n\n        :param text: The task text using Quick Add syntax.\n        :param note: Optional note to be added to the task.\n        :param reminder: Optional reminder date in free form text.\n        :param auto_reminder: Whether to add default reminder if date with time is set.\n        :return: A result object containing the parsed task data and metadata.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response cannot be parsed into a QuickAddResult.\n        \"\"\"\n        endpoint = get_api_url(TASKS_QUICK_ADD_PATH)\n\n        data = {\n            \"meta\": True,\n            \"text\": text,\n            \"auto_reminder\": auto_reminder,\n        }\n\n        if note is not None:\n            data[\"note\"] = note\n        if reminder is not None:\n            data[\"reminder\"] = reminder\n\n        task_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Task.from_dict(task_data)\n\n    def update_task(  # noqa: PLR0912\n        self,\n        task_id: str,\n        *,\n        content: Annotated[str, MinLen(1), MaxLen(500)] | None = None,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        labels: list[Annotated[str, MaxLen(60)]] | None = None,\n        priority: Annotated[int, Ge(1), Le(4)] | None = None,\n        due_string: Annotated[str, MaxLen(150)] | None = None,\n        due_lang: LanguageCode | None = None,\n        due_date: date | None = None,\n        due_datetime: datetime | None = None,\n        assignee_id: str | None = None,\n        day_order: int | None = None,\n        collapsed: bool | None = None,\n        duration: Annotated[int, Ge(1)] | None = None,\n        duration_unit: Literal[\"minute\", \"day\"] | None = None,\n        deadline_date: date | None = None,\n        deadline_lang: LanguageCode | None = None,\n    ) -&gt; Task:\n        \"\"\"\n        Update an existing task.\n\n        Only the fields to be updated need to be provided.\n\n        :param task_id: The ID of the task to update.\n        :param content: The text content of the task.\n        :param description: Description for the task.\n        :param labels: The task's labels (a list of names).\n        :param priority: The priority of the task (4 for very urgent).\n        :param due_string: The due date in natural language format.\n        :param due_lang: Language for parsing the due date (e.g., 'en').\n        :param due_date: The due date as a date object.\n        :param due_datetime: The due date and time as a datetime object.\n        :param assignee_id: User ID to whom the task is assigned.\n        :param day_order: The order of the task inside Today or Next 7 days view.\n        :param collapsed: Whether the task's sub-tasks are collapsed.\n        :param duration: The amount of time the task will take.\n        :param duration_unit: The unit of time for duration.\n        :param deadline_date: The deadline date as a date object.\n        :param deadline_lang: Language for parsing the deadline date.\n        :return: the updated Task.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n\n        data: dict[str, Any] = {}\n        if content is not None:\n            data[\"content\"] = content\n        if description is not None:\n            data[\"description\"] = description\n        if labels is not None:\n            data[\"labels\"] = labels\n        if priority is not None:\n            data[\"priority\"] = priority\n        if due_string is not None:\n            data[\"due_string\"] = due_string\n        if due_lang is not None:\n            data[\"due_lang\"] = due_lang\n        if due_date is not None:\n            data[\"due_date\"] = format_date(due_date)\n        if due_datetime is not None:\n            data[\"due_datetime\"] = format_datetime(due_datetime)\n        if assignee_id is not None:\n            data[\"assignee_id\"] = assignee_id\n        if day_order is not None:\n            data[\"day_order\"] = day_order\n        if collapsed is not None:\n            data[\"collapsed\"] = collapsed\n        if duration is not None:\n            data[\"duration\"] = duration\n        if duration_unit is not None:\n            data[\"duration_unit\"] = duration_unit\n        if deadline_date is not None:\n            data[\"deadline_date\"] = format_date(deadline_date)\n        if deadline_lang is not None:\n            data[\"deadline_lang\"] = deadline_lang\n\n        task_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Task.from_dict(task_data)\n\n    def complete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Complete a task.\n\n        For recurring tasks, this schedules the next occurrence.\n        For non-recurring tasks, it marks them as completed.\n\n        :param task_id: The ID of the task to close.\n        :return: True if the task was closed successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/close\")\n        return post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n\n    def uncomplete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Uncomplete a (completed) task.\n\n        Any parent tasks or sections will also be uncompleted.\n\n        :param task_id: The ID of the task to reopen.\n        :return: True if the task was uncompleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/reopen\")\n        return post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n\n    def move_task(\n        self,\n        task_id: str,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n    ) -&gt; bool:\n        \"\"\"\n        Move a task to a different project, section, or parent task.\n\n        `project_id` takes predence, followed by\n        `section_id` (which also updates `project_id`),\n        and then `parent_id` (which also updates `section_id` and `project_id`).\n\n        :param task_id: The ID of the task to move.\n        :param project_id: The ID of the project to move the task to.\n        :param section_id: The ID of the section to move the task to.\n        :param parent_id: The ID of the parent to move the task to.\n        :return: True if the task was moved successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises ValueError: If neither `project_id`, `section_id`,\n                nor `parent_id` is provided.\n        \"\"\"\n        if project_id is None and section_id is None and parent_id is None:\n            raise ValueError(\n                \"Either `project_id`, `section_id`, or `parent_id` must be provided.\"\n            )\n\n        data: dict[str, Any] = {}\n        if project_id is not None:\n            data[\"project_id\"] = project_id\n        if section_id is not None:\n            data[\"section_id\"] = section_id\n        if parent_id is not None:\n            data[\"parent_id\"] = parent_id\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/move\")\n        return post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n\n    def delete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Delete a task.\n\n        :param task_id: The ID of the task to delete.\n        :return: True if the task was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n        return delete(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n\n    def get_completed_tasks_by_due_date(\n        self,\n        *,\n        since: datetime,\n        until: datetime,\n        workspace_id: str | None = None,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        filter_query: str | None = None,\n        filter_lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of completed tasks within a due date range.\n\n        Retrieves tasks completed within a specific due date range (up to 6 weeks).\n        Supports filtering by workspace, project, section, parent task, or a query.\n\n        The response is an iterable of lists of completed tasks. Be aware that each\n        iteration fires off a network request to the Todoist API, and may result in\n        rate limiting or other API restrictions.\n\n        :param since: Start of the date range (inclusive).\n        :param until: End of the date range (inclusive).\n        :param workspace_id: Filter by workspace ID.\n        :param project_id: Filter by project ID.\n        :param section_id: Filter by section ID.\n        :param parent_id: Filter by parent task ID.\n        :param filter_query: Filter by a query string.\n        :param filter_lang: Language for the filter query (e.g., 'en').\n        :param limit: Maximum number of tasks per page (default 50).\n        :return: An iterable of lists of completed tasks.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_COMPLETED_BY_DUE_DATE_PATH)\n\n        params: dict[str, Any] = {\n            \"since\": format_datetime(since),\n            \"until\": format_datetime(until),\n        }\n        if workspace_id is not None:\n            params[\"workspace_id\"] = workspace_id\n        if project_id is not None:\n            params[\"project_id\"] = project_id\n        if section_id is not None:\n            params[\"section_id\"] = section_id\n        if parent_id is not None:\n            params[\"parent_id\"] = parent_id\n        if filter_query is not None:\n            params[\"filter_query\"] = filter_query\n        if filter_lang is not None:\n            params[\"filter_lang\"] = filter_lang\n        if limit is not None:\n            params[\"limit\"] = limit\n\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"items\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def get_completed_tasks_by_completion_date(\n        self,\n        *,\n        since: datetime,\n        until: datetime,\n        workspace_id: str | None = None,\n        filter_query: str | None = None,\n        filter_lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of completed tasks within a date range.\n\n        Retrieves tasks completed within a specific date range (up to 3 months).\n        Supports filtering by workspace or a filter query.\n\n        The response is an iterable of lists of completed tasks. Be aware that each\n        iteration fires off a network request to the Todoist API, and may result in\n        rate limiting or other API restrictions.\n\n        :param since: Start of the date range (inclusive).\n        :param until: End of the date range (inclusive).\n        :param workspace_id: Filter by workspace ID.\n        :param filter_query: Filter by a query string.\n        :param filter_lang: Language for the filter query (e.g., 'en').\n        :param limit: Maximum number of tasks per page (default 50).\n        :return: An iterable of lists of completed tasks.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_COMPLETED_BY_COMPLETION_DATE_PATH)\n\n        params: dict[str, Any] = {\n            \"since\": format_datetime(since),\n            \"until\": format_datetime(until),\n        }\n        if workspace_id is not None:\n            params[\"workspace_id\"] = workspace_id\n        if filter_query is not None:\n            params[\"filter_query\"] = filter_query\n        if filter_lang is not None:\n            params[\"filter_lang\"] = filter_lang\n        if limit is not None:\n            params[\"limit\"] = limit\n\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"items\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def get_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Get a project by its ID.\n\n        :param project_id: The ID of the project to retrieve.\n        :return: The requested project.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n        project_data: dict[str, Any] = get(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return Project.from_dict(project_data)\n\n    def get_projects(\n        self,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Project]]:\n        \"\"\"\n        Get an iterable of lists of active projects.\n\n        The response is an iterable of lists of active projects.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param limit: Maximum number of projects per page.\n        :return: An iterable of lists of projects.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(PROJECTS_PATH)\n        params: dict[str, Any] = {}\n        if limit is not None:\n            params[\"limit\"] = limit\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"results\",\n            Project.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_project(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(120)],\n        *,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        parent_id: str | None = None,\n        color: ColorString | None = None,\n        is_favorite: bool | None = None,\n        view_style: ViewStyle | None = None,\n    ) -&gt; Project:\n        \"\"\"\n        Create a new project.\n\n        :param name: The name of the project.\n        :param description: Description for the project (up to 1024 characters).\n        :param parent_id: The ID of the parent project. Set to null for root projects.\n        :param color: The color of the project icon.\n        :param is_favorite: Whether the project is a favorite.\n        :param view_style: A string value (either 'list' or 'board', default is 'list').\n        :return: The newly created project.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(PROJECTS_PATH)\n\n        data: dict[str, Any] = {\"name\": name}\n        if parent_id is not None:\n            data[\"parent_id\"] = parent_id\n        if description is not None:\n            data[\"description\"] = description\n        if color is not None:\n            data[\"color\"] = color\n        if is_favorite is not None:\n            data[\"is_favorite\"] = is_favorite\n        if view_style is not None:\n            data[\"view_style\"] = view_style\n\n        project_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Project.from_dict(project_data)\n\n    def update_project(\n        self,\n        project_id: str,\n        *,\n        name: Annotated[str, MinLen(1), MaxLen(120)] | None = None,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        color: ColorString | None = None,\n        is_favorite: bool | None = None,\n        view_style: ViewStyle | None = None,\n    ) -&gt; Project:\n        \"\"\"\n        Update an existing project.\n\n        Only the fields to be updated need to be provided as keyword arguments.\n\n        :param project_id: The ID of the project to update.\n        :param name: The name of the project.\n        :param description: Description for the project (up to 1024 characters).\n        :param color: The color of the project icon.\n        :param is_favorite: Whether the project is a favorite.\n        :param view_style: A string value (either 'list' or 'board').\n        :return: the updated Project.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n\n        data: dict[str, Any] = {}\n\n        if name is not None:\n            data[\"name\"] = name\n        if description is not None:\n            data[\"description\"] = description\n        if color is not None:\n            data[\"color\"] = color\n        if is_favorite is not None:\n            data[\"is_favorite\"] = is_favorite\n        if view_style is not None:\n            data[\"view_style\"] = view_style\n\n        project_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Project.from_dict(project_data)\n\n    def archive_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Archive a project.\n\n        For personal projects, archives it only for the user.\n        For workspace projects, archives it for all members.\n\n        :param project_id: The ID of the project to archive.\n        :return: The archived project object.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(\n            f\"{PROJECTS_PATH}/{project_id}/{PROJECT_ARCHIVE_PATH_SUFFIX}\"\n        )\n        project_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return Project.from_dict(project_data)\n\n    def unarchive_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Unarchive a project.\n\n        Restores a previously archived project.\n\n        :param project_id: The ID of the project to unarchive.\n        :return: The unarchived project object.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(\n            f\"{PROJECTS_PATH}/{project_id}/{PROJECT_UNARCHIVE_PATH_SUFFIX}\"\n        )\n        project_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return Project.from_dict(project_data)\n\n    def delete_project(self, project_id: str) -&gt; bool:\n        \"\"\"\n        Delete a project.\n\n        All nested sections and tasks will also be deleted.\n\n        :param project_id: The ID of the project to delete.\n        :return: True if the project was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n        return delete(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n\n    def get_collaborators(\n        self,\n        project_id: str,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Collaborator]]:\n        \"\"\"\n        Get an iterable of lists of collaborators in shared projects.\n\n        The response is an iterable of lists of collaborators in shared projects,\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: The ID of the project.\n        :param limit: Maximum number of collaborators per page.\n        :return: An iterable of lists of collaborators.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}/{COLLABORATORS_PATH}\")\n        params: dict[str, Any] = {}\n        if limit is not None:\n            params[\"limit\"] = limit\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"results\",\n            Collaborator.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def get_section(self, section_id: str) -&gt; Section:\n        \"\"\"\n        Get a specific section by its ID.\n\n        :param section_id: The ID of the section to retrieve.\n        :return: The requested section.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Section dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        section_data: dict[str, Any] = get(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return Section.from_dict(section_data)\n\n    def get_sections(\n        self,\n        project_id: str | None = None,\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Section]]:\n        \"\"\"\n        Get an iterable of lists of active sections.\n\n        Supports filtering by `project_id` and pagination arguments.\n\n        The response is an iterable of lists of active sections.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: Filter sections by project ID.\n        :param limit: Maximum number of sections per page.\n        :return: An iterable of lists of sections.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(SECTIONS_PATH)\n\n        params: dict[str, Any] = {}\n        if project_id is not None:\n            params[\"project_id\"] = project_id\n        if limit is not None:\n            params[\"limit\"] = limit\n\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"results\",\n            Section.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_section(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(2048)],\n        project_id: str,\n        *,\n        order: int | None = None,\n    ) -&gt; Section:\n        \"\"\"\n        Create a new section within a project.\n\n        :param name: The name of the section.\n        :param project_id: The ID of the project to add the section to.\n        :param order: The order of the section among all sections in the project.\n        :return: The newly created section.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Section dictionary.\n        \"\"\"\n        endpoint = get_api_url(SECTIONS_PATH)\n\n        data: dict[str, Any] = {\"name\": name, \"project_id\": project_id}\n        if order is not None:\n            data[\"order\"] = order\n\n        section_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Section.from_dict(section_data)\n\n    def update_section(\n        self,\n        section_id: str,\n        name: Annotated[str, MinLen(1), MaxLen(2048)],\n    ) -&gt; Section:\n        \"\"\"\n        Update an existing section.\n\n        Currently, only `name` can be updated.\n\n        :param section_id: The ID of the section to update.\n        :param name: The new name for the section.\n        :return: the updated Section.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        section_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data={\"name\": name},\n        )\n        return Section.from_dict(section_data)\n\n    def delete_section(self, section_id: str) -&gt; bool:\n        \"\"\"\n        Delete a section.\n\n        All tasks within the section will also be deleted.\n\n        :param section_id: The ID of the section to delete.\n        :return: True if the section was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        return delete(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n\n    def get_comment(self, comment_id: str) -&gt; Comment:\n        \"\"\"\n        Get a specific comment by its ID.\n\n        :param comment_id: The ID of the comment to retrieve.\n        :return: The requested comment.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Comment dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        comment_data: dict[str, Any] = get(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return Comment.from_dict(comment_data)\n\n    def get_comments(\n        self,\n        *,\n        project_id: str | None = None,\n        task_id: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Comment]]:\n        \"\"\"\n        Get an iterable of lists of comments for a task or project.\n\n        Requires either `project_id` or `task_id` to be set.\n\n        The response is an iterable of lists of comments.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: The ID of the project to retrieve comments for.\n        :param task_id: The ID of the task to retrieve comments for.\n        :param limit: Maximum number of comments per page.\n        :return: An iterable of lists of comments.\n        :raises ValueError: If neither `project_id` nor `task_id` is provided.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        if project_id is None and task_id is None:\n            raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n        endpoint = get_api_url(COMMENTS_PATH)\n\n        params: dict[str, Any] = {}\n        if project_id is not None:\n            params[\"project_id\"] = project_id\n        if task_id is not None:\n            params[\"task_id\"] = task_id\n        if limit is not None:\n            params[\"limit\"] = limit\n\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"results\",\n            Comment.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_comment(\n        self,\n        content: Annotated[str, MaxLen(15000)],\n        *,\n        project_id: str | None = None,\n        task_id: str | None = None,\n        attachment: Attachment | None = None,\n        uids_to_notify: list[str] | None = None,\n    ) -&gt; Comment:\n        \"\"\"\n        Create a new comment on a task or project.\n\n        Requires either `project_id` or `task_id` to be set,\n        and can optionally include an `attachment` object.\n\n        :param content: The text content of the comment (supports Markdown).\n        :param project_id: The ID of the project to add the comment to.\n        :param task_id: The ID of the task to add the comment to.\n        :param attachment: The attachment object to include with the comment.\n        :param uids_to_notify: A list of user IDs to notify.\n        :return: The newly created comment.\n        :raises ValueError: If neither `project_id` nor `task_id` is provided.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Comment dictionary.\n        \"\"\"\n        if project_id is None and task_id is None:\n            raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n        endpoint = get_api_url(COMMENTS_PATH)\n\n        data: dict[str, Any] = {\"content\": content}\n        if project_id is not None:\n            data[\"project_id\"] = project_id\n        if task_id is not None:\n            data[\"task_id\"] = task_id\n        if attachment is not None:\n            data[\"attachment\"] = attachment.to_dict()\n        if uids_to_notify is not None:\n            data[\"uids_to_notify\"] = uids_to_notify\n\n        comment_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Comment.from_dict(comment_data)\n\n    def update_comment(\n        self, comment_id: str, content: Annotated[str, MaxLen(15000)]\n    ) -&gt; Comment:\n        \"\"\"\n        Update an existing comment.\n\n        Currently, only `content` can be updated.\n\n        :param comment_id: The ID of the comment to update.\n        :param content: The new text content for the comment.\n        :return: the updated Comment.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        comment_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data={\"content\": content},\n        )\n        return Comment.from_dict(comment_data)\n\n    def delete_comment(self, comment_id: str) -&gt; bool:\n        \"\"\"\n        Delete a comment.\n\n        :param comment_id: The ID of the comment to delete.\n        :return: True if the comment was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        return delete(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n\n    def get_label(self, label_id: str) -&gt; Label:\n        \"\"\"\n        Get a specific personal label by its ID.\n\n        :param label_id: The ID of the label to retrieve.\n        :return: The requested label.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Label dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n        label_data: dict[str, Any] = get(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return Label.from_dict(label_data)\n\n    def get_labels(\n        self,\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Label]]:\n        \"\"\"\n        Get an iterable of lists of personal labels.\n\n        Supports pagination arguments.\n\n        The response is an iterable of lists of personal labels.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param limit: ` number of labels per page.\n        :return: An iterable of lists of personal labels.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(LABELS_PATH)\n\n        params: dict[str, Any] = {}\n        if limit is not None:\n            params[\"limit\"] = limit\n\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"results\",\n            Label.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_label(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(60)],\n        *,\n        color: ColorString | None = None,\n        item_order: int | None = None,\n        is_favorite: bool | None = None,\n    ) -&gt; Label:\n        \"\"\"\n        Create a new personal label.\n\n        :param name: The name of the label.\n        :param color: The color of the label icon.\n        :param item_order: Label's order in the label list.\n        :param is_favorite: Whether the label is a favorite.\n        :return: The newly created label.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Label dictionary.\n        \"\"\"\n        endpoint = get_api_url(LABELS_PATH)\n\n        data: dict[str, Any] = {\"name\": name}\n\n        if color is not None:\n            data[\"color\"] = color\n        if item_order is not None:\n            data[\"item_order\"] = item_order\n        if is_favorite is not None:\n            data[\"is_favorite\"] = is_favorite\n\n        label_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Label.from_dict(label_data)\n\n    def update_label(\n        self,\n        label_id: str,\n        *,\n        name: Annotated[str, MinLen(1), MaxLen(60)] | None = None,\n        color: ColorString | None = None,\n        item_order: int | None = None,\n        is_favorite: bool | None = None,\n    ) -&gt; Label:\n        \"\"\"\n        Update a personal label.\n\n        Only the fields to be updated need to be provided as keyword arguments.\n\n        :param label_id: The ID of the label.\n        :param name: The name of the label.\n        :param color: The color of the label icon.\n        :param item_order: Label's order in the label list.\n        :param is_favorite: Whether the label is a favorite.\n        :return: the updated Label.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n\n        data: dict[str, Any] = {}\n        if name is not None:\n            data[\"name\"] = name\n        if color is not None:\n            data[\"color\"] = color\n        if item_order is not None:\n            data[\"item_order\"] = item_order\n        if is_favorite is not None:\n            data[\"is_favorite\"] = is_favorite\n\n        label_data: dict[str, Any] = post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return Label.from_dict(label_data)\n\n    def delete_label(self, label_id: str) -&gt; bool:\n        \"\"\"\n        Delete a personal label.\n\n        Instances of the label will be removed from tasks.\n\n        :param label_id: The ID of the label to delete.\n        :return: True if the label was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n        return delete(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n\n    def get_shared_labels(\n        self,\n        *,\n        omit_personal: bool = False,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[str]]:\n        \"\"\"\n        Get an iterable of lists of shared label names.\n\n        Includes labels from collaborators on shared projects that are not in the\n        user's personal labels. Can optionally exclude personal label names using\n        `omit_personal=True`. Supports pagination arguments.\n\n        The response is an iterable of lists of shared label names.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param omit_personal: Optional boolean flag to omit personal label names.\n        :param limit: Maximum number of labels per page.\n        :return: An iterable of lists of shared label names (strings).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_PATH)\n\n        params: dict[str, Any] = {\"omit_personal\": omit_personal}\n        if limit is not None:\n            params[\"limit\"] = limit\n\n        return ResultsPaginator(\n            self._session,\n            endpoint,\n            \"results\",\n            str,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def rename_shared_label(\n        self,\n        name: Annotated[str, MaxLen(60)],\n        new_name: Annotated[str, MinLen(1), MaxLen(60)],\n    ) -&gt; bool:\n        \"\"\"\n        Rename all occurrences of a shared label across all projects.\n\n        :param name: The current name of the shared label to rename.\n        :param new_name: The new name for the shared label.\n        :return: True if the rename was successful,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_RENAME_PATH)\n        return post(\n            self._session,\n            endpoint,\n            self._token,\n            params={\"name\": name},\n            data={\"new_name\": new_name},\n        )\n\n    def remove_shared_label(self, name: Annotated[str, MaxLen(60)]) -&gt; bool:\n        \"\"\"\n        Remove all occurrences of a shared label across all projects.\n\n        This action removes the label string from all tasks where it appears.\n\n        :param name: The name of the shared label to remove.\n        :return: True if the removal was successful,\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_REMOVE_PATH)\n        data = {\"name\": name}\n        return post(\n            self._session,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n</code></pre> <p>               Bases: <code>Iterator[list[T]]</code></p> <p>Iterator for paginated results from the Todoist API.</p> <p>It encapsulates the logic for fetching and iterating through paginated results from Todoist API endpoints. It handles cursor-based pagination automatically, requesting new pages as needed when iterating.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>class ResultsPaginator(Iterator[list[T]]):\n    \"\"\"\n    Iterator for paginated results from the Todoist API.\n\n    It encapsulates the logic for fetching and iterating through paginated results\n    from Todoist API endpoints. It handles cursor-based pagination automatically,\n    requesting new pages as needed when iterating.\n    \"\"\"\n\n    _session: requests.Session\n    _url: str\n    _results_field: str\n    _results_inst: Callable[[Any], T]\n    _token: str\n    _cursor: str | None\n\n    def __init__(\n        self,\n        session: requests.Session,\n        url: str,\n        results_field: str,\n        results_inst: Callable[[Any], T],\n        token: str,\n        request_id_fn: Callable[[], str] | None,\n        params: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ResultsPaginator.\n\n        :param session: The requests Session to use for API calls.\n        :param url: The API endpoint URL to fetch results from.\n        :param results_field: The key in the API response that contains the results.\n        :param results_inst: A callable that converts result items to objects of type T.\n        :param token: The authentication token for the Todoist API.\n        :param params: Query parameters to include in API requests.\n        \"\"\"\n        self._session = session\n        self._url = url\n        self._results_field = results_field\n        self._results_inst = results_inst\n        self._token = token\n        self._request_id_fn = request_id_fn\n        self._params = params\n        self._cursor = \"\"  # empty string for first page\n\n    def __next__(self) -&gt; list[T]:\n        \"\"\"\n        Fetch and return the next page of results from the Todoist API.\n\n        :return: A list of results.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        if self._cursor is None:\n            raise StopIteration\n\n        params = self._params.copy()\n        if self._cursor != \"\":\n            params[\"cursor\"] = self._cursor\n\n        data: dict[str, Any] = get(\n            self._session,\n            self._url,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            params,\n        )\n        self._cursor = data.get(\"next_cursor\")\n\n        results: list[Any] = data.get(self._results_field, [])\n        return [self._results_inst(result) for result in results]\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_comment","title":"<code>add_comment(content, *, project_id=None, task_id=None, attachment=None, uids_to_notify=None)</code>","text":"<p>Create a new comment on a task or project.</p> <p>Requires either <code>project_id</code> or <code>task_id</code> to be set, and can optionally include an <code>attachment</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text content of the comment (supports Markdown).</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to add the comment to.</p> <code>None</code> <code>task_id</code> <code>str | None</code> <p>The ID of the task to add the comment to.</p> <code>None</code> <code>attachment</code> <code>Attachment | None</code> <p>The attachment object to include with the comment.</p> <code>None</code> <code>uids_to_notify</code> <code>list[str] | None</code> <p>A list of user IDs to notify.</p> <code>None</code> <p>Returns:</p> Type Description <code>Comment</code> <p>The newly created comment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>project_id</code> nor <code>task_id</code> is provided.</p> <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Comment dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_comment(\n    self,\n    content: Annotated[str, MaxLen(15000)],\n    *,\n    project_id: str | None = None,\n    task_id: str | None = None,\n    attachment: Attachment | None = None,\n    uids_to_notify: list[str] | None = None,\n) -&gt; Comment:\n    \"\"\"\n    Create a new comment on a task or project.\n\n    Requires either `project_id` or `task_id` to be set,\n    and can optionally include an `attachment` object.\n\n    :param content: The text content of the comment (supports Markdown).\n    :param project_id: The ID of the project to add the comment to.\n    :param task_id: The ID of the task to add the comment to.\n    :param attachment: The attachment object to include with the comment.\n    :param uids_to_notify: A list of user IDs to notify.\n    :return: The newly created comment.\n    :raises ValueError: If neither `project_id` nor `task_id` is provided.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Comment dictionary.\n    \"\"\"\n    if project_id is None and task_id is None:\n        raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n    endpoint = get_api_url(COMMENTS_PATH)\n\n    data: dict[str, Any] = {\"content\": content}\n    if project_id is not None:\n        data[\"project_id\"] = project_id\n    if task_id is not None:\n        data[\"task_id\"] = task_id\n    if attachment is not None:\n        data[\"attachment\"] = attachment.to_dict()\n    if uids_to_notify is not None:\n        data[\"uids_to_notify\"] = uids_to_notify\n\n    comment_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Comment.from_dict(comment_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_label","title":"<code>add_label(name, *, color=None, item_order=None, is_favorite=None)</code>","text":"<p>Create a new personal label.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the label.</p> required <code>color</code> <code>ColorString | None</code> <p>The color of the label icon.</p> <code>None</code> <code>item_order</code> <code>int | None</code> <p>Label's order in the label list.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the label is a favorite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>The newly created label.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Label dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_label(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(60)],\n    *,\n    color: ColorString | None = None,\n    item_order: int | None = None,\n    is_favorite: bool | None = None,\n) -&gt; Label:\n    \"\"\"\n    Create a new personal label.\n\n    :param name: The name of the label.\n    :param color: The color of the label icon.\n    :param item_order: Label's order in the label list.\n    :param is_favorite: Whether the label is a favorite.\n    :return: The newly created label.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Label dictionary.\n    \"\"\"\n    endpoint = get_api_url(LABELS_PATH)\n\n    data: dict[str, Any] = {\"name\": name}\n\n    if color is not None:\n        data[\"color\"] = color\n    if item_order is not None:\n        data[\"item_order\"] = item_order\n    if is_favorite is not None:\n        data[\"is_favorite\"] = is_favorite\n\n    label_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Label.from_dict(label_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_project","title":"<code>add_project(name, *, description=None, parent_id=None, color=None, is_favorite=None, view_style=None)</code>","text":"<p>Create a new project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the project.</p> required <code>description</code> <code>str | None</code> <p>Description for the project (up to 1024 characters).</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent project. Set to null for root projects.</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the project icon.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the project is a favorite.</p> <code>None</code> <code>view_style</code> <code>ViewStyle | None</code> <p>A string value (either 'list' or 'board', default is 'list').</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>The newly created project.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_project(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(120)],\n    *,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    parent_id: str | None = None,\n    color: ColorString | None = None,\n    is_favorite: bool | None = None,\n    view_style: ViewStyle | None = None,\n) -&gt; Project:\n    \"\"\"\n    Create a new project.\n\n    :param name: The name of the project.\n    :param description: Description for the project (up to 1024 characters).\n    :param parent_id: The ID of the parent project. Set to null for root projects.\n    :param color: The color of the project icon.\n    :param is_favorite: Whether the project is a favorite.\n    :param view_style: A string value (either 'list' or 'board', default is 'list').\n    :return: The newly created project.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(PROJECTS_PATH)\n\n    data: dict[str, Any] = {\"name\": name}\n    if parent_id is not None:\n        data[\"parent_id\"] = parent_id\n    if description is not None:\n        data[\"description\"] = description\n    if color is not None:\n        data[\"color\"] = color\n    if is_favorite is not None:\n        data[\"is_favorite\"] = is_favorite\n    if view_style is not None:\n        data[\"view_style\"] = view_style\n\n    project_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Project.from_dict(project_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_section","title":"<code>add_section(name, project_id, *, order=None)</code>","text":"<p>Create a new section within a project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the section.</p> required <code>project_id</code> <code>str</code> <p>The ID of the project to add the section to.</p> required <code>order</code> <code>int | None</code> <p>The order of the section among all sections in the project.</p> <code>None</code> <p>Returns:</p> Type Description <code>Section</code> <p>The newly created section.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Section dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_section(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(2048)],\n    project_id: str,\n    *,\n    order: int | None = None,\n) -&gt; Section:\n    \"\"\"\n    Create a new section within a project.\n\n    :param name: The name of the section.\n    :param project_id: The ID of the project to add the section to.\n    :param order: The order of the section among all sections in the project.\n    :return: The newly created section.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Section dictionary.\n    \"\"\"\n    endpoint = get_api_url(SECTIONS_PATH)\n\n    data: dict[str, Any] = {\"name\": name, \"project_id\": project_id}\n    if order is not None:\n        data[\"order\"] = order\n\n    section_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Section.from_dict(section_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_task","title":"<code>add_task(content, *, description=None, project_id=None, section_id=None, parent_id=None, labels=None, priority=None, due_string=None, due_lang=None, due_date=None, due_datetime=None, assignee_id=None, order=None, auto_reminder=None, auto_parse_labels=None, duration=None, duration_unit=None, deadline_date=None, deadline_lang=None)</code>","text":"<p>Create a new task.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text content of the task.</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to add the task to.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>The ID of the section to add the task to.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent task.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>The task's labels (a list of names).</p> <code>None</code> <code>priority</code> <code>int | None</code> <p>The priority of the task (4 for very urgent).</p> <code>None</code> <code>due_string</code> <code>str | None</code> <p>The due date in natural language format.</p> <code>None</code> <code>due_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the due date (e.g., 'en').</p> <code>None</code> <code>due_date</code> <code>date | None</code> <p>The due date as a date object.</p> <code>None</code> <code>due_datetime</code> <code>datetime | None</code> <p>The due date and time as a datetime object.</p> <code>None</code> <code>assignee_id</code> <code>str | None</code> <p>User ID to whom the task is assigned.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the task.</p> <code>None</code> <code>order</code> <code>int | None</code> <p>The order of task in the project or section.</p> <code>None</code> <code>auto_reminder</code> <code>bool | None</code> <p>Whether to add default reminder if date with time is set.</p> <code>None</code> <code>auto_parse_labels</code> <code>bool | None</code> <p>Whether to parse labels from task content.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>The amount of time the task will take.</p> <code>None</code> <code>duration_unit</code> <code>Literal['minute', 'day'] | None</code> <p>The unit of time for duration.</p> <code>None</code> <code>deadline_date</code> <code>date | None</code> <p>The deadline date as a date object.</p> <code>None</code> <code>deadline_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the deadline date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Task</code> <p>The newly created task.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Task dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_task(  # noqa: PLR0912\n    self,\n    content: Annotated[str, MinLen(1), MaxLen(500)],\n    *,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    labels: list[Annotated[str, MaxLen(100)]] | None = None,\n    priority: Annotated[int, Ge(1), Le(4)] | None = None,\n    due_string: Annotated[str, MaxLen(150)] | None = None,\n    due_lang: LanguageCode | None = None,\n    due_date: date | None = None,\n    due_datetime: datetime | None = None,\n    assignee_id: str | None = None,\n    order: int | None = None,\n    auto_reminder: bool | None = None,\n    auto_parse_labels: bool | None = None,\n    duration: Annotated[int, Ge(1)] | None = None,\n    duration_unit: Literal[\"minute\", \"day\"] | None = None,\n    deadline_date: date | None = None,\n    deadline_lang: LanguageCode | None = None,\n) -&gt; Task:\n    \"\"\"\n    Create a new task.\n\n    :param content: The text content of the task.\n    :param project_id: The ID of the project to add the task to.\n    :param section_id: The ID of the section to add the task to.\n    :param parent_id: The ID of the parent task.\n    :param labels: The task's labels (a list of names).\n    :param priority: The priority of the task (4 for very urgent).\n    :param due_string: The due date in natural language format.\n    :param due_lang: Language for parsing the due date (e.g., 'en').\n    :param due_date: The due date as a date object.\n    :param due_datetime: The due date and time as a datetime object.\n    :param assignee_id: User ID to whom the task is assigned.\n    :param description: Description for the task.\n    :param order: The order of task in the project or section.\n    :param auto_reminder: Whether to add default reminder if date with time is set.\n    :param auto_parse_labels: Whether to parse labels from task content.\n    :param duration: The amount of time the task will take.\n    :param duration_unit: The unit of time for duration.\n    :param deadline_date: The deadline date as a date object.\n    :param deadline_lang: Language for parsing the deadline date.\n    :return: The newly created task.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Task dictionary.\n    \"\"\"\n    endpoint = get_api_url(TASKS_PATH)\n\n    data: dict[str, Any] = {\"content\": content}\n    if description is not None:\n        data[\"description\"] = description\n    if project_id is not None:\n        data[\"project_id\"] = project_id\n    if section_id is not None:\n        data[\"section_id\"] = section_id\n    if parent_id is not None:\n        data[\"parent_id\"] = parent_id\n    if labels is not None:\n        data[\"labels\"] = labels\n    if priority is not None:\n        data[\"priority\"] = priority\n    if due_string is not None:\n        data[\"due_string\"] = due_string\n    if due_lang is not None:\n        data[\"due_lang\"] = due_lang\n    if due_date is not None:\n        data[\"due_date\"] = format_date(due_date)\n    if due_datetime is not None:\n        data[\"due_datetime\"] = format_datetime(due_datetime)\n    if assignee_id is not None:\n        data[\"assignee_id\"] = assignee_id\n    if order is not None:\n        data[\"order\"] = order\n    if auto_reminder is not None:\n        data[\"auto_reminder\"] = auto_reminder\n    if auto_parse_labels is not None:\n        data[\"auto_parse_labels\"] = auto_parse_labels\n    if duration is not None:\n        data[\"duration\"] = duration\n    if duration_unit is not None:\n        data[\"duration_unit\"] = duration_unit\n    if deadline_date is not None:\n        data[\"deadline_date\"] = format_date(deadline_date)\n    if deadline_lang is not None:\n        data[\"deadline_lang\"] = deadline_lang\n\n    task_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Task.from_dict(task_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_task_quick","title":"<code>add_task_quick(text, *, note=None, reminder=None, auto_reminder=True)</code>","text":"<p>Create a new task using Todoist's Quick Add syntax.</p> <p>This automatically parses dates, deadlines, projects, labels, priorities, etc, from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The task text using Quick Add syntax.</p> required <code>note</code> <code>str | None</code> <p>Optional note to be added to the task.</p> <code>None</code> <code>reminder</code> <code>str | None</code> <p>Optional reminder date in free form text.</p> <code>None</code> <code>auto_reminder</code> <code>bool</code> <p>Whether to add default reminder if date with time is set.</p> <code>True</code> <p>Returns:</p> Type Description <code>Task</code> <p>A result object containing the parsed task data and metadata.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response cannot be parsed into a QuickAddResult.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_task_quick(\n    self,\n    text: str,\n    *,\n    note: str | None = None,\n    reminder: str | None = None,\n    auto_reminder: bool = True,\n) -&gt; Task:\n    \"\"\"\n    Create a new task using Todoist's Quick Add syntax.\n\n    This automatically parses dates, deadlines, projects, labels, priorities, etc,\n    from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").\n\n    :param text: The task text using Quick Add syntax.\n    :param note: Optional note to be added to the task.\n    :param reminder: Optional reminder date in free form text.\n    :param auto_reminder: Whether to add default reminder if date with time is set.\n    :return: A result object containing the parsed task data and metadata.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response cannot be parsed into a QuickAddResult.\n    \"\"\"\n    endpoint = get_api_url(TASKS_QUICK_ADD_PATH)\n\n    data = {\n        \"meta\": True,\n        \"text\": text,\n        \"auto_reminder\": auto_reminder,\n    }\n\n    if note is not None:\n        data[\"note\"] = note\n    if reminder is not None:\n        data[\"reminder\"] = reminder\n\n    task_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Task.from_dict(task_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.archive_project","title":"<code>archive_project(project_id)</code>","text":"<p>Archive a project.</p> <p>For personal projects, archives it only for the user. For workspace projects, archives it for all members.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to archive.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The archived project object.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def archive_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Archive a project.\n\n    For personal projects, archives it only for the user.\n    For workspace projects, archives it for all members.\n\n    :param project_id: The ID of the project to archive.\n    :return: The archived project object.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(\n        f\"{PROJECTS_PATH}/{project_id}/{PROJECT_ARCHIVE_PATH_SUFFIX}\"\n    )\n    project_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return Project.from_dict(project_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.complete_task","title":"<code>complete_task(task_id)</code>","text":"<p>Complete a task.</p> <p>For recurring tasks, this schedules the next occurrence. For non-recurring tasks, it marks them as completed.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to close.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was closed successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def complete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Complete a task.\n\n    For recurring tasks, this schedules the next occurrence.\n    For non-recurring tasks, it marks them as completed.\n\n    :param task_id: The ID of the task to close.\n    :return: True if the task was closed successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/close\")\n    return post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_comment","title":"<code>delete_comment(comment_id)</code>","text":"<p>Delete a comment.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the comment was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_comment(self, comment_id: str) -&gt; bool:\n    \"\"\"\n    Delete a comment.\n\n    :param comment_id: The ID of the comment to delete.\n    :return: True if the comment was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    return delete(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_label","title":"<code>delete_label(label_id)</code>","text":"<p>Delete a personal label.</p> <p>Instances of the label will be removed from tasks.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the label was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_label(self, label_id: str) -&gt; bool:\n    \"\"\"\n    Delete a personal label.\n\n    Instances of the label will be removed from tasks.\n\n    :param label_id: The ID of the label to delete.\n    :return: True if the label was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n    return delete(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_project","title":"<code>delete_project(project_id)</code>","text":"<p>Delete a project.</p> <p>All nested sections and tasks will also be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the project was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_project(self, project_id: str) -&gt; bool:\n    \"\"\"\n    Delete a project.\n\n    All nested sections and tasks will also be deleted.\n\n    :param project_id: The ID of the project to delete.\n    :return: True if the project was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n    return delete(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_section","title":"<code>delete_section(section_id)</code>","text":"<p>Delete a section.</p> <p>All tasks within the section will also be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the section was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_section(self, section_id: str) -&gt; bool:\n    \"\"\"\n    Delete a section.\n\n    All tasks within the section will also be deleted.\n\n    :param section_id: The ID of the section to delete.\n    :return: True if the section was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    return delete(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_task","title":"<code>delete_task(task_id)</code>","text":"<p>Delete a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Delete a task.\n\n    :param task_id: The ID of the task to delete.\n    :return: True if the task was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n    return delete(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.filter_tasks","title":"<code>filter_tasks(*, query=None, lang=None, limit=None)</code>","text":"<p>Get an iterable of lists of active tasks matching the filter.</p> <p>The response is an iterable of lists of active tasks matching the criteria. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>Query tasks using Todoist's filter language.</p> <code>None</code> <code>lang</code> <code>str | None</code> <p>Language for task content (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Task]]</code> <p>An iterable of lists of tasks.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def filter_tasks(\n    self,\n    *,\n    query: Annotated[str, MaxLen(1024)] | None = None,\n    lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of active tasks matching the filter.\n\n    The response is an iterable of lists of active tasks matching the criteria.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query tasks using Todoist's filter language.\n    :param lang: Language for task content (e.g., 'en').\n    :param limit: Maximum number of tasks per page.\n    :return: An iterable of lists of tasks.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_FILTER_PATH)\n\n    params: dict[str, Any] = {}\n    if query is not None:\n        params[\"query\"] = query\n    if lang is not None:\n        params[\"lang\"] = lang\n    if limit is not None:\n        params[\"limit\"] = limit\n\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"results\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_collaborators","title":"<code>get_collaborators(project_id, limit=None)</code>","text":"<p>Get an iterable of lists of collaborators in shared projects.</p> <p>The response is an iterable of lists of collaborators in shared projects, Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project.</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of collaborators per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Collaborator]]</code> <p>An iterable of lists of collaborators.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_collaborators(\n    self,\n    project_id: str,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Collaborator]]:\n    \"\"\"\n    Get an iterable of lists of collaborators in shared projects.\n\n    The response is an iterable of lists of collaborators in shared projects,\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: The ID of the project.\n    :param limit: Maximum number of collaborators per page.\n    :return: An iterable of lists of collaborators.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}/{COLLABORATORS_PATH}\")\n    params: dict[str, Any] = {}\n    if limit is not None:\n        params[\"limit\"] = limit\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"results\",\n        Collaborator.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_comment","title":"<code>get_comment(comment_id)</code>","text":"<p>Get a specific comment by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to retrieve.</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>The requested comment.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Comment dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_comment(self, comment_id: str) -&gt; Comment:\n    \"\"\"\n    Get a specific comment by its ID.\n\n    :param comment_id: The ID of the comment to retrieve.\n    :return: The requested comment.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Comment dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    comment_data: dict[str, Any] = get(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return Comment.from_dict(comment_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_comments","title":"<code>get_comments(*, project_id=None, task_id=None, limit=None)</code>","text":"<p>Get an iterable of lists of comments for a task or project.</p> <p>Requires either <code>project_id</code> or <code>task_id</code> to be set.</p> <p>The response is an iterable of lists of comments. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>The ID of the project to retrieve comments for.</p> <code>None</code> <code>task_id</code> <code>str | None</code> <p>The ID of the task to retrieve comments for.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of comments per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Comment]]</code> <p>An iterable of lists of comments.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>project_id</code> nor <code>task_id</code> is provided.</p> <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_comments(\n    self,\n    *,\n    project_id: str | None = None,\n    task_id: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Comment]]:\n    \"\"\"\n    Get an iterable of lists of comments for a task or project.\n\n    Requires either `project_id` or `task_id` to be set.\n\n    The response is an iterable of lists of comments.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: The ID of the project to retrieve comments for.\n    :param task_id: The ID of the task to retrieve comments for.\n    :param limit: Maximum number of comments per page.\n    :return: An iterable of lists of comments.\n    :raises ValueError: If neither `project_id` nor `task_id` is provided.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    if project_id is None and task_id is None:\n        raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n    endpoint = get_api_url(COMMENTS_PATH)\n\n    params: dict[str, Any] = {}\n    if project_id is not None:\n        params[\"project_id\"] = project_id\n    if task_id is not None:\n        params[\"task_id\"] = task_id\n    if limit is not None:\n        params[\"limit\"] = limit\n\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"results\",\n        Comment.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_completed_tasks_by_completion_date","title":"<code>get_completed_tasks_by_completion_date(*, since, until, workspace_id=None, filter_query=None, filter_lang=None, limit=None)</code>","text":"<p>Get an iterable of lists of completed tasks within a date range.</p> <p>Retrieves tasks completed within a specific date range (up to 3 months). Supports filtering by workspace or a filter query.</p> <p>The response is an iterable of lists of completed tasks. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>datetime</code> <p>Start of the date range (inclusive).</p> required <code>until</code> <code>datetime</code> <p>End of the date range (inclusive).</p> required <code>workspace_id</code> <code>str | None</code> <p>Filter by workspace ID.</p> <code>None</code> <code>filter_query</code> <code>str | None</code> <p>Filter by a query string.</p> <code>None</code> <code>filter_lang</code> <code>str | None</code> <p>Language for the filter query (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (default 50).</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Task]]</code> <p>An iterable of lists of completed tasks.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_completed_tasks_by_completion_date(\n    self,\n    *,\n    since: datetime,\n    until: datetime,\n    workspace_id: str | None = None,\n    filter_query: str | None = None,\n    filter_lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of completed tasks within a date range.\n\n    Retrieves tasks completed within a specific date range (up to 3 months).\n    Supports filtering by workspace or a filter query.\n\n    The response is an iterable of lists of completed tasks. Be aware that each\n    iteration fires off a network request to the Todoist API, and may result in\n    rate limiting or other API restrictions.\n\n    :param since: Start of the date range (inclusive).\n    :param until: End of the date range (inclusive).\n    :param workspace_id: Filter by workspace ID.\n    :param filter_query: Filter by a query string.\n    :param filter_lang: Language for the filter query (e.g., 'en').\n    :param limit: Maximum number of tasks per page (default 50).\n    :return: An iterable of lists of completed tasks.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_COMPLETED_BY_COMPLETION_DATE_PATH)\n\n    params: dict[str, Any] = {\n        \"since\": format_datetime(since),\n        \"until\": format_datetime(until),\n    }\n    if workspace_id is not None:\n        params[\"workspace_id\"] = workspace_id\n    if filter_query is not None:\n        params[\"filter_query\"] = filter_query\n    if filter_lang is not None:\n        params[\"filter_lang\"] = filter_lang\n    if limit is not None:\n        params[\"limit\"] = limit\n\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"items\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_completed_tasks_by_due_date","title":"<code>get_completed_tasks_by_due_date(*, since, until, workspace_id=None, project_id=None, section_id=None, parent_id=None, filter_query=None, filter_lang=None, limit=None)</code>","text":"<p>Get an iterable of lists of completed tasks within a due date range.</p> <p>Retrieves tasks completed within a specific due date range (up to 6 weeks). Supports filtering by workspace, project, section, parent task, or a query.</p> <p>The response is an iterable of lists of completed tasks. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>datetime</code> <p>Start of the date range (inclusive).</p> required <code>until</code> <code>datetime</code> <p>End of the date range (inclusive).</p> required <code>workspace_id</code> <code>str | None</code> <p>Filter by workspace ID.</p> <code>None</code> <code>project_id</code> <code>str | None</code> <p>Filter by project ID.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>Filter by section ID.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter by parent task ID.</p> <code>None</code> <code>filter_query</code> <code>str | None</code> <p>Filter by a query string.</p> <code>None</code> <code>filter_lang</code> <code>str | None</code> <p>Language for the filter query (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (default 50).</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Task]]</code> <p>An iterable of lists of completed tasks.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_completed_tasks_by_due_date(\n    self,\n    *,\n    since: datetime,\n    until: datetime,\n    workspace_id: str | None = None,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    filter_query: str | None = None,\n    filter_lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of completed tasks within a due date range.\n\n    Retrieves tasks completed within a specific due date range (up to 6 weeks).\n    Supports filtering by workspace, project, section, parent task, or a query.\n\n    The response is an iterable of lists of completed tasks. Be aware that each\n    iteration fires off a network request to the Todoist API, and may result in\n    rate limiting or other API restrictions.\n\n    :param since: Start of the date range (inclusive).\n    :param until: End of the date range (inclusive).\n    :param workspace_id: Filter by workspace ID.\n    :param project_id: Filter by project ID.\n    :param section_id: Filter by section ID.\n    :param parent_id: Filter by parent task ID.\n    :param filter_query: Filter by a query string.\n    :param filter_lang: Language for the filter query (e.g., 'en').\n    :param limit: Maximum number of tasks per page (default 50).\n    :return: An iterable of lists of completed tasks.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_COMPLETED_BY_DUE_DATE_PATH)\n\n    params: dict[str, Any] = {\n        \"since\": format_datetime(since),\n        \"until\": format_datetime(until),\n    }\n    if workspace_id is not None:\n        params[\"workspace_id\"] = workspace_id\n    if project_id is not None:\n        params[\"project_id\"] = project_id\n    if section_id is not None:\n        params[\"section_id\"] = section_id\n    if parent_id is not None:\n        params[\"parent_id\"] = parent_id\n    if filter_query is not None:\n        params[\"filter_query\"] = filter_query\n    if filter_lang is not None:\n        params[\"filter_lang\"] = filter_lang\n    if limit is not None:\n        params[\"limit\"] = limit\n\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"items\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_label","title":"<code>get_label(label_id)</code>","text":"<p>Get a specific personal label by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label to retrieve.</p> required <p>Returns:</p> Type Description <code>Label</code> <p>The requested label.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Label dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_label(self, label_id: str) -&gt; Label:\n    \"\"\"\n    Get a specific personal label by its ID.\n\n    :param label_id: The ID of the label to retrieve.\n    :return: The requested label.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Label dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n    label_data: dict[str, Any] = get(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return Label.from_dict(label_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_labels","title":"<code>get_labels(*, limit=None)</code>","text":"<p>Get an iterable of lists of personal labels.</p> <p>Supports pagination arguments.</p> <p>The response is an iterable of lists of personal labels. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>` number of labels per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Label]]</code> <p>An iterable of lists of personal labels.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_labels(\n    self,\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Label]]:\n    \"\"\"\n    Get an iterable of lists of personal labels.\n\n    Supports pagination arguments.\n\n    The response is an iterable of lists of personal labels.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param limit: ` number of labels per page.\n    :return: An iterable of lists of personal labels.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(LABELS_PATH)\n\n    params: dict[str, Any] = {}\n    if limit is not None:\n        params[\"limit\"] = limit\n\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"results\",\n        Label.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_project","title":"<code>get_project(project_id)</code>","text":"<p>Get a project by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to retrieve.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The requested project.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Get a project by its ID.\n\n    :param project_id: The ID of the project to retrieve.\n    :return: The requested project.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n    project_data: dict[str, Any] = get(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return Project.from_dict(project_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_projects","title":"<code>get_projects(limit=None)</code>","text":"<p>Get an iterable of lists of active projects.</p> <p>The response is an iterable of lists of active projects. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of projects per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Project]]</code> <p>An iterable of lists of projects.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_projects(\n    self,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Project]]:\n    \"\"\"\n    Get an iterable of lists of active projects.\n\n    The response is an iterable of lists of active projects.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param limit: Maximum number of projects per page.\n    :return: An iterable of lists of projects.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(PROJECTS_PATH)\n    params: dict[str, Any] = {}\n    if limit is not None:\n        params[\"limit\"] = limit\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"results\",\n        Project.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_section","title":"<code>get_section(section_id)</code>","text":"<p>Get a specific section by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to retrieve.</p> required <p>Returns:</p> Type Description <code>Section</code> <p>The requested section.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Section dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_section(self, section_id: str) -&gt; Section:\n    \"\"\"\n    Get a specific section by its ID.\n\n    :param section_id: The ID of the section to retrieve.\n    :return: The requested section.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Section dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    section_data: dict[str, Any] = get(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return Section.from_dict(section_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_sections","title":"<code>get_sections(project_id=None, *, limit=None)</code>","text":"<p>Get an iterable of lists of active sections.</p> <p>Supports filtering by <code>project_id</code> and pagination arguments.</p> <p>The response is an iterable of lists of active sections. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>Filter sections by project ID.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of sections per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Section]]</code> <p>An iterable of lists of sections.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_sections(\n    self,\n    project_id: str | None = None,\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Section]]:\n    \"\"\"\n    Get an iterable of lists of active sections.\n\n    Supports filtering by `project_id` and pagination arguments.\n\n    The response is an iterable of lists of active sections.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: Filter sections by project ID.\n    :param limit: Maximum number of sections per page.\n    :return: An iterable of lists of sections.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(SECTIONS_PATH)\n\n    params: dict[str, Any] = {}\n    if project_id is not None:\n        params[\"project_id\"] = project_id\n    if limit is not None:\n        params[\"limit\"] = limit\n\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"results\",\n        Section.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_shared_labels","title":"<code>get_shared_labels(*, omit_personal=False, limit=None)</code>","text":"<p>Get an iterable of lists of shared label names.</p> <p>Includes labels from collaborators on shared projects that are not in the user's personal labels. Can optionally exclude personal label names using <code>omit_personal=True</code>. Supports pagination arguments.</p> <p>The response is an iterable of lists of shared label names. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>omit_personal</code> <code>bool</code> <p>Optional boolean flag to omit personal label names.</p> <code>False</code> <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[str]]</code> <p>An iterable of lists of shared label names (strings).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_shared_labels(\n    self,\n    *,\n    omit_personal: bool = False,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[str]]:\n    \"\"\"\n    Get an iterable of lists of shared label names.\n\n    Includes labels from collaborators on shared projects that are not in the\n    user's personal labels. Can optionally exclude personal label names using\n    `omit_personal=True`. Supports pagination arguments.\n\n    The response is an iterable of lists of shared label names.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param omit_personal: Optional boolean flag to omit personal label names.\n    :param limit: Maximum number of labels per page.\n    :return: An iterable of lists of shared label names (strings).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_PATH)\n\n    params: dict[str, Any] = {\"omit_personal\": omit_personal}\n    if limit is not None:\n        params[\"limit\"] = limit\n\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"results\",\n        str,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_task","title":"<code>get_task(task_id)</code>","text":"<p>Get a specific task by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>Task</code> <p>The requested task.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Task dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_task(self, task_id: str) -&gt; Task:\n    \"\"\"\n    Get a specific task by its ID.\n\n    :param task_id: The ID of the task to retrieve.\n    :return: The requested task.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Task dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n    task_data: dict[str, Any] = get(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return Task.from_dict(task_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_tasks","title":"<code>get_tasks(*, project_id=None, section_id=None, parent_id=None, label=None, ids=None, limit=None)</code>","text":"<p>Get an iterable of lists of active tasks.</p> <p>The response is an iterable of lists of active tasks matching the criteria. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>Filter tasks by project ID.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>Filter tasks by section ID.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter tasks by parent task ID.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Filter tasks by label name.</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>A list of the IDs of the tasks to retrieve.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Task]]</code> <p>An iterable of lists of tasks.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_tasks(\n    self,\n    *,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    label: str | None = None,\n    ids: list[str] | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of active tasks.\n\n    The response is an iterable of lists of active tasks matching the criteria.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: Filter tasks by project ID.\n    :param section_id: Filter tasks by section ID.\n    :param parent_id: Filter tasks by parent task ID.\n    :param label: Filter tasks by label name.\n    :param ids: A list of the IDs of the tasks to retrieve.\n    :param limit: Maximum number of tasks per page.\n    :return: An iterable of lists of tasks.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_PATH)\n\n    params: dict[str, Any] = {}\n    if project_id is not None:\n        params[\"project_id\"] = project_id\n    if section_id is not None:\n        params[\"section_id\"] = section_id\n    if parent_id is not None:\n        params[\"parent_id\"] = parent_id\n    if label is not None:\n        params[\"label\"] = label\n    if ids is not None:\n        params[\"ids\"] = \",\".join(str(i) for i in ids)\n    if limit is not None:\n        params[\"limit\"] = limit\n\n    return ResultsPaginator(\n        self._session,\n        endpoint,\n        \"results\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.move_task","title":"<code>move_task(task_id, project_id=None, section_id=None, parent_id=None)</code>","text":"<p>Move a task to a different project, section, or parent task.</p> <p><code>project_id</code> takes predence, followed by <code>section_id</code> (which also updates <code>project_id</code>), and then <code>parent_id</code> (which also updates <code>section_id</code> and <code>project_id</code>).</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to move.</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to move the task to.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>The ID of the section to move the task to.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent to move the task to.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was moved successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>ValueError</code> <p>If neither <code>project_id</code>, <code>section_id</code>, nor <code>parent_id</code> is provided.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def move_task(\n    self,\n    task_id: str,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n) -&gt; bool:\n    \"\"\"\n    Move a task to a different project, section, or parent task.\n\n    `project_id` takes predence, followed by\n    `section_id` (which also updates `project_id`),\n    and then `parent_id` (which also updates `section_id` and `project_id`).\n\n    :param task_id: The ID of the task to move.\n    :param project_id: The ID of the project to move the task to.\n    :param section_id: The ID of the section to move the task to.\n    :param parent_id: The ID of the parent to move the task to.\n    :return: True if the task was moved successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises ValueError: If neither `project_id`, `section_id`,\n            nor `parent_id` is provided.\n    \"\"\"\n    if project_id is None and section_id is None and parent_id is None:\n        raise ValueError(\n            \"Either `project_id`, `section_id`, or `parent_id` must be provided.\"\n        )\n\n    data: dict[str, Any] = {}\n    if project_id is not None:\n        data[\"project_id\"] = project_id\n    if section_id is not None:\n        data[\"section_id\"] = section_id\n    if parent_id is not None:\n        data[\"parent_id\"] = parent_id\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/move\")\n    return post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.remove_shared_label","title":"<code>remove_shared_label(name)</code>","text":"<p>Remove all occurrences of a shared label across all projects.</p> <p>This action removes the label string from all tasks where it appears.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the shared label to remove.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the removal was successful,</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def remove_shared_label(self, name: Annotated[str, MaxLen(60)]) -&gt; bool:\n    \"\"\"\n    Remove all occurrences of a shared label across all projects.\n\n    This action removes the label string from all tasks where it appears.\n\n    :param name: The name of the shared label to remove.\n    :return: True if the removal was successful,\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_REMOVE_PATH)\n    data = {\"name\": name}\n    return post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.rename_shared_label","title":"<code>rename_shared_label(name, new_name)</code>","text":"<p>Rename all occurrences of a shared label across all projects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The current name of the shared label to rename.</p> required <code>new_name</code> <code>str</code> <p>The new name for the shared label.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the rename was successful, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def rename_shared_label(\n    self,\n    name: Annotated[str, MaxLen(60)],\n    new_name: Annotated[str, MinLen(1), MaxLen(60)],\n) -&gt; bool:\n    \"\"\"\n    Rename all occurrences of a shared label across all projects.\n\n    :param name: The current name of the shared label to rename.\n    :param new_name: The new name for the shared label.\n    :return: True if the rename was successful,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_RENAME_PATH)\n    return post(\n        self._session,\n        endpoint,\n        self._token,\n        params={\"name\": name},\n        data={\"new_name\": new_name},\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.unarchive_project","title":"<code>unarchive_project(project_id)</code>","text":"<p>Unarchive a project.</p> <p>Restores a previously archived project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to unarchive.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The unarchived project object.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def unarchive_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Unarchive a project.\n\n    Restores a previously archived project.\n\n    :param project_id: The ID of the project to unarchive.\n    :return: The unarchived project object.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(\n        f\"{PROJECTS_PATH}/{project_id}/{PROJECT_UNARCHIVE_PATH_SUFFIX}\"\n    )\n    project_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return Project.from_dict(project_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.uncomplete_task","title":"<code>uncomplete_task(task_id)</code>","text":"<p>Uncomplete a (completed) task.</p> <p>Any parent tasks or sections will also be uncompleted.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to reopen.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was uncompleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def uncomplete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Uncomplete a (completed) task.\n\n    Any parent tasks or sections will also be uncompleted.\n\n    :param task_id: The ID of the task to reopen.\n    :return: True if the task was uncompleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/reopen\")\n    return post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_comment","title":"<code>update_comment(comment_id, content)</code>","text":"<p>Update an existing comment.</p> <p>Currently, only <code>content</code> can be updated.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to update.</p> required <code>content</code> <code>str</code> <p>The new text content for the comment.</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>the updated Comment.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_comment(\n    self, comment_id: str, content: Annotated[str, MaxLen(15000)]\n) -&gt; Comment:\n    \"\"\"\n    Update an existing comment.\n\n    Currently, only `content` can be updated.\n\n    :param comment_id: The ID of the comment to update.\n    :param content: The new text content for the comment.\n    :return: the updated Comment.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    comment_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data={\"content\": content},\n    )\n    return Comment.from_dict(comment_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_label","title":"<code>update_label(label_id, *, name=None, color=None, item_order=None, is_favorite=None)</code>","text":"<p>Update a personal label.</p> <p>Only the fields to be updated need to be provided as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label.</p> required <code>name</code> <code>str | None</code> <p>The name of the label.</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the label icon.</p> <code>None</code> <code>item_order</code> <code>int | None</code> <p>Label's order in the label list.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the label is a favorite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>the updated Label.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_label(\n    self,\n    label_id: str,\n    *,\n    name: Annotated[str, MinLen(1), MaxLen(60)] | None = None,\n    color: ColorString | None = None,\n    item_order: int | None = None,\n    is_favorite: bool | None = None,\n) -&gt; Label:\n    \"\"\"\n    Update a personal label.\n\n    Only the fields to be updated need to be provided as keyword arguments.\n\n    :param label_id: The ID of the label.\n    :param name: The name of the label.\n    :param color: The color of the label icon.\n    :param item_order: Label's order in the label list.\n    :param is_favorite: Whether the label is a favorite.\n    :return: the updated Label.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n\n    data: dict[str, Any] = {}\n    if name is not None:\n        data[\"name\"] = name\n    if color is not None:\n        data[\"color\"] = color\n    if item_order is not None:\n        data[\"item_order\"] = item_order\n    if is_favorite is not None:\n        data[\"is_favorite\"] = is_favorite\n\n    label_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Label.from_dict(label_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_project","title":"<code>update_project(project_id, *, name=None, description=None, color=None, is_favorite=None, view_style=None)</code>","text":"<p>Update an existing project.</p> <p>Only the fields to be updated need to be provided as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to update.</p> required <code>name</code> <code>str | None</code> <p>The name of the project.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the project (up to 1024 characters).</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the project icon.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the project is a favorite.</p> <code>None</code> <code>view_style</code> <code>ViewStyle | None</code> <p>A string value (either 'list' or 'board').</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>the updated Project.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_project(\n    self,\n    project_id: str,\n    *,\n    name: Annotated[str, MinLen(1), MaxLen(120)] | None = None,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    color: ColorString | None = None,\n    is_favorite: bool | None = None,\n    view_style: ViewStyle | None = None,\n) -&gt; Project:\n    \"\"\"\n    Update an existing project.\n\n    Only the fields to be updated need to be provided as keyword arguments.\n\n    :param project_id: The ID of the project to update.\n    :param name: The name of the project.\n    :param description: Description for the project (up to 1024 characters).\n    :param color: The color of the project icon.\n    :param is_favorite: Whether the project is a favorite.\n    :param view_style: A string value (either 'list' or 'board').\n    :return: the updated Project.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n\n    data: dict[str, Any] = {}\n\n    if name is not None:\n        data[\"name\"] = name\n    if description is not None:\n        data[\"description\"] = description\n    if color is not None:\n        data[\"color\"] = color\n    if is_favorite is not None:\n        data[\"is_favorite\"] = is_favorite\n    if view_style is not None:\n        data[\"view_style\"] = view_style\n\n    project_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Project.from_dict(project_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_section","title":"<code>update_section(section_id, name)</code>","text":"<p>Update an existing section.</p> <p>Currently, only <code>name</code> can be updated.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to update.</p> required <code>name</code> <code>str</code> <p>The new name for the section.</p> required <p>Returns:</p> Type Description <code>Section</code> <p>the updated Section.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_section(\n    self,\n    section_id: str,\n    name: Annotated[str, MinLen(1), MaxLen(2048)],\n) -&gt; Section:\n    \"\"\"\n    Update an existing section.\n\n    Currently, only `name` can be updated.\n\n    :param section_id: The ID of the section to update.\n    :param name: The new name for the section.\n    :return: the updated Section.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    section_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data={\"name\": name},\n    )\n    return Section.from_dict(section_data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_task","title":"<code>update_task(task_id, *, content=None, description=None, labels=None, priority=None, due_string=None, due_lang=None, due_date=None, due_datetime=None, assignee_id=None, day_order=None, collapsed=None, duration=None, duration_unit=None, deadline_date=None, deadline_lang=None)</code>","text":"<p>Update an existing task.</p> <p>Only the fields to be updated need to be provided.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>content</code> <code>str | None</code> <p>The text content of the task.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the task.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>The task's labels (a list of names).</p> <code>None</code> <code>priority</code> <code>int | None</code> <p>The priority of the task (4 for very urgent).</p> <code>None</code> <code>due_string</code> <code>str | None</code> <p>The due date in natural language format.</p> <code>None</code> <code>due_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the due date (e.g., 'en').</p> <code>None</code> <code>due_date</code> <code>date | None</code> <p>The due date as a date object.</p> <code>None</code> <code>due_datetime</code> <code>datetime | None</code> <p>The due date and time as a datetime object.</p> <code>None</code> <code>assignee_id</code> <code>str | None</code> <p>User ID to whom the task is assigned.</p> <code>None</code> <code>day_order</code> <code>int | None</code> <p>The order of the task inside Today or Next 7 days view.</p> <code>None</code> <code>collapsed</code> <code>bool | None</code> <p>Whether the task's sub-tasks are collapsed.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>The amount of time the task will take.</p> <code>None</code> <code>duration_unit</code> <code>Literal['minute', 'day'] | None</code> <p>The unit of time for duration.</p> <code>None</code> <code>deadline_date</code> <code>date | None</code> <p>The deadline date as a date object.</p> <code>None</code> <code>deadline_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the deadline date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Task</code> <p>the updated Task.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_task(  # noqa: PLR0912\n    self,\n    task_id: str,\n    *,\n    content: Annotated[str, MinLen(1), MaxLen(500)] | None = None,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    labels: list[Annotated[str, MaxLen(60)]] | None = None,\n    priority: Annotated[int, Ge(1), Le(4)] | None = None,\n    due_string: Annotated[str, MaxLen(150)] | None = None,\n    due_lang: LanguageCode | None = None,\n    due_date: date | None = None,\n    due_datetime: datetime | None = None,\n    assignee_id: str | None = None,\n    day_order: int | None = None,\n    collapsed: bool | None = None,\n    duration: Annotated[int, Ge(1)] | None = None,\n    duration_unit: Literal[\"minute\", \"day\"] | None = None,\n    deadline_date: date | None = None,\n    deadline_lang: LanguageCode | None = None,\n) -&gt; Task:\n    \"\"\"\n    Update an existing task.\n\n    Only the fields to be updated need to be provided.\n\n    :param task_id: The ID of the task to update.\n    :param content: The text content of the task.\n    :param description: Description for the task.\n    :param labels: The task's labels (a list of names).\n    :param priority: The priority of the task (4 for very urgent).\n    :param due_string: The due date in natural language format.\n    :param due_lang: Language for parsing the due date (e.g., 'en').\n    :param due_date: The due date as a date object.\n    :param due_datetime: The due date and time as a datetime object.\n    :param assignee_id: User ID to whom the task is assigned.\n    :param day_order: The order of the task inside Today or Next 7 days view.\n    :param collapsed: Whether the task's sub-tasks are collapsed.\n    :param duration: The amount of time the task will take.\n    :param duration_unit: The unit of time for duration.\n    :param deadline_date: The deadline date as a date object.\n    :param deadline_lang: Language for parsing the deadline date.\n    :return: the updated Task.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n\n    data: dict[str, Any] = {}\n    if content is not None:\n        data[\"content\"] = content\n    if description is not None:\n        data[\"description\"] = description\n    if labels is not None:\n        data[\"labels\"] = labels\n    if priority is not None:\n        data[\"priority\"] = priority\n    if due_string is not None:\n        data[\"due_string\"] = due_string\n    if due_lang is not None:\n        data[\"due_lang\"] = due_lang\n    if due_date is not None:\n        data[\"due_date\"] = format_date(due_date)\n    if due_datetime is not None:\n        data[\"due_datetime\"] = format_datetime(due_datetime)\n    if assignee_id is not None:\n        data[\"assignee_id\"] = assignee_id\n    if day_order is not None:\n        data[\"day_order\"] = day_order\n    if collapsed is not None:\n        data[\"collapsed\"] = collapsed\n    if duration is not None:\n        data[\"duration\"] = duration\n    if duration_unit is not None:\n        data[\"duration_unit\"] = duration_unit\n    if deadline_date is not None:\n        data[\"deadline_date\"] = format_date(deadline_date)\n    if deadline_lang is not None:\n        data[\"deadline_lang\"] = deadline_lang\n\n    task_data: dict[str, Any] = post(\n        self._session,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return Task.from_dict(task_data)\n</code></pre>"},{"location":"api_async/","title":"API Client (async)","text":"<p>Async client for the Todoist API.</p> <p>Provides asynchronous methods for interacting with Todoist resources like tasks, projects,labels, comments, etc.</p> <p>Manages an HTTP session and handles authentication. Can be used as an async context manager to ensure the session is closed properly.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>class TodoistAPIAsync:\n    \"\"\"\n    Async client for the Todoist API.\n\n    Provides asynchronous methods for interacting with Todoist resources like tasks,\n    projects,labels, comments, etc.\n\n    Manages an HTTP session and handles authentication. Can be used as an async context\n    manager to ensure the session is closed properly.\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        request_id_fn: Callable[[], str] | None = default_request_id_fn,\n        session: requests.Session | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the TodoistAPIAsync client.\n\n        :param token: Authentication token for the Todoist API.\n        :param session: An optional pre-configured requests `Session` object.\n        \"\"\"\n        self._api = TodoistAPI(token, request_id_fn, session)\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"\n        Enters the async runtime context related to this object.\n\n        The with statement will bind this method's return value to the target(s)\n        specified in the as clause of the statement, if any.\n\n        :return: This TodoistAPIAsync instance.\n        \"\"\"\n        return self\n\n    def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit the async runtime context and closes the underlying requests session.\"\"\"\n\n    async def get_task(self, task_id: str) -&gt; Task:\n        \"\"\"\n        Get a specific task by its ID.\n\n        :param task_id: The ID of the task to retrieve.\n        :return: The requested task.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Task dictionary.\n        \"\"\"\n        return await run_async(lambda: self._api.get_task(task_id))\n\n    async def get_tasks(\n        self,\n        *,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        label: str | None = None,\n        ids: list[str] | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Task]]:\n        \"\"\"\n        Get a list of active tasks.\n\n        :param project_id: Filter tasks by project ID.\n        :param section_id: Filter tasks by section ID.\n        :param parent_id: Filter tasks by parent task ID.\n        :param label: Filter tasks by label name.\n        :param ids: A list of the IDs of the tasks to retrieve.\n        :param limit: Maximum number of tasks per page (between 1 and 200).\n        :return: A list of tasks.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_tasks(\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            label=label,\n            ids=ids,\n            limit=limit,\n        )\n\n        return generate_async(paginator)\n\n    async def filter_tasks(\n        self,\n        *,\n        query: Annotated[str, MaxLen(1024)] | None = None,\n        lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Task]]:\n        \"\"\"\n        Get a lists of active tasks matching the filter.\n\n        The response is an iterable of lists of active tasks matching the criteria.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query tasks using Todoist's filter language.\n        :param lang: Language for task content (e.g., 'en').\n        :param limit: Maximum number of tasks per page (between 1 and 200).\n        :return: An iterable of lists of tasks.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.filter_tasks(\n            query=query,\n            lang=lang,\n            limit=limit,\n        )\n        return generate_async(paginator)\n\n    async def add_task(\n        self,\n        content: Annotated[str, MinLen(1), MaxLen(500)],\n        *,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        labels: list[Annotated[str, MaxLen(100)]] | None = None,\n        priority: Annotated[int, Ge(1), Le(4)] | None = None,\n        due_string: Annotated[str, MaxLen(150)] | None = None,\n        due_date: date | None = None,\n        due_datetime: datetime | None = None,\n        due_lang: LanguageCode | None = None,\n        assignee_id: str | None = None,\n        order: int | None = None,\n        auto_reminder: bool | None = None,\n        auto_parse_labels: bool | None = None,\n        duration: Annotated[int, Ge(1)] | None = None,\n        duration_unit: Literal[\"minute\", \"day\"] | None = None,\n        deadline_date: date | None = None,\n        deadline_lang: LanguageCode | None = None,\n    ) -&gt; Task:\n        \"\"\"\n        Create a new task.\n\n        :param content: The text content of the task.\n        :param project_id: The ID of the project to add the task to.\n        :param section_id: The ID of the section to add the task to.\n        :param parent_id: The ID of the parent task.\n        :param labels: The task's labels (a list of names).\n        :param priority: The priority of the task (4 for very urgent).\n        :param due_string: The due date in natural language format.\n        :param due_lang: Language for parsing the due date (e.g., 'en').\n        :param due_date: The due date as a date object.\n        :param due_datetime: The due date and time as a datetime object.\n        :param assignee_id: User ID to whom the task is assigned.\n        :param description: Description for the task.\n        :param order: The order of task in the project or section.\n        :param auto_reminder: Whether to add default reminder if date with time is set.\n        :param auto_parse_labels: Whether to parse labels from task content.\n        :param duration: The amount of time the task will take.\n        :param duration_unit: The unit of time for duration.\n        :param deadline_date: The deadline date as a date object.\n        :param deadline_lang: Language for parsing the deadline date.\n        :return: The newly created task.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Task dictionary.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.add_task(\n                content,\n                description=description,\n                project_id=project_id,\n                section_id=section_id,\n                parent_id=parent_id,\n                labels=labels,\n                priority=priority,\n                due_string=due_string,\n                due_lang=due_lang,\n                due_date=due_date,\n                due_datetime=due_datetime,\n                assignee_id=assignee_id,\n                order=order,\n                auto_reminder=auto_reminder,\n                auto_parse_labels=auto_parse_labels,\n                duration=duration,\n                duration_unit=duration_unit,\n                deadline_date=deadline_date,\n                deadline_lang=deadline_lang,\n            )\n        )\n\n    async def add_task_quick(\n        self,\n        text: str,\n        *,\n        note: str | None = None,\n        reminder: str | None = None,\n        auto_reminder: bool = True,\n    ) -&gt; Task:\n        \"\"\"\n        Create a new task using Todoist's Quick Add syntax.\n\n        This automatically parses dates, deadlines, projects, labels, priorities, etc,\n        from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").\n\n        :param text: The task text using Quick Add syntax.\n        :param note: Optional note to be added to the task.\n        :param reminder: Optional reminder date in free form text.\n        :param auto_reminder: Whether to add default reminder if date with time is set.\n        :return: A result object containing the parsed task data and metadata.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response cannot be parsed into a QuickAddResult.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.add_task_quick(\n                text, note=note, reminder=reminder, auto_reminder=auto_reminder\n            )\n        )\n\n    async def update_task(\n        self,\n        task_id: str,\n        *,\n        content: Annotated[str, MinLen(1), MaxLen(500)] | None = None,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        labels: list[Annotated[str, MaxLen(60)]] | None = None,\n        priority: Annotated[int, Ge(1), Le(4)] | None = None,\n        due_string: Annotated[str, MaxLen(150)] | None = None,\n        due_lang: LanguageCode | None = None,\n        due_date: date | None = None,\n        due_datetime: datetime | None = None,\n        assignee_id: str | None = None,\n        day_order: int | None = None,\n        collapsed: bool | None = None,\n        duration: Annotated[int, Ge(1)] | None = None,\n        duration_unit: Literal[\"minute\", \"day\"] | None = None,\n        deadline_date: date | None = None,\n        deadline_lang: LanguageCode | None = None,\n    ) -&gt; Task:\n        \"\"\"\n        Update an existing task.\n\n        Only the fields to be updated need to be provided.\n\n        :param task_id: The ID of the task to update.\n        :param content: The text content of the task.\n        :param description: Description for the task.\n        :param labels: The task's labels (a list of names).\n        :param priority: The priority of the task (4 for very urgent).\n        :param due_string: The due date in natural language format.\n        :param due_lang: Language for parsing the due date (e.g., 'en').\n        :param due_date: The due date as a date object.\n        :param due_datetime: The due date and time as a datetime object.\n        :param assignee_id: User ID to whom the task is assigned.\n        :param day_order: The order of the task inside Today or Next 7 days view.\n        :param collapsed: Whether the task's sub-tasks are collapsed.\n        :param duration: The amount of time the task will take.\n        :param duration_unit: The unit of time for duration.\n        :param deadline_date: The deadline date as a date object.\n        :param deadline_lang: Language for parsing the deadline date.\n        :return: the updated Task.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.update_task(\n                task_id,\n                content=content,\n                description=description,\n                labels=labels,\n                priority=priority,\n                due_string=due_string,\n                due_date=due_date,\n                due_datetime=due_datetime,\n                due_lang=due_lang,\n                assignee_id=assignee_id,\n                day_order=day_order,\n                collapsed=collapsed,\n                duration=duration,\n                duration_unit=duration_unit,\n                deadline_date=deadline_date,\n                deadline_lang=deadline_lang,\n            )\n        )\n\n    async def complete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Complete a task.\n\n        For recurring tasks, this schedules the next occurrence.\n        For non-recurring tasks, it marks them as completed.\n\n        :param task_id: The ID of the task to close.\n        :return: True if the task was closed successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.complete_task(task_id))\n\n    async def uncomplete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Uncomplete a (completed) task.\n\n        Any parent tasks or sections will also be uncompleted.\n\n        :param task_id: The ID of the task to reopen.\n        :return: True if the task was uncompleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.uncomplete_task(task_id))\n\n    async def move_task(\n        self,\n        task_id: str,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n    ) -&gt; bool:\n        \"\"\"\n        Move a task to a different project, section, or parent task.\n\n        `project_id` takes predence, followed by\n        `section_id` (which also updates `project_id`),\n        and then `parent_id` (which also updates `section_id` and `project_id`).\n\n        :param task_id: The ID of the task to move.\n        :param project_id: The ID of the project to move the task to.\n        :param section_id: The ID of the section to move the task to.\n        :param parent_id: The ID of the parent to move the task to.\n        :return: True if the task was moved successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises ValueError: If neither `project_id`, `section_id`,\n                nor `parent_id` is provided.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.move_task(\n                task_id,\n                project_id=project_id,\n                section_id=section_id,\n                parent_id=parent_id,\n            )\n        )\n\n    async def delete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Delete a task.\n\n        :param task_id: The ID of the task to delete.\n        :return: True if the task was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.delete_task(task_id))\n\n    async def get_completed_tasks_by_due_date(\n        self,\n        *,\n        since: datetime,\n        until: datetime,\n        workspace_id: str | None = None,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        filter_query: str | None = None,\n        filter_lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of completed tasks within a due date range.\n\n        Retrieves tasks completed within a specific due date range (up to 6 weeks).\n        Supports filtering by workspace, project, section, parent task, or a query.\n\n        The response is an iterable of lists of completed tasks. Be aware that each\n        iteration fires off a network request to the Todoist API, and may result in\n        rate limiting or other API restrictions.\n\n        :param since: Start of the date range (inclusive).\n        :param until: End of the date range (inclusive).\n        :param workspace_id: Filter by workspace ID.\n        :param project_id: Filter by project ID.\n        :param section_id: Filter by section ID.\n        :param parent_id: Filter by parent task ID.\n        :param filter_query: Filter by a query string.\n        :param filter_lang: Language for the filter query (e.g., 'en').\n        :param limit: Maximum number of tasks per page (default 50).\n        :return: An iterable of lists of completed tasks.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_completed_tasks_by_due_date(\n            since=since,\n            until=until,\n            workspace_id=workspace_id,\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            filter_query=filter_query,\n            filter_lang=filter_lang,\n            limit=limit,\n        )\n        return generate_async(paginator)\n\n    async def get_completed_tasks_by_completion_date(\n        self,\n        *,\n        since: datetime,\n        until: datetime,\n        workspace_id: str | None = None,\n        filter_query: str | None = None,\n        filter_lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of completed tasks within a date range.\n\n        Retrieves tasks completed within a specific date range (up to 3 months).\n        Supports filtering by workspace or a filter query.\n\n        The response is an iterable of lists of completed tasks. Be aware that each\n        iteration fires off a network request to the Todoist API, and may result in\n        rate limiting or other API restrictions.\n\n        :param since: Start of the date range (inclusive).\n        :param until: End of the date range (inclusive).\n        :param workspace_id: Filter by workspace ID.\n        :param filter_query: Filter by a query string.\n        :param filter_lang: Language for the filter query (e.g., 'en').\n        :param limit: Maximum number of tasks per page (default 50).\n        :return: An iterable of lists of completed tasks.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_completed_tasks_by_completion_date(\n            since=since,\n            until=until,\n            workspace_id=workspace_id,\n            filter_query=filter_query,\n            filter_lang=filter_lang,\n            limit=limit,\n        )\n        return generate_async(paginator)\n\n    async def get_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Get a project by its ID.\n\n        :param project_id: The ID of the project to retrieve.\n        :return: The requested project.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        return await run_async(lambda: self._api.get_project(project_id))\n\n    async def get_projects(\n        self,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Project]]:\n        \"\"\"\n        Get a list of active projects.\n\n        :param limit: Maximum number of projects per page.\n        :return: A list of projects.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_projects(limit=limit)\n        return generate_async(paginator)\n\n    async def add_project(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(120)],\n        *,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        parent_id: str | None = None,\n        color: ColorString | None = None,\n        is_favorite: bool | None = None,\n        view_style: ViewStyle | None = None,\n    ) -&gt; Project:\n        \"\"\"\n        Create a new project.\n\n        :param name: The name of the project.\n        :param description: Description for the project (up to 1024 characters).\n        :param parent_id: The ID of the parent project. Set to null for root projects.\n        :param color: The color of the project icon.\n        :param is_favorite: Whether the project is a favorite.\n        :param view_style: A string value (either 'list' or 'board', default is 'list').\n        :return: The newly created project.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.add_project(\n                name,\n                description=description,\n                parent_id=parent_id,\n                color=color,\n                is_favorite=is_favorite,\n                view_style=view_style,\n            )\n        )\n\n    async def update_project(\n        self,\n        project_id: str,\n        *,\n        name: Annotated[str, MinLen(1), MaxLen(120)] | None = None,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        color: ColorString | None = None,\n        is_favorite: bool | None = None,\n        view_style: ViewStyle | None = None,\n    ) -&gt; Project:\n        \"\"\"\n        Update an existing project.\n\n        Only the fields to be updated need to be provided as keyword arguments.\n\n        :param project_id: The ID of the project to update.\n        :param name: The name of the project.\n        :param description: Description for the project (up to 1024 characters).\n        :param color: The color of the project icon.\n        :param is_favorite: Whether the project is a favorite.\n        :param view_style: A string value (either 'list' or 'board').\n        :return: the updated Project.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.update_project(\n                project_id,\n                name=name,\n                description=description,\n                color=color,\n                is_favorite=is_favorite,\n                view_style=view_style,\n            )\n        )\n\n    async def archive_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Archive a project.\n\n        For personal projects, archives it only for the user.\n        For workspace projects, archives it for all members.\n\n        :param project_id: The ID of the project to archive.\n        :return: The archived project object.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        return await run_async(lambda: self._api.archive_project(project_id))\n\n    async def unarchive_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Unarchive a project.\n\n        Restores a previously archived project.\n\n        :param project_id: The ID of the project to unarchive.\n        :return: The unarchived project object.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        return await run_async(lambda: self._api.unarchive_project(project_id))\n\n    async def delete_project(self, project_id: str) -&gt; bool:\n        \"\"\"\n        Delete a project.\n\n        All nested sections and tasks will also be deleted.\n\n        :param project_id: The ID of the project to delete.\n        :return: True if the project was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.delete_project(project_id))\n\n    async def get_collaborators(\n        self,\n        project_id: str,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Collaborator]]:\n        \"\"\"\n        Get a list of collaborators in shared projects.\n\n        :param project_id: The ID of the project.\n        :param limit: Maximum number of collaborators per page.\n        :return: A list of collaborators.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_collaborators(project_id, limit=limit)\n        return generate_async(paginator)\n\n    async def get_section(self, section_id: str) -&gt; Section:\n        \"\"\"\n        Get a specific section by its ID.\n\n        :param section_id: The ID of the section to retrieve.\n        :return: The requested section.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Section dictionary.\n        \"\"\"\n        return await run_async(lambda: self._api.get_section(section_id))\n\n    async def get_sections(\n        self,\n        project_id: str | None = None,\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Section]]:\n        \"\"\"\n        Get a list of active sections.\n\n        Supports filtering by `project_id` and pagination arguments.\n\n        :param project_id: Filter sections by project ID.\n        :param limit: Maximum number of sections per page (between 1 and 200).\n        :return: A list of sections.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_sections(project_id=project_id, limit=limit)\n        return generate_async(paginator)\n\n    async def add_section(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(2048)],\n        project_id: str,\n        *,\n        order: int | None = None,\n    ) -&gt; Section:\n        \"\"\"\n        Create a new section within a project.\n\n        :param name: The name of the section.\n        :param project_id: The ID of the project to add the section to.\n        :param order: The order of the section among all sections in the project.\n        :return: The newly created section.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Section dictionary.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.add_section(name, project_id, order=order)\n        )\n\n    async def update_section(\n        self,\n        section_id: str,\n        name: Annotated[str, MinLen(1), MaxLen(2048)],\n    ) -&gt; Section:\n        \"\"\"\n        Update an existing section.\n\n        Currently, only `name` can be updated.\n\n        :param section_id: The ID of the section to update.\n        :param name: The new name for the section.\n        :return: the updated Section.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.update_section(section_id, name))\n\n    async def delete_section(self, section_id: str) -&gt; bool:\n        \"\"\"\n        Delete a section.\n\n        All tasks within the section will also be deleted.\n\n        :param section_id: The ID of the section to delete.\n        :return: True if the section was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.delete_section(section_id))\n\n    async def get_comment(self, comment_id: str) -&gt; Comment:\n        \"\"\"\n        Get a specific comment by its ID.\n\n        :param comment_id: The ID of the comment to retrieve.\n        :return: The requested comment.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Comment dictionary.\n        \"\"\"\n        return await run_async(lambda: self._api.get_comment(comment_id))\n\n    async def get_comments(\n        self,\n        *,\n        project_id: str | None = None,\n        task_id: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Comment]]:\n        \"\"\"\n        Get a list of comments for a task or project.\n\n        Requires either `project_id` or `task_id` to be set.\n\n        :param project_id: The ID of the project to retrieve comments for.\n        :param task_id: The ID of the task to retrieve comments for.\n        :param limit: Maximum number of comments per page (between 1 and 200).\n        :return: A list of comments.\n        :raises ValueError: If neither `project_id` nor `task_id` is provided.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_comments(\n            project_id=project_id, task_id=task_id, limit=limit\n        )\n        return generate_async(paginator)\n\n    async def add_comment(\n        self,\n        content: Annotated[str, MaxLen(15000)],\n        *,\n        project_id: str | None = None,\n        task_id: str | None = None,\n        attachment: Attachment | None = None,\n        uids_to_notify: list[str] | None = None,\n    ) -&gt; Comment:\n        \"\"\"\n        Create a new comment on a task or project.\n\n        Requires either `project_id` or `task_id` to be set,\n        and can optionally include an `attachment` object.\n\n        :param content: The text content of the comment (supports Markdown).\n        :param project_id: The ID of the project to add the comment to.\n        :param task_id: The ID of the task to add the comment to.\n        :param attachment: The attachment object to include with the comment.\n        :param uids_to_notify: A list of user IDs to notify.\n        :return: The newly created comment.\n        :raises ValueError: If neither `project_id` nor `task_id` is provided.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Comment dictionary.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.add_comment(\n                content,\n                project_id=project_id,\n                task_id=task_id,\n                attachment=attachment,\n                uids_to_notify=uids_to_notify,\n            )\n        )\n\n    async def update_comment(\n        self, comment_id: str, content: Annotated[str, MaxLen(15000)]\n    ) -&gt; Comment:\n        \"\"\"\n        Update an existing comment.\n\n        Currently, only `content` can be updated.\n\n        :param comment_id: The ID of the comment to update.\n        :param content: The new text content for the comment.\n        :return: the updated Comment.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.update_comment(comment_id, content))\n\n    async def delete_comment(self, comment_id: str) -&gt; bool:\n        \"\"\"\n        Delete a comment.\n\n        :param comment_id: The ID of the comment to delete.\n        :return: True if the comment was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.delete_comment(comment_id))\n\n    async def get_label(self, label_id: str) -&gt; Label:\n        \"\"\"\n        Get a specific personal label by its ID.\n\n        :param label_id: The ID of the label to retrieve.\n        :return: The requested label.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Label dictionary.\n        \"\"\"\n        return await run_async(lambda: self._api.get_label(label_id))\n\n    async def get_labels(\n        self,\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[Label]]:\n        \"\"\"\n        Get a list of personal labels.\n\n        Supports pagination arguments.\n\n        :param limit: Maximum number of labels per page (between 1 and 200).\n        :return: A list of personal labels.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_labels(limit=limit)\n        return generate_async(paginator)\n\n    async def add_label(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(60)],\n        *,\n        color: ColorString | None = None,\n        item_order: int | None = None,\n        is_favorite: bool | None = None,\n    ) -&gt; Label:\n        \"\"\"\n        Create a new personal label.\n\n        :param name: The name of the label.\n        :param color: The color of the label icon.\n        :param item_order: Label's order in the label list.\n        :param is_favorite: Whether the label is a favorite.\n        :return: The newly created label.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Label dictionary.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.add_label(\n                name, color=color, item_order=item_order, is_favorite=is_favorite\n            )\n        )\n\n    async def update_label(\n        self,\n        label_id: str,\n        *,\n        name: Annotated[str, MinLen(1), MaxLen(60)] | None = None,\n        color: ColorString | None = None,\n        item_order: int | None = None,\n        is_favorite: bool | None = None,\n    ) -&gt; Label:\n        \"\"\"\n        Update a personal label.\n\n        Only the fields to be updated need to be provided as keyword arguments.\n\n        :param label_id: The ID of the label.\n        :param name: The name of the label.\n        :param color: The color of the label icon.\n        :param item_order: Label's order in the label list.\n        :param is_favorite: Whether the label is a favorite.\n        :return: the updated Label.\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(\n            lambda: self._api.update_label(\n                label_id,\n                name=name,\n                color=color,\n                item_order=item_order,\n                is_favorite=is_favorite,\n            )\n        )\n\n    async def delete_label(self, label_id: str) -&gt; bool:\n        \"\"\"\n        Delete a personal label.\n\n        Instances of the label will be removed from tasks.\n\n        :param label_id: The ID of the label to delete.\n        :return: True if the label was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.delete_label(label_id))\n\n    async def get_shared_labels(\n        self,\n        *,\n        omit_personal: bool = False,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncGenerator[list[str]]:\n        \"\"\"\n        Get a list of shared label names.\n\n        Includes labels from collaborators on shared projects that are not in the\n        user's personal labels. Can optionally exclude personal label names using\n        `omit_personal=True`. Supports pagination arguments.\n\n        :param omit_personal: Optional boolean flag to omit personal label names.\n        :param limit: Maximum number of labels per page (between 1 and 200).\n        :return: A list of shared label names (strings).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        paginator = self._api.get_shared_labels(\n            omit_personal=omit_personal, limit=limit\n        )\n        return generate_async(paginator)\n\n    async def rename_shared_label(\n        self,\n        name: Annotated[str, MaxLen(60)],\n        new_name: Annotated[str, MinLen(1), MaxLen(60)],\n    ) -&gt; bool:\n        \"\"\"\n        Rename all occurrences of a shared label across all projects.\n\n        :param name: The current name of the shared label to rename.\n        :param new_name: The new name for the shared label.\n        :return: True if the rename was successful,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.rename_shared_label(name, new_name))\n\n    async def remove_shared_label(self, name: Annotated[str, MaxLen(60)]) -&gt; bool:\n        \"\"\"\n        Remove all occurrences of a shared label across all projects.\n\n        This action removes the label string from all tasks where it appears.\n\n        :param name: The name of the shared label to remove.\n        :return: True if the removal was successful,\n        :raises requests.exceptions.HTTPError: If the API request fails.\n        \"\"\"\n        return await run_async(lambda: self._api.remove_shared_label(name))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_comment","title":"<code>add_comment(content, *, project_id=None, task_id=None, attachment=None, uids_to_notify=None)</code>  <code>async</code>","text":"<p>Create a new comment on a task or project.</p> <p>Requires either <code>project_id</code> or <code>task_id</code> to be set, and can optionally include an <code>attachment</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text content of the comment (supports Markdown).</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to add the comment to.</p> <code>None</code> <code>task_id</code> <code>str | None</code> <p>The ID of the task to add the comment to.</p> <code>None</code> <code>attachment</code> <code>Attachment | None</code> <p>The attachment object to include with the comment.</p> <code>None</code> <code>uids_to_notify</code> <code>list[str] | None</code> <p>A list of user IDs to notify.</p> <code>None</code> <p>Returns:</p> Type Description <code>Comment</code> <p>The newly created comment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>project_id</code> nor <code>task_id</code> is provided.</p> <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Comment dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_comment(\n    self,\n    content: Annotated[str, MaxLen(15000)],\n    *,\n    project_id: str | None = None,\n    task_id: str | None = None,\n    attachment: Attachment | None = None,\n    uids_to_notify: list[str] | None = None,\n) -&gt; Comment:\n    \"\"\"\n    Create a new comment on a task or project.\n\n    Requires either `project_id` or `task_id` to be set,\n    and can optionally include an `attachment` object.\n\n    :param content: The text content of the comment (supports Markdown).\n    :param project_id: The ID of the project to add the comment to.\n    :param task_id: The ID of the task to add the comment to.\n    :param attachment: The attachment object to include with the comment.\n    :param uids_to_notify: A list of user IDs to notify.\n    :return: The newly created comment.\n    :raises ValueError: If neither `project_id` nor `task_id` is provided.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Comment dictionary.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.add_comment(\n            content,\n            project_id=project_id,\n            task_id=task_id,\n            attachment=attachment,\n            uids_to_notify=uids_to_notify,\n        )\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_label","title":"<code>add_label(name, *, color=None, item_order=None, is_favorite=None)</code>  <code>async</code>","text":"<p>Create a new personal label.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the label.</p> required <code>color</code> <code>ColorString | None</code> <p>The color of the label icon.</p> <code>None</code> <code>item_order</code> <code>int | None</code> <p>Label's order in the label list.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the label is a favorite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>The newly created label.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Label dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_label(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(60)],\n    *,\n    color: ColorString | None = None,\n    item_order: int | None = None,\n    is_favorite: bool | None = None,\n) -&gt; Label:\n    \"\"\"\n    Create a new personal label.\n\n    :param name: The name of the label.\n    :param color: The color of the label icon.\n    :param item_order: Label's order in the label list.\n    :param is_favorite: Whether the label is a favorite.\n    :return: The newly created label.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Label dictionary.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.add_label(\n            name, color=color, item_order=item_order, is_favorite=is_favorite\n        )\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_project","title":"<code>add_project(name, *, description=None, parent_id=None, color=None, is_favorite=None, view_style=None)</code>  <code>async</code>","text":"<p>Create a new project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the project.</p> required <code>description</code> <code>str | None</code> <p>Description for the project (up to 1024 characters).</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent project. Set to null for root projects.</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the project icon.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the project is a favorite.</p> <code>None</code> <code>view_style</code> <code>ViewStyle | None</code> <p>A string value (either 'list' or 'board', default is 'list').</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>The newly created project.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_project(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(120)],\n    *,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    parent_id: str | None = None,\n    color: ColorString | None = None,\n    is_favorite: bool | None = None,\n    view_style: ViewStyle | None = None,\n) -&gt; Project:\n    \"\"\"\n    Create a new project.\n\n    :param name: The name of the project.\n    :param description: Description for the project (up to 1024 characters).\n    :param parent_id: The ID of the parent project. Set to null for root projects.\n    :param color: The color of the project icon.\n    :param is_favorite: Whether the project is a favorite.\n    :param view_style: A string value (either 'list' or 'board', default is 'list').\n    :return: The newly created project.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.add_project(\n            name,\n            description=description,\n            parent_id=parent_id,\n            color=color,\n            is_favorite=is_favorite,\n            view_style=view_style,\n        )\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_section","title":"<code>add_section(name, project_id, *, order=None)</code>  <code>async</code>","text":"<p>Create a new section within a project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the section.</p> required <code>project_id</code> <code>str</code> <p>The ID of the project to add the section to.</p> required <code>order</code> <code>int | None</code> <p>The order of the section among all sections in the project.</p> <code>None</code> <p>Returns:</p> Type Description <code>Section</code> <p>The newly created section.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Section dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_section(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(2048)],\n    project_id: str,\n    *,\n    order: int | None = None,\n) -&gt; Section:\n    \"\"\"\n    Create a new section within a project.\n\n    :param name: The name of the section.\n    :param project_id: The ID of the project to add the section to.\n    :param order: The order of the section among all sections in the project.\n    :return: The newly created section.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Section dictionary.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.add_section(name, project_id, order=order)\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_task","title":"<code>add_task(content, *, description=None, project_id=None, section_id=None, parent_id=None, labels=None, priority=None, due_string=None, due_date=None, due_datetime=None, due_lang=None, assignee_id=None, order=None, auto_reminder=None, auto_parse_labels=None, duration=None, duration_unit=None, deadline_date=None, deadline_lang=None)</code>  <code>async</code>","text":"<p>Create a new task.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text content of the task.</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to add the task to.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>The ID of the section to add the task to.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent task.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>The task's labels (a list of names).</p> <code>None</code> <code>priority</code> <code>int | None</code> <p>The priority of the task (4 for very urgent).</p> <code>None</code> <code>due_string</code> <code>str | None</code> <p>The due date in natural language format.</p> <code>None</code> <code>due_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the due date (e.g., 'en').</p> <code>None</code> <code>due_date</code> <code>date | None</code> <p>The due date as a date object.</p> <code>None</code> <code>due_datetime</code> <code>datetime | None</code> <p>The due date and time as a datetime object.</p> <code>None</code> <code>assignee_id</code> <code>str | None</code> <p>User ID to whom the task is assigned.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the task.</p> <code>None</code> <code>order</code> <code>int | None</code> <p>The order of task in the project or section.</p> <code>None</code> <code>auto_reminder</code> <code>bool | None</code> <p>Whether to add default reminder if date with time is set.</p> <code>None</code> <code>auto_parse_labels</code> <code>bool | None</code> <p>Whether to parse labels from task content.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>The amount of time the task will take.</p> <code>None</code> <code>duration_unit</code> <code>Literal['minute', 'day'] | None</code> <p>The unit of time for duration.</p> <code>None</code> <code>deadline_date</code> <code>date | None</code> <p>The deadline date as a date object.</p> <code>None</code> <code>deadline_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the deadline date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Task</code> <p>The newly created task.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Task dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_task(\n    self,\n    content: Annotated[str, MinLen(1), MaxLen(500)],\n    *,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    labels: list[Annotated[str, MaxLen(100)]] | None = None,\n    priority: Annotated[int, Ge(1), Le(4)] | None = None,\n    due_string: Annotated[str, MaxLen(150)] | None = None,\n    due_date: date | None = None,\n    due_datetime: datetime | None = None,\n    due_lang: LanguageCode | None = None,\n    assignee_id: str | None = None,\n    order: int | None = None,\n    auto_reminder: bool | None = None,\n    auto_parse_labels: bool | None = None,\n    duration: Annotated[int, Ge(1)] | None = None,\n    duration_unit: Literal[\"minute\", \"day\"] | None = None,\n    deadline_date: date | None = None,\n    deadline_lang: LanguageCode | None = None,\n) -&gt; Task:\n    \"\"\"\n    Create a new task.\n\n    :param content: The text content of the task.\n    :param project_id: The ID of the project to add the task to.\n    :param section_id: The ID of the section to add the task to.\n    :param parent_id: The ID of the parent task.\n    :param labels: The task's labels (a list of names).\n    :param priority: The priority of the task (4 for very urgent).\n    :param due_string: The due date in natural language format.\n    :param due_lang: Language for parsing the due date (e.g., 'en').\n    :param due_date: The due date as a date object.\n    :param due_datetime: The due date and time as a datetime object.\n    :param assignee_id: User ID to whom the task is assigned.\n    :param description: Description for the task.\n    :param order: The order of task in the project or section.\n    :param auto_reminder: Whether to add default reminder if date with time is set.\n    :param auto_parse_labels: Whether to parse labels from task content.\n    :param duration: The amount of time the task will take.\n    :param duration_unit: The unit of time for duration.\n    :param deadline_date: The deadline date as a date object.\n    :param deadline_lang: Language for parsing the deadline date.\n    :return: The newly created task.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Task dictionary.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.add_task(\n            content,\n            description=description,\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            labels=labels,\n            priority=priority,\n            due_string=due_string,\n            due_lang=due_lang,\n            due_date=due_date,\n            due_datetime=due_datetime,\n            assignee_id=assignee_id,\n            order=order,\n            auto_reminder=auto_reminder,\n            auto_parse_labels=auto_parse_labels,\n            duration=duration,\n            duration_unit=duration_unit,\n            deadline_date=deadline_date,\n            deadline_lang=deadline_lang,\n        )\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_task_quick","title":"<code>add_task_quick(text, *, note=None, reminder=None, auto_reminder=True)</code>  <code>async</code>","text":"<p>Create a new task using Todoist's Quick Add syntax.</p> <p>This automatically parses dates, deadlines, projects, labels, priorities, etc, from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The task text using Quick Add syntax.</p> required <code>note</code> <code>str | None</code> <p>Optional note to be added to the task.</p> <code>None</code> <code>reminder</code> <code>str | None</code> <p>Optional reminder date in free form text.</p> <code>None</code> <code>auto_reminder</code> <code>bool</code> <p>Whether to add default reminder if date with time is set.</p> <code>True</code> <p>Returns:</p> Type Description <code>Task</code> <p>A result object containing the parsed task data and metadata.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response cannot be parsed into a QuickAddResult.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_task_quick(\n    self,\n    text: str,\n    *,\n    note: str | None = None,\n    reminder: str | None = None,\n    auto_reminder: bool = True,\n) -&gt; Task:\n    \"\"\"\n    Create a new task using Todoist's Quick Add syntax.\n\n    This automatically parses dates, deadlines, projects, labels, priorities, etc,\n    from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").\n\n    :param text: The task text using Quick Add syntax.\n    :param note: Optional note to be added to the task.\n    :param reminder: Optional reminder date in free form text.\n    :param auto_reminder: Whether to add default reminder if date with time is set.\n    :return: A result object containing the parsed task data and metadata.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response cannot be parsed into a QuickAddResult.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.add_task_quick(\n            text, note=note, reminder=reminder, auto_reminder=auto_reminder\n        )\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.archive_project","title":"<code>archive_project(project_id)</code>  <code>async</code>","text":"<p>Archive a project.</p> <p>For personal projects, archives it only for the user. For workspace projects, archives it for all members.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to archive.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The archived project object.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def archive_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Archive a project.\n\n    For personal projects, archives it only for the user.\n    For workspace projects, archives it for all members.\n\n    :param project_id: The ID of the project to archive.\n    :return: The archived project object.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    return await run_async(lambda: self._api.archive_project(project_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.complete_task","title":"<code>complete_task(task_id)</code>  <code>async</code>","text":"<p>Complete a task.</p> <p>For recurring tasks, this schedules the next occurrence. For non-recurring tasks, it marks them as completed.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to close.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was closed successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def complete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Complete a task.\n\n    For recurring tasks, this schedules the next occurrence.\n    For non-recurring tasks, it marks them as completed.\n\n    :param task_id: The ID of the task to close.\n    :return: True if the task was closed successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.complete_task(task_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_comment","title":"<code>delete_comment(comment_id)</code>  <code>async</code>","text":"<p>Delete a comment.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the comment was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_comment(self, comment_id: str) -&gt; bool:\n    \"\"\"\n    Delete a comment.\n\n    :param comment_id: The ID of the comment to delete.\n    :return: True if the comment was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.delete_comment(comment_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_label","title":"<code>delete_label(label_id)</code>  <code>async</code>","text":"<p>Delete a personal label.</p> <p>Instances of the label will be removed from tasks.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the label was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_label(self, label_id: str) -&gt; bool:\n    \"\"\"\n    Delete a personal label.\n\n    Instances of the label will be removed from tasks.\n\n    :param label_id: The ID of the label to delete.\n    :return: True if the label was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.delete_label(label_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_project","title":"<code>delete_project(project_id)</code>  <code>async</code>","text":"<p>Delete a project.</p> <p>All nested sections and tasks will also be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the project was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_project(self, project_id: str) -&gt; bool:\n    \"\"\"\n    Delete a project.\n\n    All nested sections and tasks will also be deleted.\n\n    :param project_id: The ID of the project to delete.\n    :return: True if the project was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.delete_project(project_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_section","title":"<code>delete_section(section_id)</code>  <code>async</code>","text":"<p>Delete a section.</p> <p>All tasks within the section will also be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the section was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_section(self, section_id: str) -&gt; bool:\n    \"\"\"\n    Delete a section.\n\n    All tasks within the section will also be deleted.\n\n    :param section_id: The ID of the section to delete.\n    :return: True if the section was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.delete_section(section_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_task","title":"<code>delete_task(task_id)</code>  <code>async</code>","text":"<p>Delete a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Delete a task.\n\n    :param task_id: The ID of the task to delete.\n    :return: True if the task was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.delete_task(task_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.filter_tasks","title":"<code>filter_tasks(*, query=None, lang=None, limit=None)</code>  <code>async</code>","text":"<p>Get a lists of active tasks matching the filter.</p> <p>The response is an iterable of lists of active tasks matching the criteria. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>Query tasks using Todoist's filter language.</p> <code>None</code> <code>lang</code> <code>str | None</code> <p>Language for task content (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (between 1 and 200).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Task]]</code> <p>An iterable of lists of tasks.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def filter_tasks(\n    self,\n    *,\n    query: Annotated[str, MaxLen(1024)] | None = None,\n    lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Task]]:\n    \"\"\"\n    Get a lists of active tasks matching the filter.\n\n    The response is an iterable of lists of active tasks matching the criteria.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query tasks using Todoist's filter language.\n    :param lang: Language for task content (e.g., 'en').\n    :param limit: Maximum number of tasks per page (between 1 and 200).\n    :return: An iterable of lists of tasks.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.filter_tasks(\n        query=query,\n        lang=lang,\n        limit=limit,\n    )\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_collaborators","title":"<code>get_collaborators(project_id, limit=None)</code>  <code>async</code>","text":"<p>Get a list of collaborators in shared projects.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project.</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of collaborators per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Collaborator]]</code> <p>A list of collaborators.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_collaborators(\n    self,\n    project_id: str,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Collaborator]]:\n    \"\"\"\n    Get a list of collaborators in shared projects.\n\n    :param project_id: The ID of the project.\n    :param limit: Maximum number of collaborators per page.\n    :return: A list of collaborators.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_collaborators(project_id, limit=limit)\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_comment","title":"<code>get_comment(comment_id)</code>  <code>async</code>","text":"<p>Get a specific comment by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to retrieve.</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>The requested comment.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Comment dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_comment(self, comment_id: str) -&gt; Comment:\n    \"\"\"\n    Get a specific comment by its ID.\n\n    :param comment_id: The ID of the comment to retrieve.\n    :return: The requested comment.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Comment dictionary.\n    \"\"\"\n    return await run_async(lambda: self._api.get_comment(comment_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_comments","title":"<code>get_comments(*, project_id=None, task_id=None, limit=None)</code>  <code>async</code>","text":"<p>Get a list of comments for a task or project.</p> <p>Requires either <code>project_id</code> or <code>task_id</code> to be set.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>The ID of the project to retrieve comments for.</p> <code>None</code> <code>task_id</code> <code>str | None</code> <p>The ID of the task to retrieve comments for.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of comments per page (between 1 and 200).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Comment]]</code> <p>A list of comments.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>project_id</code> nor <code>task_id</code> is provided.</p> <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_comments(\n    self,\n    *,\n    project_id: str | None = None,\n    task_id: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Comment]]:\n    \"\"\"\n    Get a list of comments for a task or project.\n\n    Requires either `project_id` or `task_id` to be set.\n\n    :param project_id: The ID of the project to retrieve comments for.\n    :param task_id: The ID of the task to retrieve comments for.\n    :param limit: Maximum number of comments per page (between 1 and 200).\n    :return: A list of comments.\n    :raises ValueError: If neither `project_id` nor `task_id` is provided.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_comments(\n        project_id=project_id, task_id=task_id, limit=limit\n    )\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_completed_tasks_by_completion_date","title":"<code>get_completed_tasks_by_completion_date(*, since, until, workspace_id=None, filter_query=None, filter_lang=None, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of completed tasks within a date range.</p> <p>Retrieves tasks completed within a specific date range (up to 3 months). Supports filtering by workspace or a filter query.</p> <p>The response is an iterable of lists of completed tasks. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>datetime</code> <p>Start of the date range (inclusive).</p> required <code>until</code> <code>datetime</code> <p>End of the date range (inclusive).</p> required <code>workspace_id</code> <code>str | None</code> <p>Filter by workspace ID.</p> <code>None</code> <code>filter_query</code> <code>str | None</code> <p>Filter by a query string.</p> <code>None</code> <code>filter_lang</code> <code>str | None</code> <p>Language for the filter query (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (default 50).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Task]]</code> <p>An iterable of lists of completed tasks.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_completed_tasks_by_completion_date(\n    self,\n    *,\n    since: datetime,\n    until: datetime,\n    workspace_id: str | None = None,\n    filter_query: str | None = None,\n    filter_lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of completed tasks within a date range.\n\n    Retrieves tasks completed within a specific date range (up to 3 months).\n    Supports filtering by workspace or a filter query.\n\n    The response is an iterable of lists of completed tasks. Be aware that each\n    iteration fires off a network request to the Todoist API, and may result in\n    rate limiting or other API restrictions.\n\n    :param since: Start of the date range (inclusive).\n    :param until: End of the date range (inclusive).\n    :param workspace_id: Filter by workspace ID.\n    :param filter_query: Filter by a query string.\n    :param filter_lang: Language for the filter query (e.g., 'en').\n    :param limit: Maximum number of tasks per page (default 50).\n    :return: An iterable of lists of completed tasks.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_completed_tasks_by_completion_date(\n        since=since,\n        until=until,\n        workspace_id=workspace_id,\n        filter_query=filter_query,\n        filter_lang=filter_lang,\n        limit=limit,\n    )\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_completed_tasks_by_due_date","title":"<code>get_completed_tasks_by_due_date(*, since, until, workspace_id=None, project_id=None, section_id=None, parent_id=None, filter_query=None, filter_lang=None, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of completed tasks within a due date range.</p> <p>Retrieves tasks completed within a specific due date range (up to 6 weeks). Supports filtering by workspace, project, section, parent task, or a query.</p> <p>The response is an iterable of lists of completed tasks. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>datetime</code> <p>Start of the date range (inclusive).</p> required <code>until</code> <code>datetime</code> <p>End of the date range (inclusive).</p> required <code>workspace_id</code> <code>str | None</code> <p>Filter by workspace ID.</p> <code>None</code> <code>project_id</code> <code>str | None</code> <p>Filter by project ID.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>Filter by section ID.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter by parent task ID.</p> <code>None</code> <code>filter_query</code> <code>str | None</code> <p>Filter by a query string.</p> <code>None</code> <code>filter_lang</code> <code>str | None</code> <p>Language for the filter query (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (default 50).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Task]]</code> <p>An iterable of lists of completed tasks.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_completed_tasks_by_due_date(\n    self,\n    *,\n    since: datetime,\n    until: datetime,\n    workspace_id: str | None = None,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    filter_query: str | None = None,\n    filter_lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of completed tasks within a due date range.\n\n    Retrieves tasks completed within a specific due date range (up to 6 weeks).\n    Supports filtering by workspace, project, section, parent task, or a query.\n\n    The response is an iterable of lists of completed tasks. Be aware that each\n    iteration fires off a network request to the Todoist API, and may result in\n    rate limiting or other API restrictions.\n\n    :param since: Start of the date range (inclusive).\n    :param until: End of the date range (inclusive).\n    :param workspace_id: Filter by workspace ID.\n    :param project_id: Filter by project ID.\n    :param section_id: Filter by section ID.\n    :param parent_id: Filter by parent task ID.\n    :param filter_query: Filter by a query string.\n    :param filter_lang: Language for the filter query (e.g., 'en').\n    :param limit: Maximum number of tasks per page (default 50).\n    :return: An iterable of lists of completed tasks.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_completed_tasks_by_due_date(\n        since=since,\n        until=until,\n        workspace_id=workspace_id,\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n        filter_query=filter_query,\n        filter_lang=filter_lang,\n        limit=limit,\n    )\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_label","title":"<code>get_label(label_id)</code>  <code>async</code>","text":"<p>Get a specific personal label by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label to retrieve.</p> required <p>Returns:</p> Type Description <code>Label</code> <p>The requested label.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Label dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_label(self, label_id: str) -&gt; Label:\n    \"\"\"\n    Get a specific personal label by its ID.\n\n    :param label_id: The ID of the label to retrieve.\n    :return: The requested label.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Label dictionary.\n    \"\"\"\n    return await run_async(lambda: self._api.get_label(label_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_labels","title":"<code>get_labels(*, limit=None)</code>  <code>async</code>","text":"<p>Get a list of personal labels.</p> <p>Supports pagination arguments.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page (between 1 and 200).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Label]]</code> <p>A list of personal labels.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_labels(\n    self,\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Label]]:\n    \"\"\"\n    Get a list of personal labels.\n\n    Supports pagination arguments.\n\n    :param limit: Maximum number of labels per page (between 1 and 200).\n    :return: A list of personal labels.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_labels(limit=limit)\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_project","title":"<code>get_project(project_id)</code>  <code>async</code>","text":"<p>Get a project by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to retrieve.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The requested project.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Get a project by its ID.\n\n    :param project_id: The ID of the project to retrieve.\n    :return: The requested project.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    return await run_async(lambda: self._api.get_project(project_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_projects","title":"<code>get_projects(limit=None)</code>  <code>async</code>","text":"<p>Get a list of active projects.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of projects per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Project]]</code> <p>A list of projects.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_projects(\n    self,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Project]]:\n    \"\"\"\n    Get a list of active projects.\n\n    :param limit: Maximum number of projects per page.\n    :return: A list of projects.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_projects(limit=limit)\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_section","title":"<code>get_section(section_id)</code>  <code>async</code>","text":"<p>Get a specific section by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to retrieve.</p> required <p>Returns:</p> Type Description <code>Section</code> <p>The requested section.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Section dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_section(self, section_id: str) -&gt; Section:\n    \"\"\"\n    Get a specific section by its ID.\n\n    :param section_id: The ID of the section to retrieve.\n    :return: The requested section.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Section dictionary.\n    \"\"\"\n    return await run_async(lambda: self._api.get_section(section_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_sections","title":"<code>get_sections(project_id=None, *, limit=None)</code>  <code>async</code>","text":"<p>Get a list of active sections.</p> <p>Supports filtering by <code>project_id</code> and pagination arguments.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>Filter sections by project ID.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of sections per page (between 1 and 200).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Section]]</code> <p>A list of sections.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_sections(\n    self,\n    project_id: str | None = None,\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Section]]:\n    \"\"\"\n    Get a list of active sections.\n\n    Supports filtering by `project_id` and pagination arguments.\n\n    :param project_id: Filter sections by project ID.\n    :param limit: Maximum number of sections per page (between 1 and 200).\n    :return: A list of sections.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_sections(project_id=project_id, limit=limit)\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_shared_labels","title":"<code>get_shared_labels(*, omit_personal=False, limit=None)</code>  <code>async</code>","text":"<p>Get a list of shared label names.</p> <p>Includes labels from collaborators on shared projects that are not in the user's personal labels. Can optionally exclude personal label names using <code>omit_personal=True</code>. Supports pagination arguments.</p> <p>Parameters:</p> Name Type Description Default <code>omit_personal</code> <code>bool</code> <p>Optional boolean flag to omit personal label names.</p> <code>False</code> <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page (between 1 and 200).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[str]]</code> <p>A list of shared label names (strings).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_shared_labels(\n    self,\n    *,\n    omit_personal: bool = False,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[str]]:\n    \"\"\"\n    Get a list of shared label names.\n\n    Includes labels from collaborators on shared projects that are not in the\n    user's personal labels. Can optionally exclude personal label names using\n    `omit_personal=True`. Supports pagination arguments.\n\n    :param omit_personal: Optional boolean flag to omit personal label names.\n    :param limit: Maximum number of labels per page (between 1 and 200).\n    :return: A list of shared label names (strings).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_shared_labels(\n        omit_personal=omit_personal, limit=limit\n    )\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_task","title":"<code>get_task(task_id)</code>  <code>async</code>","text":"<p>Get a specific task by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>Task</code> <p>The requested task.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Task dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_task(self, task_id: str) -&gt; Task:\n    \"\"\"\n    Get a specific task by its ID.\n\n    :param task_id: The ID of the task to retrieve.\n    :return: The requested task.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Task dictionary.\n    \"\"\"\n    return await run_async(lambda: self._api.get_task(task_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_tasks","title":"<code>get_tasks(*, project_id=None, section_id=None, parent_id=None, label=None, ids=None, limit=None)</code>  <code>async</code>","text":"<p>Get a list of active tasks.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>Filter tasks by project ID.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>Filter tasks by section ID.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter tasks by parent task ID.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Filter tasks by label name.</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>A list of the IDs of the tasks to retrieve.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (between 1 and 200).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncGenerator[list[Task]]</code> <p>A list of tasks.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_tasks(\n    self,\n    *,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    label: str | None = None,\n    ids: list[str] | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncGenerator[list[Task]]:\n    \"\"\"\n    Get a list of active tasks.\n\n    :param project_id: Filter tasks by project ID.\n    :param section_id: Filter tasks by section ID.\n    :param parent_id: Filter tasks by parent task ID.\n    :param label: Filter tasks by label name.\n    :param ids: A list of the IDs of the tasks to retrieve.\n    :param limit: Maximum number of tasks per page (between 1 and 200).\n    :return: A list of tasks.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    paginator = self._api.get_tasks(\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n        label=label,\n        ids=ids,\n        limit=limit,\n    )\n\n    return generate_async(paginator)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.move_task","title":"<code>move_task(task_id, project_id=None, section_id=None, parent_id=None)</code>  <code>async</code>","text":"<p>Move a task to a different project, section, or parent task.</p> <p><code>project_id</code> takes predence, followed by <code>section_id</code> (which also updates <code>project_id</code>), and then <code>parent_id</code> (which also updates <code>section_id</code> and <code>project_id</code>).</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to move.</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to move the task to.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>The ID of the section to move the task to.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent to move the task to.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was moved successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>ValueError</code> <p>If neither <code>project_id</code>, <code>section_id</code>, nor <code>parent_id</code> is provided.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def move_task(\n    self,\n    task_id: str,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n) -&gt; bool:\n    \"\"\"\n    Move a task to a different project, section, or parent task.\n\n    `project_id` takes predence, followed by\n    `section_id` (which also updates `project_id`),\n    and then `parent_id` (which also updates `section_id` and `project_id`).\n\n    :param task_id: The ID of the task to move.\n    :param project_id: The ID of the project to move the task to.\n    :param section_id: The ID of the section to move the task to.\n    :param parent_id: The ID of the parent to move the task to.\n    :return: True if the task was moved successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises ValueError: If neither `project_id`, `section_id`,\n            nor `parent_id` is provided.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.move_task(\n            task_id,\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n        )\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.remove_shared_label","title":"<code>remove_shared_label(name)</code>  <code>async</code>","text":"<p>Remove all occurrences of a shared label across all projects.</p> <p>This action removes the label string from all tasks where it appears.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the shared label to remove.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the removal was successful,</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def remove_shared_label(self, name: Annotated[str, MaxLen(60)]) -&gt; bool:\n    \"\"\"\n    Remove all occurrences of a shared label across all projects.\n\n    This action removes the label string from all tasks where it appears.\n\n    :param name: The name of the shared label to remove.\n    :return: True if the removal was successful,\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.remove_shared_label(name))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.rename_shared_label","title":"<code>rename_shared_label(name, new_name)</code>  <code>async</code>","text":"<p>Rename all occurrences of a shared label across all projects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The current name of the shared label to rename.</p> required <code>new_name</code> <code>str</code> <p>The new name for the shared label.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the rename was successful, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def rename_shared_label(\n    self,\n    name: Annotated[str, MaxLen(60)],\n    new_name: Annotated[str, MinLen(1), MaxLen(60)],\n) -&gt; bool:\n    \"\"\"\n    Rename all occurrences of a shared label across all projects.\n\n    :param name: The current name of the shared label to rename.\n    :param new_name: The new name for the shared label.\n    :return: True if the rename was successful,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.rename_shared_label(name, new_name))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.unarchive_project","title":"<code>unarchive_project(project_id)</code>  <code>async</code>","text":"<p>Unarchive a project.</p> <p>Restores a previously archived project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to unarchive.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The unarchived project object.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def unarchive_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Unarchive a project.\n\n    Restores a previously archived project.\n\n    :param project_id: The ID of the project to unarchive.\n    :return: The unarchived project object.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    return await run_async(lambda: self._api.unarchive_project(project_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.uncomplete_task","title":"<code>uncomplete_task(task_id)</code>  <code>async</code>","text":"<p>Uncomplete a (completed) task.</p> <p>Any parent tasks or sections will also be uncompleted.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to reopen.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was uncompleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def uncomplete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Uncomplete a (completed) task.\n\n    Any parent tasks or sections will also be uncompleted.\n\n    :param task_id: The ID of the task to reopen.\n    :return: True if the task was uncompleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.uncomplete_task(task_id))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_comment","title":"<code>update_comment(comment_id, content)</code>  <code>async</code>","text":"<p>Update an existing comment.</p> <p>Currently, only <code>content</code> can be updated.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to update.</p> required <code>content</code> <code>str</code> <p>The new text content for the comment.</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>the updated Comment.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_comment(\n    self, comment_id: str, content: Annotated[str, MaxLen(15000)]\n) -&gt; Comment:\n    \"\"\"\n    Update an existing comment.\n\n    Currently, only `content` can be updated.\n\n    :param comment_id: The ID of the comment to update.\n    :param content: The new text content for the comment.\n    :return: the updated Comment.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.update_comment(comment_id, content))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_label","title":"<code>update_label(label_id, *, name=None, color=None, item_order=None, is_favorite=None)</code>  <code>async</code>","text":"<p>Update a personal label.</p> <p>Only the fields to be updated need to be provided as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label.</p> required <code>name</code> <code>str | None</code> <p>The name of the label.</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the label icon.</p> <code>None</code> <code>item_order</code> <code>int | None</code> <p>Label's order in the label list.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the label is a favorite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>the updated Label.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_label(\n    self,\n    label_id: str,\n    *,\n    name: Annotated[str, MinLen(1), MaxLen(60)] | None = None,\n    color: ColorString | None = None,\n    item_order: int | None = None,\n    is_favorite: bool | None = None,\n) -&gt; Label:\n    \"\"\"\n    Update a personal label.\n\n    Only the fields to be updated need to be provided as keyword arguments.\n\n    :param label_id: The ID of the label.\n    :param name: The name of the label.\n    :param color: The color of the label icon.\n    :param item_order: Label's order in the label list.\n    :param is_favorite: Whether the label is a favorite.\n    :return: the updated Label.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.update_label(\n            label_id,\n            name=name,\n            color=color,\n            item_order=item_order,\n            is_favorite=is_favorite,\n        )\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_project","title":"<code>update_project(project_id, *, name=None, description=None, color=None, is_favorite=None, view_style=None)</code>  <code>async</code>","text":"<p>Update an existing project.</p> <p>Only the fields to be updated need to be provided as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to update.</p> required <code>name</code> <code>str | None</code> <p>The name of the project.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the project (up to 1024 characters).</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the project icon.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the project is a favorite.</p> <code>None</code> <code>view_style</code> <code>ViewStyle | None</code> <p>A string value (either 'list' or 'board').</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>the updated Project.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_project(\n    self,\n    project_id: str,\n    *,\n    name: Annotated[str, MinLen(1), MaxLen(120)] | None = None,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    color: ColorString | None = None,\n    is_favorite: bool | None = None,\n    view_style: ViewStyle | None = None,\n) -&gt; Project:\n    \"\"\"\n    Update an existing project.\n\n    Only the fields to be updated need to be provided as keyword arguments.\n\n    :param project_id: The ID of the project to update.\n    :param name: The name of the project.\n    :param description: Description for the project (up to 1024 characters).\n    :param color: The color of the project icon.\n    :param is_favorite: Whether the project is a favorite.\n    :param view_style: A string value (either 'list' or 'board').\n    :return: the updated Project.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.update_project(\n            project_id,\n            name=name,\n            description=description,\n            color=color,\n            is_favorite=is_favorite,\n            view_style=view_style,\n        )\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_section","title":"<code>update_section(section_id, name)</code>  <code>async</code>","text":"<p>Update an existing section.</p> <p>Currently, only <code>name</code> can be updated.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to update.</p> required <code>name</code> <code>str</code> <p>The new name for the section.</p> required <p>Returns:</p> Type Description <code>Section</code> <p>the updated Section.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_section(\n    self,\n    section_id: str,\n    name: Annotated[str, MinLen(1), MaxLen(2048)],\n) -&gt; Section:\n    \"\"\"\n    Update an existing section.\n\n    Currently, only `name` can be updated.\n\n    :param section_id: The ID of the section to update.\n    :param name: The new name for the section.\n    :return: the updated Section.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(lambda: self._api.update_section(section_id, name))\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_task","title":"<code>update_task(task_id, *, content=None, description=None, labels=None, priority=None, due_string=None, due_lang=None, due_date=None, due_datetime=None, assignee_id=None, day_order=None, collapsed=None, duration=None, duration_unit=None, deadline_date=None, deadline_lang=None)</code>  <code>async</code>","text":"<p>Update an existing task.</p> <p>Only the fields to be updated need to be provided.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>content</code> <code>str | None</code> <p>The text content of the task.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the task.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>The task's labels (a list of names).</p> <code>None</code> <code>priority</code> <code>int | None</code> <p>The priority of the task (4 for very urgent).</p> <code>None</code> <code>due_string</code> <code>str | None</code> <p>The due date in natural language format.</p> <code>None</code> <code>due_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the due date (e.g., 'en').</p> <code>None</code> <code>due_date</code> <code>date | None</code> <p>The due date as a date object.</p> <code>None</code> <code>due_datetime</code> <code>datetime | None</code> <p>The due date and time as a datetime object.</p> <code>None</code> <code>assignee_id</code> <code>str | None</code> <p>User ID to whom the task is assigned.</p> <code>None</code> <code>day_order</code> <code>int | None</code> <p>The order of the task inside Today or Next 7 days view.</p> <code>None</code> <code>collapsed</code> <code>bool | None</code> <p>Whether the task's sub-tasks are collapsed.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>The amount of time the task will take.</p> <code>None</code> <code>duration_unit</code> <code>Literal['minute', 'day'] | None</code> <p>The unit of time for duration.</p> <code>None</code> <code>deadline_date</code> <code>date | None</code> <p>The deadline date as a date object.</p> <code>None</code> <code>deadline_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the deadline date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Task</code> <p>the updated Task.</p> <p>Raises:</p> Type Description <code>requests.exceptions.HTTPError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_task(\n    self,\n    task_id: str,\n    *,\n    content: Annotated[str, MinLen(1), MaxLen(500)] | None = None,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    labels: list[Annotated[str, MaxLen(60)]] | None = None,\n    priority: Annotated[int, Ge(1), Le(4)] | None = None,\n    due_string: Annotated[str, MaxLen(150)] | None = None,\n    due_lang: LanguageCode | None = None,\n    due_date: date | None = None,\n    due_datetime: datetime | None = None,\n    assignee_id: str | None = None,\n    day_order: int | None = None,\n    collapsed: bool | None = None,\n    duration: Annotated[int, Ge(1)] | None = None,\n    duration_unit: Literal[\"minute\", \"day\"] | None = None,\n    deadline_date: date | None = None,\n    deadline_lang: LanguageCode | None = None,\n) -&gt; Task:\n    \"\"\"\n    Update an existing task.\n\n    Only the fields to be updated need to be provided.\n\n    :param task_id: The ID of the task to update.\n    :param content: The text content of the task.\n    :param description: Description for the task.\n    :param labels: The task's labels (a list of names).\n    :param priority: The priority of the task (4 for very urgent).\n    :param due_string: The due date in natural language format.\n    :param due_lang: Language for parsing the due date (e.g., 'en').\n    :param due_date: The due date as a date object.\n    :param due_datetime: The due date and time as a datetime object.\n    :param assignee_id: User ID to whom the task is assigned.\n    :param day_order: The order of the task inside Today or Next 7 days view.\n    :param collapsed: Whether the task's sub-tasks are collapsed.\n    :param duration: The amount of time the task will take.\n    :param duration_unit: The unit of time for duration.\n    :param deadline_date: The deadline date as a date object.\n    :param deadline_lang: Language for parsing the deadline date.\n    :return: the updated Task.\n    :raises requests.exceptions.HTTPError: If the API request fails.\n    \"\"\"\n    return await run_async(\n        lambda: self._api.update_task(\n            task_id,\n            content=content,\n            description=description,\n            labels=labels,\n            priority=priority,\n            due_string=due_string,\n            due_date=due_date,\n            due_datetime=due_datetime,\n            due_lang=due_lang,\n            assignee_id=assignee_id,\n            day_order=day_order,\n            collapsed=collapsed,\n            duration=duration,\n            duration_unit=duration_unit,\n            deadline_date=deadline_date,\n            deadline_lang=deadline_lang,\n        )\n    )\n</code></pre>"},{"location":"authentication/","title":"Authentication","text":"<p>This module provides functions to help authenticate with Todoist using the OAuth protocol.</p>"},{"location":"authentication/#quick-start","title":"Quick start","text":"<pre><code>import uuid\nfrom todoist_api_python.authentication import get_access_token, get_authentication_url\n\n# 1. Generate a random state\nstate = uuid.uuid4()\n\n# 2. Get authorization url\nurl = get_authentication_url(\n    client_id=\"YOUR_CLIENT_ID\",\n    scopes=[\"data:read\", \"task:add\"],\n    state=uuid.uuid4()\n)\n\n# 3.Redirect user to url\n# 4. Handle OAuth callback and get code\ncode = \"CODE_YOU_OBTAINED\"\n\n# 5. Exchange code for access token\nauth_result = get_access_token(\n    client_id=\"YOUR_CLIENT_ID\",\n    client_secret=\"YOUR_CLIENT_SECRET\",\n    code=code,\n)\n\n# 6. Ensure state is consistent, and done!\nassert(auth_result.state == state)\naccess_token = auth_result.access_token\n</code></pre> <p>For detailed implementation steps and security considerations, refer to the Todoist OAuth documentation.</p>"},{"location":"authentication/#todoist_api_python.authentication.get_auth_token","title":"<code>get_auth_token(client_id, client_secret, code, session=None)</code>","text":"<p>Get access token using provided client ID, client secret, and auth code.</p> Source code in <code>todoist_api_python/authentication.py</code> <pre><code>def get_auth_token(\n    client_id: str, client_secret: str, code: str, session: Session | None = None\n) -&gt; AuthResult:\n    \"\"\"Get access token using provided client ID, client secret, and auth code.\"\"\"\n    endpoint = get_oauth_url(ACCESS_TOKEN_PATH)\n    session = session or requests.Session()\n    data = {\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"code\": code,\n    }\n    response: dict[str, Any] = post(session=session, url=endpoint, data=data)\n    return AuthResult.from_dict(response)\n</code></pre>"},{"location":"authentication/#todoist_api_python.authentication.get_authentication_url","title":"<code>get_authentication_url(client_id, scopes, state)</code>","text":"<p>Get authorization URL to initiate OAuth flow.</p> Source code in <code>todoist_api_python/authentication.py</code> <pre><code>def get_authentication_url(client_id: str, scopes: list[Scope], state: str) -&gt; str:\n    \"\"\"Get authorization URL to initiate OAuth flow.\"\"\"\n    if len(scopes) == 0:\n        raise ValueError(\"At least one authorization scope should be requested.\")\n\n    endpoint = get_oauth_url(AUTHORIZE_PATH)\n    query = {\n        \"client_id\": client_id,\n        \"scope\": \",\".join(scopes),\n        \"state\": state,\n    }\n    return f\"{endpoint}?{urlencode(query)}\"\n</code></pre>"},{"location":"authentication/#todoist_api_python.authentication.revoke_auth_token","title":"<code>revoke_auth_token(client_id, client_secret, token, session=None)</code>","text":"<p>Revoke an access token.</p> Source code in <code>todoist_api_python/authentication.py</code> <pre><code>def revoke_auth_token(\n    client_id: str, client_secret: str, token: str, session: Session | None = None\n) -&gt; bool:\n    \"\"\"Revoke an access token.\"\"\"\n    # `get_api_url` is not a typo. Deleting access tokens is done using the regular API.\n    endpoint = get_api_url(ACCESS_TOKENS_PATH)\n    session = session or requests.Session()\n    params = {\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"access_token\": token,\n    }\n    return delete(session=session, url=endpoint, params=params)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#310-2025-05-07","title":"[3.1.0] - 2025-05-07","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Support for moving tasks, courtesy of @radiant-tangent</li> <li>Support for <code>backups:read</code> scope</li> <li>Re-add support for <code>X-Request-ID</code></li> <li>Configurable via <code>request_id_fn</code> API constructor argument</li> <li>Defaults to random UUID v4</li> <li>Automatic testing across all supported Python versions</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Compatibility with Python 3.9 and Python 3.10</li> </ul>"},{"location":"changelog/#301-2025-04-15","title":"[3.0.1] - 2025-04-15","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Wheel and source distributions didn't include the package itself</li> <li>Project requiring Python 3.13 to be installed</li> </ul>"},{"location":"changelog/#300-2025-04-11","title":"[3.0.0] - 2025-04-11","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for deadlines</li> <li>Support for archiving and unarchiving projects</li> <li>Support for fetching completed tasks by due date range and by completion date range</li> <li>Support for <code>note</code>, <code>reminder</code>, and <code>auto_reminder</code> in <code>add_task_quick</code></li> <li>Documentation for all SDK functions, arguments, and return objects</li> <li>Types, type hints for all SDK functions, arguments, and return objects</li> <li>Function to obtain project URLs</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Use <code>dataclass-wizard</code> for object mapping</li> <li>Modernized SDK to use the Todoist API v1</li> <li>Remove deprecated <code>Task.sync_id</code>, <code>Task.comment_count</code>, and <code>Project.comment_count</code></li> <li>Replace <code>Task.is_completed</code> with <code>Task.completed_at</code></li> <li>Add support for <code>calendar</code> in <code>Project.view_style</code></li> <li>Rename <code>quick_add_task</code> to <code>add_task_quick</code></li> <li>Add <code>filter_tasks</code>, extracting that workflow from <code>get_tasks</code></li> <li>Paginate results via an <code>Iterator</code> in <code>get_tasks</code>, <code>filter_task</code>, <code>get_projects</code>,   <code>get_collaborators</code>, <code>get_sections</code>, <code>get_comments</code>, <code>get_labels</code>, <code>get_shared_labels</code></li> <li>Receive <code>date</code> and <code>datetime</code> arguments as objects, not strings</li> <li>Remove support for <code>X-Request-Id</code> header, unused on the API level</li> <li>\"Hide\" internal modules and functions</li> <li>Task URLs are now obtained on demand, improving performance when not needed</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>API requests configure appropriate timeouts to avoid connections hanging</li> </ul>"},{"location":"changelog/#217-2024-08-13","title":"[2.1.7] - 2024-08-13","text":""},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>Regression with some <code>Project</code> object attributes</li> </ul>"},{"location":"changelog/#216-2024-08-07","title":"[2.1.6] - 2024-08-07","text":""},{"location":"changelog/#fixes_1","title":"Fixes","text":"<ul> <li><code>TodoistAPIAsync</code> accepts a <code>session</code> parameter</li> <li>State becomes optional in <code>AuthResult.from_dict()</code></li> <li>Duration handling in <code>to_dict()</code> and tests</li> <li>Default value to <code>section_id</code></li> <li>Properly close requests <code>Session</code> object</li> </ul>"},{"location":"changelog/#215-2024-05-22","title":"[2.1.5] - 2024-05-22","text":""},{"location":"changelog/#fixes_2","title":"Fixes","text":"<ul> <li>Key error on <code>can_assign_tasks</code> in <code>Project</code> model</li> </ul>"},{"location":"changelog/#214-2024-05-07","title":"[2.1.4] - 2024-05-07","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support <code>project.can_assign_tasks</code></li> <li>Add <code>duration</code> to <code>Task</code> object</li> <li>Pagination example</li> </ul>"},{"location":"changelog/#213-2023-08-15","title":"[2.1.3] - 2023-08-15","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Support for getting completed items through the items archive</li> </ul>"},{"location":"changelog/#212-2023-08-14","title":"[2.1.2] - 2023-08-14","text":""},{"location":"changelog/#fixes_3","title":"Fixes","text":"<ul> <li>Restore Python 3.9 compatibility</li> </ul>"},{"location":"changelog/#211-2023-08-09","title":"[2.1.1] - 2023-08-09","text":""},{"location":"changelog/#fixes_4","title":"Fixes","text":"<ul> <li>Building environment updates</li> </ul>"},{"location":"changelog/#210-2023-08-02","title":"[2.1.0] - 2023-08-02","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Use built-in data classes instead of <code>attrs</code></li> </ul>"},{"location":"changelog/#202-2022-11-02","title":"[2.0.2] - 2022-11-02","text":""},{"location":"changelog/#fixes_5","title":"Fixes","text":"<ul> <li>Task property <code>date_added</code> should be <code>added_at</code></li> </ul>"},{"location":"changelog/#201-2022-10-06","title":"[2.0.1] - 2022-10-06","text":""},{"location":"changelog/#fixes_6","title":"Fixes","text":"<ul> <li>Fixed a crash in <code>get_comments</code> if attachment is null.</li> </ul>"},{"location":"changelog/#200-2022-09-08","title":"[2.0.0] - 2022-09-08","text":"<p>Migrate to REST API v2.</p>"},{"location":"changelog/#111-2022-02-15","title":"[1.1.1] - 2022-02-15","text":""},{"location":"changelog/#fixes_7","title":"Fixes","text":"<ul> <li>Add missing <code>attrs</code> package dependency</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Dependabot updates</li> </ul>"},{"location":"changelog/#110-2021-11-23","title":"[1.1.0] - 2021-11-23","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Public release</li> </ul>"},{"location":"models/","title":"Models","text":""},{"location":"models/#todoist_api_python.models.ApiDate","title":"<code>ApiDate = UTCDateTimePattern['%FT%T.%fZ']</code>","text":""},{"location":"models/#todoist_api_python.models.ApiDue","title":"<code>ApiDue = Union[DatePattern['%F'], DateTimePattern['%FT%T'], UTCDateTimePattern['%FT%TZ']]</code>","text":""},{"location":"models/#todoist_api_python.models.DurationUnit","title":"<code>DurationUnit = Literal['minute', 'day']</code>","text":""},{"location":"models/#todoist_api_python.models.ViewStyle","title":"<code>ViewStyle = Literal['list', 'board', 'calendar']</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Attachment(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    resource_type: str | None = None\n\n    file_name: str | None = None\n    file_size: int | None = None\n    file_type: str | None = None\n    file_url: str | None = None\n    file_duration: int | None = None\n    upload_state: str | None = None\n\n    image: str | None = None\n    image_width: int | None = None\n    image_height: int | None = None\n\n    url: str | None = None\n    title: str | None = None\n</code></pre>"},{"location":"models/#todoist_api_python.models.Attachment.file_duration","title":"<code>file_duration = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.file_name","title":"<code>file_name = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.file_size","title":"<code>file_size = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.file_type","title":"<code>file_type = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.file_url","title":"<code>file_url = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.image","title":"<code>image = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.image_height","title":"<code>image_height = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.image_width","title":"<code>image_width = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.resource_type","title":"<code>resource_type = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.title","title":"<code>title = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.upload_state","title":"<code>upload_state = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.url","title":"<code>url = None</code>","text":""},{"location":"models/#todoist_api_python.models.AuthResult","title":"<code>AuthResult</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass AuthResult(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    access_token: str\n    state: str | None\n</code></pre>"},{"location":"models/#todoist_api_python.models.AuthResult.access_token","title":"<code>access_token</code>","text":""},{"location":"models/#todoist_api_python.models.AuthResult.state","title":"<code>state</code>","text":""},{"location":"models/#todoist_api_python.models.Collaborator","title":"<code>Collaborator</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Collaborator(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    email: str\n    name: str\n</code></pre>"},{"location":"models/#todoist_api_python.models.Collaborator.email","title":"<code>email</code>","text":""},{"location":"models/#todoist_api_python.models.Collaborator.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Collaborator.name","title":"<code>name</code>","text":""},{"location":"models/#todoist_api_python.models.Comment","title":"<code>Comment</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Comment(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    content: str\n    poster_id: Annotated[str, Alias(load=(\"posted_uid\", \"poster_id\"))]\n    posted_at: ApiDate\n    task_id: Annotated[str | None, Alias(load=(\"item_id\", \"task_id\"))] = None\n    project_id: str | None = None\n    attachment: Annotated[\n        Attachment | None, Alias(load=(\"file_attachment\", \"attachment\"))\n    ] = None\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        Finish initialization of the Comment object.\n\n        :raises ValueError: If neither `task_id` nor `project_id` is specified.\n        \"\"\"\n        if self.task_id is None and self.project_id is None:\n            raise ValueError(\"Must specify `task_id` or `project_id`\")\n</code></pre>"},{"location":"models/#todoist_api_python.models.Comment.attachment","title":"<code>attachment = None</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.content","title":"<code>content</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.posted_at","title":"<code>posted_at</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.poster_id","title":"<code>poster_id</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.project_id","title":"<code>project_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.task_id","title":"<code>task_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Deadline","title":"<code>Deadline</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Deadline(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    date: ApiDue\n    lang: str = \"en\"\n</code></pre>"},{"location":"models/#todoist_api_python.models.Deadline.date","title":"<code>date</code>","text":""},{"location":"models/#todoist_api_python.models.Deadline.lang","title":"<code>lang = 'en'</code>","text":""},{"location":"models/#todoist_api_python.models.Due","title":"<code>Due</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Due(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    date: ApiDue\n    string: str\n    lang: str = \"en\"\n    is_recurring: bool = False\n    timezone: str | None = None\n</code></pre>"},{"location":"models/#todoist_api_python.models.Due.date","title":"<code>date</code>","text":""},{"location":"models/#todoist_api_python.models.Due.is_recurring","title":"<code>is_recurring = False</code>","text":""},{"location":"models/#todoist_api_python.models.Due.lang","title":"<code>lang = 'en'</code>","text":""},{"location":"models/#todoist_api_python.models.Due.string","title":"<code>string</code>","text":""},{"location":"models/#todoist_api_python.models.Due.timezone","title":"<code>timezone = None</code>","text":""},{"location":"models/#todoist_api_python.models.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Duration(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    amount: int\n    unit: DurationUnit\n</code></pre>"},{"location":"models/#todoist_api_python.models.Duration.amount","title":"<code>amount</code>","text":""},{"location":"models/#todoist_api_python.models.Duration.unit","title":"<code>unit</code>","text":""},{"location":"models/#todoist_api_python.models.Label","title":"<code>Label</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Label(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    name: str\n    color: str\n    order: int\n    is_favorite: bool\n</code></pre>"},{"location":"models/#todoist_api_python.models.Label.color","title":"<code>color</code>","text":""},{"location":"models/#todoist_api_python.models.Label.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Label.is_favorite","title":"<code>is_favorite</code>","text":""},{"location":"models/#todoist_api_python.models.Label.name","title":"<code>name</code>","text":""},{"location":"models/#todoist_api_python.models.Label.order","title":"<code>order</code>","text":""},{"location":"models/#todoist_api_python.models.Meta","title":"<code>Meta</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Meta(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    project: tuple[str, str]\n    section: tuple[str, str]\n    assignee: tuple[str, str]\n    labels: dict[int, str]\n    due: Due | None\n    deadline: Deadline | None\n</code></pre>"},{"location":"models/#todoist_api_python.models.Meta.assignee","title":"<code>assignee</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.deadline","title":"<code>deadline</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.due","title":"<code>due</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.labels","title":"<code>labels</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.project","title":"<code>project</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.section","title":"<code>section</code>","text":""},{"location":"models/#todoist_api_python.models.Project","title":"<code>Project</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Project(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    name: str\n    description: str\n    order: Annotated[int, Alias(load=(\"child_order\", \"order\"))]\n    color: str\n    is_collapsed: Annotated[bool, Alias(load=(\"collapsed\", \"is_collapsed\"))]\n    is_shared: Annotated[bool, Alias(load=(\"shared\", \"is_shared\"))]\n    is_favorite: bool\n    is_archived: bool\n    can_assign_tasks: bool\n    view_style: ViewStyle\n    created_at: ApiDate\n    updated_at: ApiDate\n\n    parent_id: str | None = None\n    is_inbox_project: Annotated[\n        bool | None, Alias(load=(\"inbox_project\", \"is_inbox_project\"))\n    ] = None\n\n    workspace_id: str | None = None\n    folder_id: str | None = None\n\n    @property\n    def url(self) -&gt; str:\n        if self.is_inbox_project:\n            return INBOX_URL\n        return get_project_url(self.id, self.name)\n</code></pre>"},{"location":"models/#todoist_api_python.models.Project.can_assign_tasks","title":"<code>can_assign_tasks</code>","text":""},{"location":"models/#todoist_api_python.models.Project.color","title":"<code>color</code>","text":""},{"location":"models/#todoist_api_python.models.Project.created_at","title":"<code>created_at</code>","text":""},{"location":"models/#todoist_api_python.models.Project.description","title":"<code>description</code>","text":""},{"location":"models/#todoist_api_python.models.Project.folder_id","title":"<code>folder_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Project.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_archived","title":"<code>is_archived</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_collapsed","title":"<code>is_collapsed</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_favorite","title":"<code>is_favorite</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_inbox_project","title":"<code>is_inbox_project = None</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_shared","title":"<code>is_shared</code>","text":""},{"location":"models/#todoist_api_python.models.Project.name","title":"<code>name</code>","text":""},{"location":"models/#todoist_api_python.models.Project.order","title":"<code>order</code>","text":""},{"location":"models/#todoist_api_python.models.Project.parent_id","title":"<code>parent_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Project.updated_at","title":"<code>updated_at</code>","text":""},{"location":"models/#todoist_api_python.models.Project.url","title":"<code>url</code>","text":""},{"location":"models/#todoist_api_python.models.Project.view_style","title":"<code>view_style</code>","text":""},{"location":"models/#todoist_api_python.models.Project.workspace_id","title":"<code>workspace_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Section","title":"<code>Section</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Section(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    name: str\n    project_id: str\n    is_collapsed: Annotated[bool, Alias(load=(\"collapsed\", \"is_collapsed\"))]\n    order: Annotated[int, Alias(load=(\"section_order\", \"order\"))]\n</code></pre>"},{"location":"models/#todoist_api_python.models.Section.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Section.is_collapsed","title":"<code>is_collapsed</code>","text":""},{"location":"models/#todoist_api_python.models.Section.name","title":"<code>name</code>","text":""},{"location":"models/#todoist_api_python.models.Section.order","title":"<code>order</code>","text":""},{"location":"models/#todoist_api_python.models.Section.project_id","title":"<code>project_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task","title":"<code>Task</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Task(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    content: str\n    description: str\n    project_id: str\n    section_id: str | None\n    parent_id: str | None\n    labels: list[str] | None\n    priority: int\n    due: Due | None\n    deadline: Deadline | None\n    duration: Duration | None\n    is_collapsed: Annotated[bool, Alias(load=(\"collapsed\", \"is_collapsed\"))]\n    order: Annotated[int, Alias(load=(\"child_order\", \"order\"))]\n    assignee_id: Annotated[str | None, Alias(load=(\"responsible_uid\", \"assignee_id\"))]\n    assigner_id: Annotated[str | None, Alias(load=(\"assigned_by_uid\", \"assigner_id\"))]\n    completed_at: Optional[ApiDate]  # noqa: UP007 # https://github.com/rnag/dataclass-wizard/issues/189\n    creator_id: Annotated[str, Alias(load=(\"added_by_uid\", \"creator_id\"))]\n    created_at: Annotated[ApiDate, Alias(load=(\"added_at\", \"created_at\"))]\n    updated_at: ApiDate\n\n    meta: Meta | None = None\n\n    @property\n    def url(self) -&gt; str:\n        return get_task_url(self.id, self.content)\n\n    @property\n    def is_completed(self) -&gt; bool:\n        return self.completed_at is not None\n</code></pre>"},{"location":"models/#todoist_api_python.models.Task.assignee_id","title":"<code>assignee_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.assigner_id","title":"<code>assigner_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.completed_at","title":"<code>completed_at</code>","text":""},{"location":"models/#todoist_api_python.models.Task.content","title":"<code>content</code>","text":""},{"location":"models/#todoist_api_python.models.Task.created_at","title":"<code>created_at</code>","text":""},{"location":"models/#todoist_api_python.models.Task.creator_id","title":"<code>creator_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.deadline","title":"<code>deadline</code>","text":""},{"location":"models/#todoist_api_python.models.Task.description","title":"<code>description</code>","text":""},{"location":"models/#todoist_api_python.models.Task.due","title":"<code>due</code>","text":""},{"location":"models/#todoist_api_python.models.Task.duration","title":"<code>duration</code>","text":""},{"location":"models/#todoist_api_python.models.Task.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.is_collapsed","title":"<code>is_collapsed</code>","text":""},{"location":"models/#todoist_api_python.models.Task.is_completed","title":"<code>is_completed</code>","text":""},{"location":"models/#todoist_api_python.models.Task.labels","title":"<code>labels</code>","text":""},{"location":"models/#todoist_api_python.models.Task.meta","title":"<code>meta = None</code>","text":""},{"location":"models/#todoist_api_python.models.Task.order","title":"<code>order</code>","text":""},{"location":"models/#todoist_api_python.models.Task.parent_id","title":"<code>parent_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.priority","title":"<code>priority</code>","text":""},{"location":"models/#todoist_api_python.models.Task.project_id","title":"<code>project_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.section_id","title":"<code>section_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.updated_at","title":"<code>updated_at</code>","text":""},{"location":"models/#todoist_api_python.models.Task.url","title":"<code>url</code>","text":""}]}