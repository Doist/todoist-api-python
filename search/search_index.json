{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This is the official Python SDK for the Todoist API.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install todoist-api-python\n</code></pre> <p>Or add the project as a dependency in <code>pyproject.toml</code>:</p> <pre><code>dependencies = [\n  \"todoist-api-python&gt;=3.1.0,&lt;4\",\n]\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Here's an example of initializing the API client, fetching a task, and paginating through its comments:</p> <pre><code>from todoist_api_python.api import TodoistAPI\n\napi = TodoistAPI(\"YOUR_API_TOKEN\")\n\ntask = api.get_task(\"6X4Vw2Hfmg73Q2XR\")\nprint(f\"Task: {task.content}\")\n\ncomments_iter = api.get_comments(task_id=task.id)\nfor comments in comments_iter:\n    for comment in comments:\n        print(f\"Comment: {comment.content}\")\n</code></pre>"},{"location":"#async-usage","title":"Async usage","text":"<p>Use <code>TodoistAPIAsync</code> with <code>async with</code> (or call <code>await api.close()</code> manually) to ensure the underlying <code>httpx.AsyncClient</code> is closed.</p>"},{"location":"#quick-start","title":"Quick start","text":"<ul> <li>Authentication</li> <li>API client</li> <li>Models</li> </ul>"},{"location":"#api-reference","title":"API reference","text":"<p>For detailed reference documentation, have a look at the API documentation.</p>"},{"location":"api/","title":"API Client","text":"<p>Client for the Todoist API.</p> <p>Provides methods for interacting with Todoist resources like tasks, projects, labels, comments, etc.</p> <p>Manages an HTTP client and handles authentication. Can be used as a context manager to ensure the client is closed properly.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>class TodoistAPI:\n    \"\"\"\n    Client for the Todoist API.\n\n    Provides methods for interacting with Todoist resources like tasks, projects,\n    labels, comments, etc.\n\n    Manages an HTTP client and handles authentication. Can be used as a context manager\n    to ensure the client is closed properly.\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        request_id_fn: Callable[[], str] | None = default_request_id_fn,\n        client: httpx.Client | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the TodoistAPI client.\n\n        :param token: Authentication token for the Todoist API.\n        :param request_id_fn: Generator of request IDs for the `X-Request-ID` header.\n        :param client: An optional pre-configured `httpx.Client` object.\n        \"\"\"\n        self._token = token\n        self._request_id_fn = request_id_fn\n        self._client = client or httpx.Client()\n        self._finalizer = finalize(self, self._client.close)\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"\n        Enters the runtime context related to this object.\n\n        The with statement will bind this method's return value to the target(s)\n        specified in the as clause of the statement, if any.\n\n        :return: This TodoistAPI instance.\n        \"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit the runtime context and close the underlying httpx client.\"\"\"\n        self._finalizer()\n\n    def get_task(self, task_id: str) -&gt; Task:\n        \"\"\"\n        Get a specific task by its ID.\n\n        :param task_id: The ID of the task to retrieve.\n        :return: The requested task.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Task dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n        response = get(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Task.from_dict(data)\n\n    def get_tasks(\n        self,\n        *,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        label: str | None = None,\n        ids: list[str] | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of active tasks.\n\n        The response is an iterable of lists of active tasks matching the criteria.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: Filter tasks by project ID.\n        :param section_id: Filter tasks by section ID.\n        :param parent_id: Filter tasks by parent task ID.\n        :param label: Filter tasks by label name.\n        :param ids: A list of the IDs of the tasks to retrieve.\n        :param limit: Maximum number of tasks per page.\n        :return: An iterable of lists of tasks.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_PATH)\n\n        params = kwargs_without_none(\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            label=label,\n            ids=\",\".join(str(i) for i in ids) if ids is not None else None,\n            limit=limit,\n        )\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def filter_tasks(\n        self,\n        *,\n        query: Annotated[str, MaxLen(1024)] | None = None,\n        lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of active tasks matching the filter.\n\n        The response is an iterable of lists of active tasks matching the criteria.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query tasks using Todoist's filter language.\n        :param lang: Language for task content (e.g., 'en').\n        :param limit: Maximum number of tasks per page.\n        :return: An iterable of lists of tasks.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_FILTER_PATH)\n\n        params = kwargs_without_none(query=query, lang=lang, limit=limit)\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_task(\n        self,\n        content: Annotated[str, MinLen(1), MaxLen(500)],\n        *,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        labels: list[Annotated[str, MaxLen(100)]] | None = None,\n        priority: Annotated[int, Ge(1), Le(4)] | None = None,\n        due_string: Annotated[str, MaxLen(150)] | None = None,\n        due_lang: LanguageCode | None = None,\n        due_date: date | None = None,\n        due_datetime: datetime | None = None,\n        assignee_id: str | None = None,\n        order: int | None = None,\n        auto_reminder: bool | None = None,\n        auto_parse_labels: bool | None = None,\n        duration: Annotated[int, Ge(1)] | None = None,\n        duration_unit: Literal[\"minute\", \"day\"] | None = None,\n        deadline_date: date | None = None,\n        deadline_lang: LanguageCode | None = None,\n    ) -&gt; Task:\n        \"\"\"\n        Create a new task.\n\n        :param content: The text content of the task.\n        :param project_id: The ID of the project to add the task to.\n        :param section_id: The ID of the section to add the task to.\n        :param parent_id: The ID of the parent task.\n        :param labels: The task's labels (a list of names).\n        :param priority: The priority of the task (4 for very urgent).\n        :param due_string: The due date in natural language format.\n        :param due_lang: Language for parsing the due date (e.g., 'en').\n        :param due_date: The due date as a date object.\n        :param due_datetime: The due date and time as a datetime object.\n        :param assignee_id: User ID to whom the task is assigned.\n        :param description: Description for the task.\n        :param order: The order of task in the project or section.\n        :param auto_reminder: Whether to add default reminder if date with time is set.\n        :param auto_parse_labels: Whether to parse labels from task content.\n        :param duration: The amount of time the task will take.\n        :param duration_unit: The unit of time for duration.\n        :param deadline_date: The deadline date as a date object.\n        :param deadline_lang: Language for parsing the deadline date.\n        :return: The newly created task.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Task dictionary.\n        \"\"\"\n        endpoint = get_api_url(TASKS_PATH)\n\n        data = kwargs_without_none(\n            content=content,\n            description=description,\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            labels=labels,\n            priority=priority,\n            due_string=due_string,\n            due_lang=due_lang,\n            due_date=format_date(due_date) if due_date is not None else None,\n            due_datetime=(\n                format_datetime(due_datetime) if due_datetime is not None else None\n            ),\n            assignee_id=assignee_id,\n            order=order,\n            auto_reminder=auto_reminder,\n            auto_parse_labels=auto_parse_labels,\n            duration=duration,\n            duration_unit=duration_unit,\n            deadline_date=(\n                format_date(deadline_date) if deadline_date is not None else None\n            ),\n            deadline_lang=deadline_lang,\n        )\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Task.from_dict(data)\n\n    def add_task_quick(\n        self,\n        text: str,\n        *,\n        note: str | None = None,\n        reminder: str | None = None,\n        auto_reminder: bool = True,\n    ) -&gt; Task:\n        \"\"\"\n        Create a new task using Todoist's Quick Add syntax.\n\n        This automatically parses dates, deadlines, projects, labels, priorities, etc,\n        from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").\n\n        :param text: The task text using Quick Add syntax.\n        :param note: Optional note to be added to the task.\n        :param reminder: Optional reminder date in free form text.\n        :param auto_reminder: Whether to add default reminder if date with time is set.\n        :return: A result object containing the parsed task data and metadata.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response cannot be parsed into a QuickAddResult.\n        \"\"\"\n        endpoint = get_api_url(TASKS_QUICK_ADD_PATH)\n\n        data = kwargs_without_none(\n            meta=True,\n            text=text,\n            auto_reminder=auto_reminder,\n            note=note,\n            reminder=reminder,\n        )\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Task.from_dict(data)\n\n    def update_task(\n        self,\n        task_id: str,\n        *,\n        content: Annotated[str, MinLen(1), MaxLen(500)] | None = None,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        labels: list[Annotated[str, MaxLen(60)]] | None = None,\n        priority: Annotated[int, Ge(1), Le(4)] | None = None,\n        due_string: Annotated[str, MaxLen(150)] | None = None,\n        due_lang: LanguageCode | None = None,\n        due_date: date | None = None,\n        due_datetime: datetime | None = None,\n        assignee_id: str | None = None,\n        order: int | None = None,\n        day_order: int | None = None,\n        collapsed: bool | None = None,\n        duration: Annotated[int, Ge(1)] | None = None,\n        duration_unit: Literal[\"minute\", \"day\"] | None = None,\n        deadline_date: date | None = None,\n        deadline_lang: LanguageCode | None = None,\n    ) -&gt; Task:\n        \"\"\"\n        Update an existing task.\n\n        Only the fields to be updated need to be provided.\n\n        :param task_id: The ID of the task to update.\n        :param content: The text content of the task.\n        :param description: Description for the task.\n        :param labels: The task's labels (a list of names).\n        :param priority: The priority of the task (4 for very urgent).\n        :param due_string: The due date in natural language format.\n        :param due_lang: Language for parsing the due date (e.g., 'en').\n        :param due_date: The due date as a date object.\n        :param due_datetime: The due date and time as a datetime object.\n        :param assignee_id: User ID to whom the task is assigned.\n        :param order: The order of task in the project or section.\n        :param day_order: The order of the task inside Today or Next 7 days view.\n        :param collapsed: Whether the task's sub-tasks are collapsed.\n        :param duration: The amount of time the task will take.\n        :param duration_unit: The unit of time for duration.\n        :param deadline_date: The deadline date as a date object.\n        :param deadline_lang: Language for parsing the deadline date.\n        :return: the updated Task.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n\n        data = kwargs_without_none(\n            content=content,\n            description=description,\n            labels=labels,\n            priority=priority,\n            due_string=due_string,\n            due_lang=due_lang,\n            due_date=format_date(due_date) if due_date is not None else None,\n            due_datetime=(\n                format_datetime(due_datetime) if due_datetime is not None else None\n            ),\n            assignee_id=assignee_id,\n            order=order,\n            day_order=day_order,\n            collapsed=collapsed,\n            duration=duration,\n            duration_unit=duration_unit,\n            deadline_date=(\n                format_date(deadline_date) if deadline_date is not None else None\n            ),\n            deadline_lang=deadline_lang,\n        )\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Task.from_dict(data)\n\n    def complete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Complete a task.\n\n        For recurring tasks, this schedules the next occurrence.\n        For non-recurring tasks, it marks them as completed.\n\n        :param task_id: The ID of the task to close.\n        :return: True if the task was closed successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/close\")\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    def uncomplete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Uncomplete a (completed) task.\n\n        Any parent tasks or sections will also be uncompleted.\n\n        :param task_id: The ID of the task to reopen.\n        :return: True if the task was uncompleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/reopen\")\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    def move_task(\n        self,\n        task_id: str,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n    ) -&gt; bool:\n        \"\"\"\n        Move a task to a different project, section, or parent task.\n\n        `project_id` takes predence, followed by\n        `section_id` (which also updates `project_id`),\n        and then `parent_id` (which also updates `section_id` and `project_id`).\n\n        :param task_id: The ID of the task to move.\n        :param project_id: The ID of the project to move the task to.\n        :param section_id: The ID of the section to move the task to.\n        :param parent_id: The ID of the parent to move the task to.\n        :return: True if the task was moved successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises ValueError: If neither `project_id`, `section_id`,\n                nor `parent_id` is provided.\n        \"\"\"\n        if project_id is None and section_id is None and parent_id is None:\n            raise ValueError(\n                \"Either `project_id`, `section_id`, or `parent_id` must be provided.\"\n            )\n\n        data = kwargs_without_none(\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n        )\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/move\")\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return response.is_success\n\n    def delete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Delete a task.\n\n        :param task_id: The ID of the task to delete.\n        :return: True if the task was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n        response = delete(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    def get_completed_tasks_by_due_date(\n        self,\n        *,\n        since: datetime,\n        until: datetime,\n        workspace_id: str | None = None,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        filter_query: str | None = None,\n        filter_lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of completed tasks within a due date range.\n\n        Retrieves tasks completed within a specific due date range (up to 6 weeks).\n        Supports filtering by workspace, project, section, parent task, or a query.\n\n        The response is an iterable of lists of completed tasks. Be aware that each\n        iteration fires off a network request to the Todoist API, and may result in\n        rate limiting or other API restrictions.\n\n        :param since: Start of the date range (inclusive).\n        :param until: End of the date range (inclusive).\n        :param workspace_id: Filter by workspace ID.\n        :param project_id: Filter by project ID.\n        :param section_id: Filter by section ID.\n        :param parent_id: Filter by parent task ID.\n        :param filter_query: Filter by a query string.\n        :param filter_lang: Language for the filter query (e.g., 'en').\n        :param limit: Maximum number of tasks per page (default 50).\n        :return: An iterable of lists of completed tasks.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_COMPLETED_BY_DUE_DATE_PATH)\n\n        params = kwargs_without_none(\n            since=format_datetime(since),\n            until=format_datetime(until),\n            workspace_id=workspace_id,\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            filter_query=filter_query,\n            filter_lang=filter_lang,\n            limit=limit,\n        )\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"items\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def get_completed_tasks_by_completion_date(\n        self,\n        *,\n        since: datetime,\n        until: datetime,\n        workspace_id: str | None = None,\n        filter_query: str | None = None,\n        filter_lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of completed tasks within a date range.\n\n        Retrieves tasks completed within a specific date range (up to 3 months).\n        Supports filtering by workspace or a filter query.\n\n        The response is an iterable of lists of completed tasks. Be aware that each\n        iteration fires off a network request to the Todoist API, and may result in\n        rate limiting or other API restrictions.\n\n        :param since: Start of the date range (inclusive).\n        :param until: End of the date range (inclusive).\n        :param workspace_id: Filter by workspace ID.\n        :param filter_query: Filter by a query string.\n        :param filter_lang: Language for the filter query (e.g., 'en').\n        :param limit: Maximum number of tasks per page (default 50).\n        :return: An iterable of lists of completed tasks.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_COMPLETED_BY_COMPLETION_DATE_PATH)\n\n        params = kwargs_without_none(\n            since=format_datetime(since),\n            until=format_datetime(until),\n            workspace_id=workspace_id,\n            filter_query=filter_query,\n            filter_lang=filter_lang,\n            limit=limit,\n        )\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"items\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def get_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Get a project by its ID.\n\n        :param project_id: The ID of the project to retrieve.\n        :return: The requested project.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n        response = get(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    def get_projects(\n        self,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Project]]:\n        \"\"\"\n        Get an iterable of lists of active projects.\n\n        The response is an iterable of lists of active projects.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param limit: Maximum number of projects per page.\n        :return: An iterable of lists of projects.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(PROJECTS_PATH)\n        params = kwargs_without_none(limit=limit)\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Project.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def search_projects(\n        self,\n        query: Annotated[str, MinLen(1), MaxLen(1024)],\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Project]]:\n        \"\"\"\n        Search active projects by name.\n\n        The response is an iterable of lists of projects matching the query.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query string for project names.\n        :param limit: Maximum number of projects per page.\n        :return: An iterable of lists of projects.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{PROJECTS_SEARCH_PATH_SUFFIX}\")\n\n        params = kwargs_without_none(query=query, limit=limit)\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Project.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_project(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(120)],\n        *,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        parent_id: str | None = None,\n        color: ColorString | None = None,\n        is_favorite: bool | None = None,\n        view_style: ViewStyle | None = None,\n    ) -&gt; Project:\n        \"\"\"\n        Create a new project.\n\n        :param name: The name of the project.\n        :param description: Description for the project (up to 1024 characters).\n        :param parent_id: The ID of the parent project. Set to null for root projects.\n        :param color: The color of the project icon.\n        :param is_favorite: Whether the project is a favorite.\n        :param view_style: A string value (either 'list' or 'board', default is 'list').\n        :return: The newly created project.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(PROJECTS_PATH)\n\n        data = kwargs_without_none(\n            name=name,\n            parent_id=parent_id,\n            description=description,\n            color=color,\n            is_favorite=is_favorite,\n            view_style=view_style,\n        )\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    def update_project(\n        self,\n        project_id: str,\n        *,\n        name: Annotated[str, MinLen(1), MaxLen(120)] | None = None,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        color: ColorString | None = None,\n        is_favorite: bool | None = None,\n        view_style: ViewStyle | None = None,\n    ) -&gt; Project:\n        \"\"\"\n        Update an existing project.\n\n        Only the fields to be updated need to be provided as keyword arguments.\n\n        :param project_id: The ID of the project to update.\n        :param name: The name of the project.\n        :param description: Description for the project (up to 1024 characters).\n        :param color: The color of the project icon.\n        :param is_favorite: Whether the project is a favorite.\n        :param view_style: A string value (either 'list' or 'board').\n        :return: the updated Project.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n\n        data = kwargs_without_none(\n            name=name,\n            description=description,\n            color=color,\n            is_favorite=is_favorite,\n            view_style=view_style,\n        )\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    def archive_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Archive a project.\n\n        For personal projects, archives it only for the user.\n        For workspace projects, archives it for all members.\n\n        :param project_id: The ID of the project to archive.\n        :return: The archived project object.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(\n            f\"{PROJECTS_PATH}/{project_id}/{PROJECT_ARCHIVE_PATH_SUFFIX}\"\n        )\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    def unarchive_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Unarchive a project.\n\n        Restores a previously archived project.\n\n        :param project_id: The ID of the project to unarchive.\n        :return: The unarchived project object.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(\n            f\"{PROJECTS_PATH}/{project_id}/{PROJECT_UNARCHIVE_PATH_SUFFIX}\"\n        )\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    def delete_project(self, project_id: str) -&gt; bool:\n        \"\"\"\n        Delete a project.\n\n        All nested sections and tasks will also be deleted.\n\n        :param project_id: The ID of the project to delete.\n        :return: True if the project was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n        response = delete(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    def get_collaborators(\n        self,\n        project_id: str,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Collaborator]]:\n        \"\"\"\n        Get an iterable of lists of collaborators in shared projects.\n\n        The response is an iterable of lists of collaborators in shared projects,\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: The ID of the project.\n        :param limit: Maximum number of collaborators per page.\n        :return: An iterable of lists of collaborators.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}/{COLLABORATORS_PATH}\")\n        params = kwargs_without_none(limit=limit)\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Collaborator.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def get_section(self, section_id: str) -&gt; Section:\n        \"\"\"\n        Get a specific section by its ID.\n\n        :param section_id: The ID of the section to retrieve.\n        :return: The requested section.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Section dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        response = get(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Section.from_dict(data)\n\n    def get_sections(\n        self,\n        project_id: str | None = None,\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Section]]:\n        \"\"\"\n        Get an iterable of lists of active sections.\n\n        Supports filtering by `project_id` and pagination arguments.\n\n        The response is an iterable of lists of active sections.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: Filter sections by project ID.\n        :param limit: Maximum number of sections per page.\n        :return: An iterable of lists of sections.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(SECTIONS_PATH)\n\n        params = kwargs_without_none(project_id=project_id, limit=limit)\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Section.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def search_sections(\n        self,\n        query: Annotated[str, MinLen(1), MaxLen(1024)],\n        *,\n        project_id: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Section]]:\n        \"\"\"\n        Search active sections by name.\n\n        The response is an iterable of lists of sections matching the query.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query string for section names.\n        :param project_id: If set, search sections within the given project only.\n        :param limit: Maximum number of sections per page.\n        :return: An iterable of lists of sections.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{SECTIONS_SEARCH_PATH_SUFFIX}\")\n\n        params = kwargs_without_none(query=query, project_id=project_id, limit=limit)\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Section.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_section(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(2048)],\n        project_id: str,\n        *,\n        order: int | None = None,\n    ) -&gt; Section:\n        \"\"\"\n        Create a new section within a project.\n\n        :param name: The name of the section.\n        :param project_id: The ID of the project to add the section to.\n        :param order: The order of the section among all sections in the project.\n        :return: The newly created section.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Section dictionary.\n        \"\"\"\n        endpoint = get_api_url(SECTIONS_PATH)\n\n        data = kwargs_without_none(name=name, project_id=project_id, order=order)\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Section.from_dict(data)\n\n    def update_section(\n        self,\n        section_id: str,\n        name: Annotated[str, MinLen(1), MaxLen(2048)],\n    ) -&gt; Section:\n        \"\"\"\n        Update an existing section.\n\n        Currently, only `name` can be updated.\n\n        :param section_id: The ID of the section to update.\n        :param name: The new name for the section.\n        :return: the updated Section.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data={\"name\": name},\n        )\n        data = response_json_dict(response)\n        return Section.from_dict(data)\n\n    def delete_section(self, section_id: str) -&gt; bool:\n        \"\"\"\n        Delete a section.\n\n        All tasks within the section will also be deleted.\n\n        :param section_id: The ID of the section to delete.\n        :return: True if the section was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        response = delete(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    def get_comment(self, comment_id: str) -&gt; Comment:\n        \"\"\"\n        Get a specific comment by its ID.\n\n        :param comment_id: The ID of the comment to retrieve.\n        :return: The requested comment.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Comment dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        response = get(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Comment.from_dict(data)\n\n    def get_comments(\n        self,\n        *,\n        project_id: str | None = None,\n        task_id: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Comment]]:\n        \"\"\"\n        Get an iterable of lists of comments for a task or project.\n\n        Requires either `project_id` or `task_id` to be set.\n\n        The response is an iterable of lists of comments.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: The ID of the project to retrieve comments for.\n        :param task_id: The ID of the task to retrieve comments for.\n        :param limit: Maximum number of comments per page.\n        :return: An iterable of lists of comments.\n        :raises ValueError: If neither `project_id` nor `task_id` is provided.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        if project_id is None and task_id is None:\n            raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n        endpoint = get_api_url(COMMENTS_PATH)\n\n        params = kwargs_without_none(\n            project_id=project_id,\n            task_id=task_id,\n            limit=limit,\n        )\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Comment.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_comment(\n        self,\n        content: Annotated[str, MaxLen(15000)],\n        *,\n        project_id: str | None = None,\n        task_id: str | None = None,\n        attachment: Attachment | None = None,\n        uids_to_notify: list[str] | None = None,\n    ) -&gt; Comment:\n        \"\"\"\n        Create a new comment on a task or project.\n\n        Requires either `project_id` or `task_id` to be set,\n        and can optionally include an `attachment` object.\n\n        :param content: The text content of the comment (supports Markdown).\n        :param project_id: The ID of the project to add the comment to.\n        :param task_id: The ID of the task to add the comment to.\n        :param attachment: The attachment object to include with the comment.\n        :param uids_to_notify: A list of user IDs to notify.\n        :return: The newly created comment.\n        :raises ValueError: If neither `project_id` nor `task_id` is provided.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Comment dictionary.\n        \"\"\"\n        if project_id is None and task_id is None:\n            raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n        endpoint = get_api_url(COMMENTS_PATH)\n\n        data = kwargs_without_none(\n            content=content,\n            project_id=project_id,\n            task_id=task_id,\n            attachment=attachment.to_dict() if attachment is not None else None,\n            uids_to_notify=uids_to_notify,\n        )\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Comment.from_dict(data)\n\n    def update_comment(\n        self, comment_id: str, content: Annotated[str, MaxLen(15000)]\n    ) -&gt; Comment:\n        \"\"\"\n        Update an existing comment.\n\n        Currently, only `content` can be updated.\n\n        :param comment_id: The ID of the comment to update.\n        :param content: The new text content for the comment.\n        :return: the updated Comment.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data={\"content\": content},\n        )\n        data = response_json_dict(response)\n        return Comment.from_dict(data)\n\n    def delete_comment(self, comment_id: str) -&gt; bool:\n        \"\"\"\n        Delete a comment.\n\n        :param comment_id: The ID of the comment to delete.\n        :return: True if the comment was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        response = delete(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    def get_label(self, label_id: str) -&gt; Label:\n        \"\"\"\n        Get a specific personal label by its ID.\n\n        :param label_id: The ID of the label to retrieve.\n        :return: The requested label.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Label dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n        response = get(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Label.from_dict(data)\n\n    def get_labels(\n        self,\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Label]]:\n        \"\"\"\n        Get an iterable of lists of personal labels.\n\n        Supports pagination arguments.\n\n        The response is an iterable of lists of personal labels.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param limit: Maximum number of labels per page.\n        :return: An iterable of lists of personal labels.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(LABELS_PATH)\n\n        params = kwargs_without_none(limit=limit)\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Label.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def search_labels(\n        self,\n        query: Annotated[str, MinLen(1), MaxLen(1024)],\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[Label]]:\n        \"\"\"\n        Search personal labels by name.\n\n        The response is an iterable of lists of labels matching the query.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query string for label names.\n        :param limit: Maximum number of labels per page.\n        :return: An iterable of lists of labels.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{LABELS_SEARCH_PATH_SUFFIX}\")\n\n        params = kwargs_without_none(query=query, limit=limit)\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Label.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def add_label(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(60)],\n        *,\n        color: ColorString | None = None,\n        item_order: int | None = None,\n        is_favorite: bool | None = None,\n    ) -&gt; Label:\n        \"\"\"\n        Create a new personal label.\n\n        :param name: The name of the label.\n        :param color: The color of the label icon.\n        :param item_order: Label's order in the label list.\n        :param is_favorite: Whether the label is a favorite.\n        :return: The newly created label.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Label dictionary.\n        \"\"\"\n        endpoint = get_api_url(LABELS_PATH)\n\n        data = kwargs_without_none(\n            name=name,\n            color=color,\n            item_order=item_order,\n            is_favorite=is_favorite,\n        )\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Label.from_dict(data)\n\n    def update_label(\n        self,\n        label_id: str,\n        *,\n        name: Annotated[str, MinLen(1), MaxLen(60)] | None = None,\n        color: ColorString | None = None,\n        item_order: int | None = None,\n        is_favorite: bool | None = None,\n    ) -&gt; Label:\n        \"\"\"\n        Update a personal label.\n\n        Only the fields to be updated need to be provided as keyword arguments.\n\n        :param label_id: The ID of the label.\n        :param name: The name of the label.\n        :param color: The color of the label icon.\n        :param item_order: Label's order in the label list.\n        :param is_favorite: Whether the label is a favorite.\n        :return: the updated Label.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n\n        data = kwargs_without_none(\n            name=name,\n            color=color,\n            item_order=item_order,\n            is_favorite=is_favorite,\n        )\n\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Label.from_dict(data)\n\n    def delete_label(self, label_id: str) -&gt; bool:\n        \"\"\"\n        Delete a personal label.\n\n        Instances of the label will be removed from tasks.\n\n        :param label_id: The ID of the label to delete.\n        :return: True if the label was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n        response = delete(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    def get_shared_labels(\n        self,\n        *,\n        omit_personal: bool = False,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; Iterator[list[str]]:\n        \"\"\"\n        Get an iterable of lists of shared label names.\n\n        Includes labels from collaborators on shared projects that are not in the\n        user's personal labels. Can optionally exclude personal label names using\n        `omit_personal=True`. Supports pagination arguments.\n\n        The response is an iterable of lists of shared label names.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param omit_personal: Optional boolean flag to omit personal label names.\n        :param limit: Maximum number of labels per page.\n        :return: An iterable of lists of shared label names (strings).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_PATH)\n\n        params = kwargs_without_none(omit_personal=omit_personal, limit=limit)\n\n        return ResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            str,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    def rename_shared_label(\n        self,\n        name: Annotated[str, MaxLen(60)],\n        new_name: Annotated[str, MinLen(1), MaxLen(60)],\n    ) -&gt; bool:\n        \"\"\"\n        Rename all occurrences of a shared label across all projects.\n\n        :param name: The current name of the shared label to rename.\n        :param new_name: The new name for the shared label.\n        :return: True if the rename was successful,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_RENAME_PATH)\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            params={\"name\": name},\n            data={\"new_name\": new_name},\n        )\n        return response.is_success\n\n    def remove_shared_label(self, name: Annotated[str, MaxLen(60)]) -&gt; bool:\n        \"\"\"\n        Remove all occurrences of a shared label across all projects.\n\n        This action removes the label string from all tasks where it appears.\n\n        :param name: The name of the shared label to remove.\n        :return: True if the removal was successful,\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_REMOVE_PATH)\n        data = {\"name\": name}\n        response = post(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return response.is_success\n</code></pre> <p>               Bases: <code>Iterator[list[T]]</code></p> <p>Iterator for paginated results from the Todoist API.</p> <p>It encapsulates the logic for fetching and iterating through paginated results from Todoist API endpoints. It handles cursor-based pagination automatically, requesting new pages as needed when iterating.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>class ResultsPaginator(Iterator[list[T]]):\n    \"\"\"\n    Iterator for paginated results from the Todoist API.\n\n    It encapsulates the logic for fetching and iterating through paginated results\n    from Todoist API endpoints. It handles cursor-based pagination automatically,\n    requesting new pages as needed when iterating.\n    \"\"\"\n\n    _client: httpx.Client\n    _url: str\n    _results_field: str\n    _results_inst: Callable[[Any], T]\n    _token: str\n    _cursor: str | None\n\n    def __init__(\n        self,\n        client: httpx.Client,\n        url: str,\n        results_field: str,\n        results_inst: Callable[[Any], T],\n        token: str,\n        request_id_fn: Callable[[], str] | None,\n        params: dict[str, Any],\n    ) -&gt; None:\n        \"\"\"\n        Initialize the ResultsPaginator.\n\n        :param client: The httpx client to use for API calls.\n        :param url: The API endpoint URL to fetch results from.\n        :param results_field: The key in the API response that contains the results.\n        :param results_inst: A callable that converts result items to objects of type T.\n        :param token: The authentication token for the Todoist API.\n        :param params: Query parameters to include in API requests.\n        \"\"\"\n        self._client = client\n        self._url = url\n        self._results_field = results_field\n        self._results_inst = results_inst\n        self._token = token\n        self._request_id_fn = request_id_fn\n        self._params = params\n        self._cursor = \"\"  # empty string for first page\n\n    def __next__(self) -&gt; list[T]:\n        \"\"\"\n        Fetch and return the next page of results from the Todoist API.\n\n        :return: A list of results.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        if self._cursor is None:\n            raise StopIteration\n\n        params = self._params.copy()\n        if self._cursor != \"\":\n            params[\"cursor\"] = self._cursor\n\n        response = get(\n            self._client,\n            self._url,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            params,\n        )\n        data = response_json_dict(response)\n        self._cursor = data.get(\"next_cursor\")\n\n        results: list[Any] = data.get(self._results_field, [])\n        return [self._results_inst(result) for result in results]\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_comment","title":"<code>add_comment(content, *, project_id=None, task_id=None, attachment=None, uids_to_notify=None)</code>","text":"<p>Create a new comment on a task or project.</p> <p>Requires either <code>project_id</code> or <code>task_id</code> to be set, and can optionally include an <code>attachment</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text content of the comment (supports Markdown).</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to add the comment to.</p> <code>None</code> <code>task_id</code> <code>str | None</code> <p>The ID of the task to add the comment to.</p> <code>None</code> <code>attachment</code> <code>Attachment | None</code> <p>The attachment object to include with the comment.</p> <code>None</code> <code>uids_to_notify</code> <code>list[str] | None</code> <p>A list of user IDs to notify.</p> <code>None</code> <p>Returns:</p> Type Description <code>Comment</code> <p>The newly created comment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>project_id</code> nor <code>task_id</code> is provided.</p> <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Comment dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_comment(\n    self,\n    content: Annotated[str, MaxLen(15000)],\n    *,\n    project_id: str | None = None,\n    task_id: str | None = None,\n    attachment: Attachment | None = None,\n    uids_to_notify: list[str] | None = None,\n) -&gt; Comment:\n    \"\"\"\n    Create a new comment on a task or project.\n\n    Requires either `project_id` or `task_id` to be set,\n    and can optionally include an `attachment` object.\n\n    :param content: The text content of the comment (supports Markdown).\n    :param project_id: The ID of the project to add the comment to.\n    :param task_id: The ID of the task to add the comment to.\n    :param attachment: The attachment object to include with the comment.\n    :param uids_to_notify: A list of user IDs to notify.\n    :return: The newly created comment.\n    :raises ValueError: If neither `project_id` nor `task_id` is provided.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Comment dictionary.\n    \"\"\"\n    if project_id is None and task_id is None:\n        raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n    endpoint = get_api_url(COMMENTS_PATH)\n\n    data = kwargs_without_none(\n        content=content,\n        project_id=project_id,\n        task_id=task_id,\n        attachment=attachment.to_dict() if attachment is not None else None,\n        uids_to_notify=uids_to_notify,\n    )\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Comment.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_label","title":"<code>add_label(name, *, color=None, item_order=None, is_favorite=None)</code>","text":"<p>Create a new personal label.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the label.</p> required <code>color</code> <code>ColorString | None</code> <p>The color of the label icon.</p> <code>None</code> <code>item_order</code> <code>int | None</code> <p>Label's order in the label list.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the label is a favorite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>The newly created label.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Label dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_label(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(60)],\n    *,\n    color: ColorString | None = None,\n    item_order: int | None = None,\n    is_favorite: bool | None = None,\n) -&gt; Label:\n    \"\"\"\n    Create a new personal label.\n\n    :param name: The name of the label.\n    :param color: The color of the label icon.\n    :param item_order: Label's order in the label list.\n    :param is_favorite: Whether the label is a favorite.\n    :return: The newly created label.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Label dictionary.\n    \"\"\"\n    endpoint = get_api_url(LABELS_PATH)\n\n    data = kwargs_without_none(\n        name=name,\n        color=color,\n        item_order=item_order,\n        is_favorite=is_favorite,\n    )\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Label.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_project","title":"<code>add_project(name, *, description=None, parent_id=None, color=None, is_favorite=None, view_style=None)</code>","text":"<p>Create a new project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the project.</p> required <code>description</code> <code>str | None</code> <p>Description for the project (up to 1024 characters).</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent project. Set to null for root projects.</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the project icon.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the project is a favorite.</p> <code>None</code> <code>view_style</code> <code>ViewStyle | None</code> <p>A string value (either 'list' or 'board', default is 'list').</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>The newly created project.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_project(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(120)],\n    *,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    parent_id: str | None = None,\n    color: ColorString | None = None,\n    is_favorite: bool | None = None,\n    view_style: ViewStyle | None = None,\n) -&gt; Project:\n    \"\"\"\n    Create a new project.\n\n    :param name: The name of the project.\n    :param description: Description for the project (up to 1024 characters).\n    :param parent_id: The ID of the parent project. Set to null for root projects.\n    :param color: The color of the project icon.\n    :param is_favorite: Whether the project is a favorite.\n    :param view_style: A string value (either 'list' or 'board', default is 'list').\n    :return: The newly created project.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(PROJECTS_PATH)\n\n    data = kwargs_without_none(\n        name=name,\n        parent_id=parent_id,\n        description=description,\n        color=color,\n        is_favorite=is_favorite,\n        view_style=view_style,\n    )\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_section","title":"<code>add_section(name, project_id, *, order=None)</code>","text":"<p>Create a new section within a project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the section.</p> required <code>project_id</code> <code>str</code> <p>The ID of the project to add the section to.</p> required <code>order</code> <code>int | None</code> <p>The order of the section among all sections in the project.</p> <code>None</code> <p>Returns:</p> Type Description <code>Section</code> <p>The newly created section.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Section dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_section(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(2048)],\n    project_id: str,\n    *,\n    order: int | None = None,\n) -&gt; Section:\n    \"\"\"\n    Create a new section within a project.\n\n    :param name: The name of the section.\n    :param project_id: The ID of the project to add the section to.\n    :param order: The order of the section among all sections in the project.\n    :return: The newly created section.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Section dictionary.\n    \"\"\"\n    endpoint = get_api_url(SECTIONS_PATH)\n\n    data = kwargs_without_none(name=name, project_id=project_id, order=order)\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Section.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_task","title":"<code>add_task(content, *, description=None, project_id=None, section_id=None, parent_id=None, labels=None, priority=None, due_string=None, due_lang=None, due_date=None, due_datetime=None, assignee_id=None, order=None, auto_reminder=None, auto_parse_labels=None, duration=None, duration_unit=None, deadline_date=None, deadline_lang=None)</code>","text":"<p>Create a new task.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text content of the task.</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to add the task to.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>The ID of the section to add the task to.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent task.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>The task's labels (a list of names).</p> <code>None</code> <code>priority</code> <code>int | None</code> <p>The priority of the task (4 for very urgent).</p> <code>None</code> <code>due_string</code> <code>str | None</code> <p>The due date in natural language format.</p> <code>None</code> <code>due_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the due date (e.g., 'en').</p> <code>None</code> <code>due_date</code> <code>date | None</code> <p>The due date as a date object.</p> <code>None</code> <code>due_datetime</code> <code>datetime | None</code> <p>The due date and time as a datetime object.</p> <code>None</code> <code>assignee_id</code> <code>str | None</code> <p>User ID to whom the task is assigned.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the task.</p> <code>None</code> <code>order</code> <code>int | None</code> <p>The order of task in the project or section.</p> <code>None</code> <code>auto_reminder</code> <code>bool | None</code> <p>Whether to add default reminder if date with time is set.</p> <code>None</code> <code>auto_parse_labels</code> <code>bool | None</code> <p>Whether to parse labels from task content.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>The amount of time the task will take.</p> <code>None</code> <code>duration_unit</code> <code>Literal['minute', 'day'] | None</code> <p>The unit of time for duration.</p> <code>None</code> <code>deadline_date</code> <code>date | None</code> <p>The deadline date as a date object.</p> <code>None</code> <code>deadline_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the deadline date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Task</code> <p>The newly created task.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Task dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_task(\n    self,\n    content: Annotated[str, MinLen(1), MaxLen(500)],\n    *,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    labels: list[Annotated[str, MaxLen(100)]] | None = None,\n    priority: Annotated[int, Ge(1), Le(4)] | None = None,\n    due_string: Annotated[str, MaxLen(150)] | None = None,\n    due_lang: LanguageCode | None = None,\n    due_date: date | None = None,\n    due_datetime: datetime | None = None,\n    assignee_id: str | None = None,\n    order: int | None = None,\n    auto_reminder: bool | None = None,\n    auto_parse_labels: bool | None = None,\n    duration: Annotated[int, Ge(1)] | None = None,\n    duration_unit: Literal[\"minute\", \"day\"] | None = None,\n    deadline_date: date | None = None,\n    deadline_lang: LanguageCode | None = None,\n) -&gt; Task:\n    \"\"\"\n    Create a new task.\n\n    :param content: The text content of the task.\n    :param project_id: The ID of the project to add the task to.\n    :param section_id: The ID of the section to add the task to.\n    :param parent_id: The ID of the parent task.\n    :param labels: The task's labels (a list of names).\n    :param priority: The priority of the task (4 for very urgent).\n    :param due_string: The due date in natural language format.\n    :param due_lang: Language for parsing the due date (e.g., 'en').\n    :param due_date: The due date as a date object.\n    :param due_datetime: The due date and time as a datetime object.\n    :param assignee_id: User ID to whom the task is assigned.\n    :param description: Description for the task.\n    :param order: The order of task in the project or section.\n    :param auto_reminder: Whether to add default reminder if date with time is set.\n    :param auto_parse_labels: Whether to parse labels from task content.\n    :param duration: The amount of time the task will take.\n    :param duration_unit: The unit of time for duration.\n    :param deadline_date: The deadline date as a date object.\n    :param deadline_lang: Language for parsing the deadline date.\n    :return: The newly created task.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Task dictionary.\n    \"\"\"\n    endpoint = get_api_url(TASKS_PATH)\n\n    data = kwargs_without_none(\n        content=content,\n        description=description,\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n        labels=labels,\n        priority=priority,\n        due_string=due_string,\n        due_lang=due_lang,\n        due_date=format_date(due_date) if due_date is not None else None,\n        due_datetime=(\n            format_datetime(due_datetime) if due_datetime is not None else None\n        ),\n        assignee_id=assignee_id,\n        order=order,\n        auto_reminder=auto_reminder,\n        auto_parse_labels=auto_parse_labels,\n        duration=duration,\n        duration_unit=duration_unit,\n        deadline_date=(\n            format_date(deadline_date) if deadline_date is not None else None\n        ),\n        deadline_lang=deadline_lang,\n    )\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Task.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.add_task_quick","title":"<code>add_task_quick(text, *, note=None, reminder=None, auto_reminder=True)</code>","text":"<p>Create a new task using Todoist's Quick Add syntax.</p> <p>This automatically parses dates, deadlines, projects, labels, priorities, etc, from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The task text using Quick Add syntax.</p> required <code>note</code> <code>str | None</code> <p>Optional note to be added to the task.</p> <code>None</code> <code>reminder</code> <code>str | None</code> <p>Optional reminder date in free form text.</p> <code>None</code> <code>auto_reminder</code> <code>bool</code> <p>Whether to add default reminder if date with time is set.</p> <code>True</code> <p>Returns:</p> Type Description <code>Task</code> <p>A result object containing the parsed task data and metadata.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response cannot be parsed into a QuickAddResult.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def add_task_quick(\n    self,\n    text: str,\n    *,\n    note: str | None = None,\n    reminder: str | None = None,\n    auto_reminder: bool = True,\n) -&gt; Task:\n    \"\"\"\n    Create a new task using Todoist's Quick Add syntax.\n\n    This automatically parses dates, deadlines, projects, labels, priorities, etc,\n    from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").\n\n    :param text: The task text using Quick Add syntax.\n    :param note: Optional note to be added to the task.\n    :param reminder: Optional reminder date in free form text.\n    :param auto_reminder: Whether to add default reminder if date with time is set.\n    :return: A result object containing the parsed task data and metadata.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response cannot be parsed into a QuickAddResult.\n    \"\"\"\n    endpoint = get_api_url(TASKS_QUICK_ADD_PATH)\n\n    data = kwargs_without_none(\n        meta=True,\n        text=text,\n        auto_reminder=auto_reminder,\n        note=note,\n        reminder=reminder,\n    )\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Task.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.archive_project","title":"<code>archive_project(project_id)</code>","text":"<p>Archive a project.</p> <p>For personal projects, archives it only for the user. For workspace projects, archives it for all members.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to archive.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The archived project object.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def archive_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Archive a project.\n\n    For personal projects, archives it only for the user.\n    For workspace projects, archives it for all members.\n\n    :param project_id: The ID of the project to archive.\n    :return: The archived project object.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(\n        f\"{PROJECTS_PATH}/{project_id}/{PROJECT_ARCHIVE_PATH_SUFFIX}\"\n    )\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.complete_task","title":"<code>complete_task(task_id)</code>","text":"<p>Complete a task.</p> <p>For recurring tasks, this schedules the next occurrence. For non-recurring tasks, it marks them as completed.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to close.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was closed successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def complete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Complete a task.\n\n    For recurring tasks, this schedules the next occurrence.\n    For non-recurring tasks, it marks them as completed.\n\n    :param task_id: The ID of the task to close.\n    :return: True if the task was closed successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/close\")\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_comment","title":"<code>delete_comment(comment_id)</code>","text":"<p>Delete a comment.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the comment was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_comment(self, comment_id: str) -&gt; bool:\n    \"\"\"\n    Delete a comment.\n\n    :param comment_id: The ID of the comment to delete.\n    :return: True if the comment was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    response = delete(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_label","title":"<code>delete_label(label_id)</code>","text":"<p>Delete a personal label.</p> <p>Instances of the label will be removed from tasks.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the label was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_label(self, label_id: str) -&gt; bool:\n    \"\"\"\n    Delete a personal label.\n\n    Instances of the label will be removed from tasks.\n\n    :param label_id: The ID of the label to delete.\n    :return: True if the label was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n    response = delete(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_project","title":"<code>delete_project(project_id)</code>","text":"<p>Delete a project.</p> <p>All nested sections and tasks will also be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the project was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_project(self, project_id: str) -&gt; bool:\n    \"\"\"\n    Delete a project.\n\n    All nested sections and tasks will also be deleted.\n\n    :param project_id: The ID of the project to delete.\n    :return: True if the project was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n    response = delete(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_section","title":"<code>delete_section(section_id)</code>","text":"<p>Delete a section.</p> <p>All tasks within the section will also be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the section was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_section(self, section_id: str) -&gt; bool:\n    \"\"\"\n    Delete a section.\n\n    All tasks within the section will also be deleted.\n\n    :param section_id: The ID of the section to delete.\n    :return: True if the section was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    response = delete(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.delete_task","title":"<code>delete_task(task_id)</code>","text":"<p>Delete a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def delete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Delete a task.\n\n    :param task_id: The ID of the task to delete.\n    :return: True if the task was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n    response = delete(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.filter_tasks","title":"<code>filter_tasks(*, query=None, lang=None, limit=None)</code>","text":"<p>Get an iterable of lists of active tasks matching the filter.</p> <p>The response is an iterable of lists of active tasks matching the criteria. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>Query tasks using Todoist's filter language.</p> <code>None</code> <code>lang</code> <code>str | None</code> <p>Language for task content (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Task]]</code> <p>An iterable of lists of tasks.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def filter_tasks(\n    self,\n    *,\n    query: Annotated[str, MaxLen(1024)] | None = None,\n    lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of active tasks matching the filter.\n\n    The response is an iterable of lists of active tasks matching the criteria.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query tasks using Todoist's filter language.\n    :param lang: Language for task content (e.g., 'en').\n    :param limit: Maximum number of tasks per page.\n    :return: An iterable of lists of tasks.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_FILTER_PATH)\n\n    params = kwargs_without_none(query=query, lang=lang, limit=limit)\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_collaborators","title":"<code>get_collaborators(project_id, limit=None)</code>","text":"<p>Get an iterable of lists of collaborators in shared projects.</p> <p>The response is an iterable of lists of collaborators in shared projects, Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project.</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of collaborators per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Collaborator]]</code> <p>An iterable of lists of collaborators.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_collaborators(\n    self,\n    project_id: str,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Collaborator]]:\n    \"\"\"\n    Get an iterable of lists of collaborators in shared projects.\n\n    The response is an iterable of lists of collaborators in shared projects,\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: The ID of the project.\n    :param limit: Maximum number of collaborators per page.\n    :return: An iterable of lists of collaborators.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}/{COLLABORATORS_PATH}\")\n    params = kwargs_without_none(limit=limit)\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Collaborator.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_comment","title":"<code>get_comment(comment_id)</code>","text":"<p>Get a specific comment by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to retrieve.</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>The requested comment.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Comment dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_comment(self, comment_id: str) -&gt; Comment:\n    \"\"\"\n    Get a specific comment by its ID.\n\n    :param comment_id: The ID of the comment to retrieve.\n    :return: The requested comment.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Comment dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    response = get(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Comment.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_comments","title":"<code>get_comments(*, project_id=None, task_id=None, limit=None)</code>","text":"<p>Get an iterable of lists of comments for a task or project.</p> <p>Requires either <code>project_id</code> or <code>task_id</code> to be set.</p> <p>The response is an iterable of lists of comments. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>The ID of the project to retrieve comments for.</p> <code>None</code> <code>task_id</code> <code>str | None</code> <p>The ID of the task to retrieve comments for.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of comments per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Comment]]</code> <p>An iterable of lists of comments.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>project_id</code> nor <code>task_id</code> is provided.</p> <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_comments(\n    self,\n    *,\n    project_id: str | None = None,\n    task_id: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Comment]]:\n    \"\"\"\n    Get an iterable of lists of comments for a task or project.\n\n    Requires either `project_id` or `task_id` to be set.\n\n    The response is an iterable of lists of comments.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: The ID of the project to retrieve comments for.\n    :param task_id: The ID of the task to retrieve comments for.\n    :param limit: Maximum number of comments per page.\n    :return: An iterable of lists of comments.\n    :raises ValueError: If neither `project_id` nor `task_id` is provided.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    if project_id is None and task_id is None:\n        raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n    endpoint = get_api_url(COMMENTS_PATH)\n\n    params = kwargs_without_none(\n        project_id=project_id,\n        task_id=task_id,\n        limit=limit,\n    )\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Comment.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_completed_tasks_by_completion_date","title":"<code>get_completed_tasks_by_completion_date(*, since, until, workspace_id=None, filter_query=None, filter_lang=None, limit=None)</code>","text":"<p>Get an iterable of lists of completed tasks within a date range.</p> <p>Retrieves tasks completed within a specific date range (up to 3 months). Supports filtering by workspace or a filter query.</p> <p>The response is an iterable of lists of completed tasks. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>datetime</code> <p>Start of the date range (inclusive).</p> required <code>until</code> <code>datetime</code> <p>End of the date range (inclusive).</p> required <code>workspace_id</code> <code>str | None</code> <p>Filter by workspace ID.</p> <code>None</code> <code>filter_query</code> <code>str | None</code> <p>Filter by a query string.</p> <code>None</code> <code>filter_lang</code> <code>str | None</code> <p>Language for the filter query (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (default 50).</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Task]]</code> <p>An iterable of lists of completed tasks.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_completed_tasks_by_completion_date(\n    self,\n    *,\n    since: datetime,\n    until: datetime,\n    workspace_id: str | None = None,\n    filter_query: str | None = None,\n    filter_lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of completed tasks within a date range.\n\n    Retrieves tasks completed within a specific date range (up to 3 months).\n    Supports filtering by workspace or a filter query.\n\n    The response is an iterable of lists of completed tasks. Be aware that each\n    iteration fires off a network request to the Todoist API, and may result in\n    rate limiting or other API restrictions.\n\n    :param since: Start of the date range (inclusive).\n    :param until: End of the date range (inclusive).\n    :param workspace_id: Filter by workspace ID.\n    :param filter_query: Filter by a query string.\n    :param filter_lang: Language for the filter query (e.g., 'en').\n    :param limit: Maximum number of tasks per page (default 50).\n    :return: An iterable of lists of completed tasks.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_COMPLETED_BY_COMPLETION_DATE_PATH)\n\n    params = kwargs_without_none(\n        since=format_datetime(since),\n        until=format_datetime(until),\n        workspace_id=workspace_id,\n        filter_query=filter_query,\n        filter_lang=filter_lang,\n        limit=limit,\n    )\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"items\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_completed_tasks_by_due_date","title":"<code>get_completed_tasks_by_due_date(*, since, until, workspace_id=None, project_id=None, section_id=None, parent_id=None, filter_query=None, filter_lang=None, limit=None)</code>","text":"<p>Get an iterable of lists of completed tasks within a due date range.</p> <p>Retrieves tasks completed within a specific due date range (up to 6 weeks). Supports filtering by workspace, project, section, parent task, or a query.</p> <p>The response is an iterable of lists of completed tasks. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>datetime</code> <p>Start of the date range (inclusive).</p> required <code>until</code> <code>datetime</code> <p>End of the date range (inclusive).</p> required <code>workspace_id</code> <code>str | None</code> <p>Filter by workspace ID.</p> <code>None</code> <code>project_id</code> <code>str | None</code> <p>Filter by project ID.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>Filter by section ID.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter by parent task ID.</p> <code>None</code> <code>filter_query</code> <code>str | None</code> <p>Filter by a query string.</p> <code>None</code> <code>filter_lang</code> <code>str | None</code> <p>Language for the filter query (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (default 50).</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Task]]</code> <p>An iterable of lists of completed tasks.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_completed_tasks_by_due_date(\n    self,\n    *,\n    since: datetime,\n    until: datetime,\n    workspace_id: str | None = None,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    filter_query: str | None = None,\n    filter_lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of completed tasks within a due date range.\n\n    Retrieves tasks completed within a specific due date range (up to 6 weeks).\n    Supports filtering by workspace, project, section, parent task, or a query.\n\n    The response is an iterable of lists of completed tasks. Be aware that each\n    iteration fires off a network request to the Todoist API, and may result in\n    rate limiting or other API restrictions.\n\n    :param since: Start of the date range (inclusive).\n    :param until: End of the date range (inclusive).\n    :param workspace_id: Filter by workspace ID.\n    :param project_id: Filter by project ID.\n    :param section_id: Filter by section ID.\n    :param parent_id: Filter by parent task ID.\n    :param filter_query: Filter by a query string.\n    :param filter_lang: Language for the filter query (e.g., 'en').\n    :param limit: Maximum number of tasks per page (default 50).\n    :return: An iterable of lists of completed tasks.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_COMPLETED_BY_DUE_DATE_PATH)\n\n    params = kwargs_without_none(\n        since=format_datetime(since),\n        until=format_datetime(until),\n        workspace_id=workspace_id,\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n        filter_query=filter_query,\n        filter_lang=filter_lang,\n        limit=limit,\n    )\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"items\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_label","title":"<code>get_label(label_id)</code>","text":"<p>Get a specific personal label by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label to retrieve.</p> required <p>Returns:</p> Type Description <code>Label</code> <p>The requested label.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Label dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_label(self, label_id: str) -&gt; Label:\n    \"\"\"\n    Get a specific personal label by its ID.\n\n    :param label_id: The ID of the label to retrieve.\n    :return: The requested label.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Label dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n    response = get(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Label.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_labels","title":"<code>get_labels(*, limit=None)</code>","text":"<p>Get an iterable of lists of personal labels.</p> <p>Supports pagination arguments.</p> <p>The response is an iterable of lists of personal labels. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Label]]</code> <p>An iterable of lists of personal labels.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_labels(\n    self,\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Label]]:\n    \"\"\"\n    Get an iterable of lists of personal labels.\n\n    Supports pagination arguments.\n\n    The response is an iterable of lists of personal labels.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param limit: Maximum number of labels per page.\n    :return: An iterable of lists of personal labels.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(LABELS_PATH)\n\n    params = kwargs_without_none(limit=limit)\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Label.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_project","title":"<code>get_project(project_id)</code>","text":"<p>Get a project by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to retrieve.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The requested project.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Get a project by its ID.\n\n    :param project_id: The ID of the project to retrieve.\n    :return: The requested project.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n    response = get(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_projects","title":"<code>get_projects(limit=None)</code>","text":"<p>Get an iterable of lists of active projects.</p> <p>The response is an iterable of lists of active projects. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of projects per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Project]]</code> <p>An iterable of lists of projects.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_projects(\n    self,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Project]]:\n    \"\"\"\n    Get an iterable of lists of active projects.\n\n    The response is an iterable of lists of active projects.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param limit: Maximum number of projects per page.\n    :return: An iterable of lists of projects.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(PROJECTS_PATH)\n    params = kwargs_without_none(limit=limit)\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Project.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_section","title":"<code>get_section(section_id)</code>","text":"<p>Get a specific section by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to retrieve.</p> required <p>Returns:</p> Type Description <code>Section</code> <p>The requested section.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Section dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_section(self, section_id: str) -&gt; Section:\n    \"\"\"\n    Get a specific section by its ID.\n\n    :param section_id: The ID of the section to retrieve.\n    :return: The requested section.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Section dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    response = get(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Section.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_sections","title":"<code>get_sections(project_id=None, *, limit=None)</code>","text":"<p>Get an iterable of lists of active sections.</p> <p>Supports filtering by <code>project_id</code> and pagination arguments.</p> <p>The response is an iterable of lists of active sections. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>Filter sections by project ID.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of sections per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Section]]</code> <p>An iterable of lists of sections.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_sections(\n    self,\n    project_id: str | None = None,\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Section]]:\n    \"\"\"\n    Get an iterable of lists of active sections.\n\n    Supports filtering by `project_id` and pagination arguments.\n\n    The response is an iterable of lists of active sections.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: Filter sections by project ID.\n    :param limit: Maximum number of sections per page.\n    :return: An iterable of lists of sections.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(SECTIONS_PATH)\n\n    params = kwargs_without_none(project_id=project_id, limit=limit)\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Section.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_shared_labels","title":"<code>get_shared_labels(*, omit_personal=False, limit=None)</code>","text":"<p>Get an iterable of lists of shared label names.</p> <p>Includes labels from collaborators on shared projects that are not in the user's personal labels. Can optionally exclude personal label names using <code>omit_personal=True</code>. Supports pagination arguments.</p> <p>The response is an iterable of lists of shared label names. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>omit_personal</code> <code>bool</code> <p>Optional boolean flag to omit personal label names.</p> <code>False</code> <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[str]]</code> <p>An iterable of lists of shared label names (strings).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_shared_labels(\n    self,\n    *,\n    omit_personal: bool = False,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[str]]:\n    \"\"\"\n    Get an iterable of lists of shared label names.\n\n    Includes labels from collaborators on shared projects that are not in the\n    user's personal labels. Can optionally exclude personal label names using\n    `omit_personal=True`. Supports pagination arguments.\n\n    The response is an iterable of lists of shared label names.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param omit_personal: Optional boolean flag to omit personal label names.\n    :param limit: Maximum number of labels per page.\n    :return: An iterable of lists of shared label names (strings).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_PATH)\n\n    params = kwargs_without_none(omit_personal=omit_personal, limit=limit)\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        str,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_task","title":"<code>get_task(task_id)</code>","text":"<p>Get a specific task by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>Task</code> <p>The requested task.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Task dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_task(self, task_id: str) -&gt; Task:\n    \"\"\"\n    Get a specific task by its ID.\n\n    :param task_id: The ID of the task to retrieve.\n    :return: The requested task.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Task dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n    response = get(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Task.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.get_tasks","title":"<code>get_tasks(*, project_id=None, section_id=None, parent_id=None, label=None, ids=None, limit=None)</code>","text":"<p>Get an iterable of lists of active tasks.</p> <p>The response is an iterable of lists of active tasks matching the criteria. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>Filter tasks by project ID.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>Filter tasks by section ID.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter tasks by parent task ID.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Filter tasks by label name.</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>A list of the IDs of the tasks to retrieve.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Task]]</code> <p>An iterable of lists of tasks.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def get_tasks(\n    self,\n    *,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    label: str | None = None,\n    ids: list[str] | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of active tasks.\n\n    The response is an iterable of lists of active tasks matching the criteria.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: Filter tasks by project ID.\n    :param section_id: Filter tasks by section ID.\n    :param parent_id: Filter tasks by parent task ID.\n    :param label: Filter tasks by label name.\n    :param ids: A list of the IDs of the tasks to retrieve.\n    :param limit: Maximum number of tasks per page.\n    :return: An iterable of lists of tasks.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_PATH)\n\n    params = kwargs_without_none(\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n        label=label,\n        ids=\",\".join(str(i) for i in ids) if ids is not None else None,\n        limit=limit,\n    )\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.move_task","title":"<code>move_task(task_id, project_id=None, section_id=None, parent_id=None)</code>","text":"<p>Move a task to a different project, section, or parent task.</p> <p><code>project_id</code> takes predence, followed by <code>section_id</code> (which also updates <code>project_id</code>), and then <code>parent_id</code> (which also updates <code>section_id</code> and <code>project_id</code>).</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to move.</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to move the task to.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>The ID of the section to move the task to.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent to move the task to.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was moved successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>ValueError</code> <p>If neither <code>project_id</code>, <code>section_id</code>, nor <code>parent_id</code> is provided.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def move_task(\n    self,\n    task_id: str,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n) -&gt; bool:\n    \"\"\"\n    Move a task to a different project, section, or parent task.\n\n    `project_id` takes predence, followed by\n    `section_id` (which also updates `project_id`),\n    and then `parent_id` (which also updates `section_id` and `project_id`).\n\n    :param task_id: The ID of the task to move.\n    :param project_id: The ID of the project to move the task to.\n    :param section_id: The ID of the section to move the task to.\n    :param parent_id: The ID of the parent to move the task to.\n    :return: True if the task was moved successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises ValueError: If neither `project_id`, `section_id`,\n            nor `parent_id` is provided.\n    \"\"\"\n    if project_id is None and section_id is None and parent_id is None:\n        raise ValueError(\n            \"Either `project_id`, `section_id`, or `parent_id` must be provided.\"\n        )\n\n    data = kwargs_without_none(\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n    )\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/move\")\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.remove_shared_label","title":"<code>remove_shared_label(name)</code>","text":"<p>Remove all occurrences of a shared label across all projects.</p> <p>This action removes the label string from all tasks where it appears.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the shared label to remove.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the removal was successful,</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def remove_shared_label(self, name: Annotated[str, MaxLen(60)]) -&gt; bool:\n    \"\"\"\n    Remove all occurrences of a shared label across all projects.\n\n    This action removes the label string from all tasks where it appears.\n\n    :param name: The name of the shared label to remove.\n    :return: True if the removal was successful,\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_REMOVE_PATH)\n    data = {\"name\": name}\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.rename_shared_label","title":"<code>rename_shared_label(name, new_name)</code>","text":"<p>Rename all occurrences of a shared label across all projects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The current name of the shared label to rename.</p> required <code>new_name</code> <code>str</code> <p>The new name for the shared label.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the rename was successful, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def rename_shared_label(\n    self,\n    name: Annotated[str, MaxLen(60)],\n    new_name: Annotated[str, MinLen(1), MaxLen(60)],\n) -&gt; bool:\n    \"\"\"\n    Rename all occurrences of a shared label across all projects.\n\n    :param name: The current name of the shared label to rename.\n    :param new_name: The new name for the shared label.\n    :return: True if the rename was successful,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_RENAME_PATH)\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        params={\"name\": name},\n        data={\"new_name\": new_name},\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.search_labels","title":"<code>search_labels(query, *, limit=None)</code>","text":"<p>Search personal labels by name.</p> <p>The response is an iterable of lists of labels matching the query. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string for label names.</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Label]]</code> <p>An iterable of lists of labels.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def search_labels(\n    self,\n    query: Annotated[str, MinLen(1), MaxLen(1024)],\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Label]]:\n    \"\"\"\n    Search personal labels by name.\n\n    The response is an iterable of lists of labels matching the query.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query string for label names.\n    :param limit: Maximum number of labels per page.\n    :return: An iterable of lists of labels.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{LABELS_SEARCH_PATH_SUFFIX}\")\n\n    params = kwargs_without_none(query=query, limit=limit)\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Label.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.search_projects","title":"<code>search_projects(query, *, limit=None)</code>","text":"<p>Search active projects by name.</p> <p>The response is an iterable of lists of projects matching the query. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string for project names.</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of projects per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Project]]</code> <p>An iterable of lists of projects.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def search_projects(\n    self,\n    query: Annotated[str, MinLen(1), MaxLen(1024)],\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Project]]:\n    \"\"\"\n    Search active projects by name.\n\n    The response is an iterable of lists of projects matching the query.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query string for project names.\n    :param limit: Maximum number of projects per page.\n    :return: An iterable of lists of projects.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{PROJECTS_SEARCH_PATH_SUFFIX}\")\n\n    params = kwargs_without_none(query=query, limit=limit)\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Project.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.search_sections","title":"<code>search_sections(query, *, project_id=None, limit=None)</code>","text":"<p>Search active sections by name.</p> <p>The response is an iterable of lists of sections matching the query. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string for section names.</p> required <code>project_id</code> <code>str | None</code> <p>If set, search sections within the given project only.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of sections per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iterator[list[Section]]</code> <p>An iterable of lists of sections.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def search_sections(\n    self,\n    query: Annotated[str, MinLen(1), MaxLen(1024)],\n    *,\n    project_id: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; Iterator[list[Section]]:\n    \"\"\"\n    Search active sections by name.\n\n    The response is an iterable of lists of sections matching the query.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query string for section names.\n    :param project_id: If set, search sections within the given project only.\n    :param limit: Maximum number of sections per page.\n    :return: An iterable of lists of sections.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{SECTIONS_SEARCH_PATH_SUFFIX}\")\n\n    params = kwargs_without_none(query=query, project_id=project_id, limit=limit)\n\n    return ResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Section.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.unarchive_project","title":"<code>unarchive_project(project_id)</code>","text":"<p>Unarchive a project.</p> <p>Restores a previously archived project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to unarchive.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The unarchived project object.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def unarchive_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Unarchive a project.\n\n    Restores a previously archived project.\n\n    :param project_id: The ID of the project to unarchive.\n    :return: The unarchived project object.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(\n        f\"{PROJECTS_PATH}/{project_id}/{PROJECT_UNARCHIVE_PATH_SUFFIX}\"\n    )\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.uncomplete_task","title":"<code>uncomplete_task(task_id)</code>","text":"<p>Uncomplete a (completed) task.</p> <p>Any parent tasks or sections will also be uncompleted.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to reopen.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was uncompleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def uncomplete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Uncomplete a (completed) task.\n\n    Any parent tasks or sections will also be uncompleted.\n\n    :param task_id: The ID of the task to reopen.\n    :return: True if the task was uncompleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/reopen\")\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_comment","title":"<code>update_comment(comment_id, content)</code>","text":"<p>Update an existing comment.</p> <p>Currently, only <code>content</code> can be updated.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to update.</p> required <code>content</code> <code>str</code> <p>The new text content for the comment.</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>the updated Comment.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_comment(\n    self, comment_id: str, content: Annotated[str, MaxLen(15000)]\n) -&gt; Comment:\n    \"\"\"\n    Update an existing comment.\n\n    Currently, only `content` can be updated.\n\n    :param comment_id: The ID of the comment to update.\n    :param content: The new text content for the comment.\n    :return: the updated Comment.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data={\"content\": content},\n    )\n    data = response_json_dict(response)\n    return Comment.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_label","title":"<code>update_label(label_id, *, name=None, color=None, item_order=None, is_favorite=None)</code>","text":"<p>Update a personal label.</p> <p>Only the fields to be updated need to be provided as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label.</p> required <code>name</code> <code>str | None</code> <p>The name of the label.</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the label icon.</p> <code>None</code> <code>item_order</code> <code>int | None</code> <p>Label's order in the label list.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the label is a favorite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>the updated Label.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_label(\n    self,\n    label_id: str,\n    *,\n    name: Annotated[str, MinLen(1), MaxLen(60)] | None = None,\n    color: ColorString | None = None,\n    item_order: int | None = None,\n    is_favorite: bool | None = None,\n) -&gt; Label:\n    \"\"\"\n    Update a personal label.\n\n    Only the fields to be updated need to be provided as keyword arguments.\n\n    :param label_id: The ID of the label.\n    :param name: The name of the label.\n    :param color: The color of the label icon.\n    :param item_order: Label's order in the label list.\n    :param is_favorite: Whether the label is a favorite.\n    :return: the updated Label.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n\n    data = kwargs_without_none(\n        name=name,\n        color=color,\n        item_order=item_order,\n        is_favorite=is_favorite,\n    )\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Label.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_project","title":"<code>update_project(project_id, *, name=None, description=None, color=None, is_favorite=None, view_style=None)</code>","text":"<p>Update an existing project.</p> <p>Only the fields to be updated need to be provided as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to update.</p> required <code>name</code> <code>str | None</code> <p>The name of the project.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the project (up to 1024 characters).</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the project icon.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the project is a favorite.</p> <code>None</code> <code>view_style</code> <code>ViewStyle | None</code> <p>A string value (either 'list' or 'board').</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>the updated Project.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_project(\n    self,\n    project_id: str,\n    *,\n    name: Annotated[str, MinLen(1), MaxLen(120)] | None = None,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    color: ColorString | None = None,\n    is_favorite: bool | None = None,\n    view_style: ViewStyle | None = None,\n) -&gt; Project:\n    \"\"\"\n    Update an existing project.\n\n    Only the fields to be updated need to be provided as keyword arguments.\n\n    :param project_id: The ID of the project to update.\n    :param name: The name of the project.\n    :param description: Description for the project (up to 1024 characters).\n    :param color: The color of the project icon.\n    :param is_favorite: Whether the project is a favorite.\n    :param view_style: A string value (either 'list' or 'board').\n    :return: the updated Project.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n\n    data = kwargs_without_none(\n        name=name,\n        description=description,\n        color=color,\n        is_favorite=is_favorite,\n        view_style=view_style,\n    )\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_section","title":"<code>update_section(section_id, name)</code>","text":"<p>Update an existing section.</p> <p>Currently, only <code>name</code> can be updated.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to update.</p> required <code>name</code> <code>str</code> <p>The new name for the section.</p> required <p>Returns:</p> Type Description <code>Section</code> <p>the updated Section.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_section(\n    self,\n    section_id: str,\n    name: Annotated[str, MinLen(1), MaxLen(2048)],\n) -&gt; Section:\n    \"\"\"\n    Update an existing section.\n\n    Currently, only `name` can be updated.\n\n    :param section_id: The ID of the section to update.\n    :param name: The new name for the section.\n    :return: the updated Section.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data={\"name\": name},\n    )\n    data = response_json_dict(response)\n    return Section.from_dict(data)\n</code></pre>"},{"location":"api/#todoist_api_python.api.TodoistAPI.update_task","title":"<code>update_task(task_id, *, content=None, description=None, labels=None, priority=None, due_string=None, due_lang=None, due_date=None, due_datetime=None, assignee_id=None, order=None, day_order=None, collapsed=None, duration=None, duration_unit=None, deadline_date=None, deadline_lang=None)</code>","text":"<p>Update an existing task.</p> <p>Only the fields to be updated need to be provided.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>content</code> <code>str | None</code> <p>The text content of the task.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the task.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>The task's labels (a list of names).</p> <code>None</code> <code>priority</code> <code>int | None</code> <p>The priority of the task (4 for very urgent).</p> <code>None</code> <code>due_string</code> <code>str | None</code> <p>The due date in natural language format.</p> <code>None</code> <code>due_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the due date (e.g., 'en').</p> <code>None</code> <code>due_date</code> <code>date | None</code> <p>The due date as a date object.</p> <code>None</code> <code>due_datetime</code> <code>datetime | None</code> <p>The due date and time as a datetime object.</p> <code>None</code> <code>assignee_id</code> <code>str | None</code> <p>User ID to whom the task is assigned.</p> <code>None</code> <code>order</code> <code>int | None</code> <p>The order of task in the project or section.</p> <code>None</code> <code>day_order</code> <code>int | None</code> <p>The order of the task inside Today or Next 7 days view.</p> <code>None</code> <code>collapsed</code> <code>bool | None</code> <p>Whether the task's sub-tasks are collapsed.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>The amount of time the task will take.</p> <code>None</code> <code>duration_unit</code> <code>Literal['minute', 'day'] | None</code> <p>The unit of time for duration.</p> <code>None</code> <code>deadline_date</code> <code>date | None</code> <p>The deadline date as a date object.</p> <code>None</code> <code>deadline_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the deadline date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Task</code> <p>the updated Task.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api.py</code> <pre><code>def update_task(\n    self,\n    task_id: str,\n    *,\n    content: Annotated[str, MinLen(1), MaxLen(500)] | None = None,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    labels: list[Annotated[str, MaxLen(60)]] | None = None,\n    priority: Annotated[int, Ge(1), Le(4)] | None = None,\n    due_string: Annotated[str, MaxLen(150)] | None = None,\n    due_lang: LanguageCode | None = None,\n    due_date: date | None = None,\n    due_datetime: datetime | None = None,\n    assignee_id: str | None = None,\n    order: int | None = None,\n    day_order: int | None = None,\n    collapsed: bool | None = None,\n    duration: Annotated[int, Ge(1)] | None = None,\n    duration_unit: Literal[\"minute\", \"day\"] | None = None,\n    deadline_date: date | None = None,\n    deadline_lang: LanguageCode | None = None,\n) -&gt; Task:\n    \"\"\"\n    Update an existing task.\n\n    Only the fields to be updated need to be provided.\n\n    :param task_id: The ID of the task to update.\n    :param content: The text content of the task.\n    :param description: Description for the task.\n    :param labels: The task's labels (a list of names).\n    :param priority: The priority of the task (4 for very urgent).\n    :param due_string: The due date in natural language format.\n    :param due_lang: Language for parsing the due date (e.g., 'en').\n    :param due_date: The due date as a date object.\n    :param due_datetime: The due date and time as a datetime object.\n    :param assignee_id: User ID to whom the task is assigned.\n    :param order: The order of task in the project or section.\n    :param day_order: The order of the task inside Today or Next 7 days view.\n    :param collapsed: Whether the task's sub-tasks are collapsed.\n    :param duration: The amount of time the task will take.\n    :param duration_unit: The unit of time for duration.\n    :param deadline_date: The deadline date as a date object.\n    :param deadline_lang: Language for parsing the deadline date.\n    :return: the updated Task.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n\n    data = kwargs_without_none(\n        content=content,\n        description=description,\n        labels=labels,\n        priority=priority,\n        due_string=due_string,\n        due_lang=due_lang,\n        due_date=format_date(due_date) if due_date is not None else None,\n        due_datetime=(\n            format_datetime(due_datetime) if due_datetime is not None else None\n        ),\n        assignee_id=assignee_id,\n        order=order,\n        day_order=day_order,\n        collapsed=collapsed,\n        duration=duration,\n        duration_unit=duration_unit,\n        deadline_date=(\n            format_date(deadline_date) if deadline_date is not None else None\n        ),\n        deadline_lang=deadline_lang,\n    )\n\n    response = post(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Task.from_dict(data)\n</code></pre>"},{"location":"api_async/","title":"API Client (async)","text":"<p>Async client for the Todoist API.</p> <p>Provides asynchronous methods for interacting with Todoist resources like tasks, projects, labels, comments, etc.</p> <p>Manages an HTTP client and handles authentication.</p> <p>Prefer using this class as an async context manager to ensure the underlying <code>httpx.AsyncClient</code> is always closed. If you do not use <code>async with</code>, call <code>await close()</code> explicitly.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>class TodoistAPIAsync:\n    \"\"\"\n    Async client for the Todoist API.\n\n    Provides asynchronous methods for interacting with Todoist resources like\n    tasks, projects, labels, comments, etc.\n\n    Manages an HTTP client and handles authentication.\n\n    Prefer using this class as an async context manager to ensure the underlying\n    `httpx.AsyncClient` is always closed. If you do not use `async with`, call\n    `await close()` explicitly.\n    \"\"\"\n\n    def __init__(\n        self,\n        token: str,\n        request_id_fn: Callable[[], str] | None = default_request_id_fn,\n        client: httpx.AsyncClient | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the TodoistAPIAsync client.\n\n        :param token: Authentication token for the Todoist API.\n        :param request_id_fn: Generator of request IDs for the `X-Request-ID` header.\n        :param client: An optional pre-configured `httpx.AsyncClient` object, to be\n            fully managed by `TodoistAPIAsync`.\n        \"\"\"\n        self._token = token\n        self._request_id_fn = request_id_fn\n        self._client = client or httpx.AsyncClient()\n\n    async def __aenter__(self) -&gt; Self:\n        \"\"\"\n        Enters the runtime context related to this object.\n\n        The with statement will bind this method's return value to the target(s)\n        specified in the as clause of the statement, if any.\n\n        :return: This TodoistAPIAsync instance.\n        \"\"\"\n        return self\n\n    async def __aexit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; None:\n        \"\"\"Exit the async runtime context and close the underlying httpx client.\"\"\"\n        await self.close()\n\n    async def close(self) -&gt; None:\n        \"\"\"Close the underlying `httpx.AsyncClient`.\"\"\"\n        await self._client.aclose()\n\n    def __del__(self) -&gt; None:\n        \"\"\"Warn when the async client was not explicitly closed.\"\"\"\n        client = getattr(self, \"_client\", None)\n        if client is None or client.is_closed:\n            return\n\n        warnings.warn(\n            \"TodoistAPIAsync client was not closed. \"\n            \"Use `async with TodoistAPIAsync(...)` or call `await api.close()`.\",\n            ResourceWarning,\n            stacklevel=2,\n        )\n\n    async def get_task(self, task_id: str) -&gt; Task:\n        \"\"\"\n        Get a specific task by its ID.\n\n        :param task_id: The ID of the task to retrieve.\n        :return: The requested task.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Task dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n        response = await get_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Task.from_dict(data)\n\n    async def get_tasks(\n        self,\n        *,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        label: str | None = None,\n        ids: list[str] | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of active tasks.\n\n        The response is an iterable of lists of active tasks matching the criteria.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: Filter tasks by project ID.\n        :param section_id: Filter tasks by section ID.\n        :param parent_id: Filter tasks by parent task ID.\n        :param label: Filter tasks by label name.\n        :param ids: A list of the IDs of the tasks to retrieve.\n        :param limit: Maximum number of tasks per page.\n        :return: An iterable of lists of tasks.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_PATH)\n\n        params = kwargs_without_none(\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            label=label,\n            ids=\",\".join(str(i) for i in ids) if ids is not None else None,\n            limit=limit,\n        )\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def filter_tasks(\n        self,\n        *,\n        query: Annotated[str, MaxLen(1024)] | None = None,\n        lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of active tasks matching the filter.\n\n        The response is an iterable of lists of active tasks matching the criteria.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query tasks using Todoist's filter language.\n        :param lang: Language for task content (e.g., 'en').\n        :param limit: Maximum number of tasks per page.\n        :return: An iterable of lists of tasks.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_FILTER_PATH)\n\n        params = kwargs_without_none(query=query, lang=lang, limit=limit)\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def add_task(\n        self,\n        content: Annotated[str, MinLen(1), MaxLen(500)],\n        *,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        labels: list[Annotated[str, MaxLen(100)]] | None = None,\n        priority: Annotated[int, Ge(1), Le(4)] | None = None,\n        due_string: Annotated[str, MaxLen(150)] | None = None,\n        due_lang: LanguageCode | None = None,\n        due_date: date | None = None,\n        due_datetime: datetime | None = None,\n        assignee_id: str | None = None,\n        order: int | None = None,\n        auto_reminder: bool | None = None,\n        auto_parse_labels: bool | None = None,\n        duration: Annotated[int, Ge(1)] | None = None,\n        duration_unit: Literal[\"minute\", \"day\"] | None = None,\n        deadline_date: date | None = None,\n        deadline_lang: LanguageCode | None = None,\n    ) -&gt; Task:\n        \"\"\"\n        Create a new task.\n\n        :param content: The text content of the task.\n        :param project_id: The ID of the project to add the task to.\n        :param section_id: The ID of the section to add the task to.\n        :param parent_id: The ID of the parent task.\n        :param labels: The task's labels (a list of names).\n        :param priority: The priority of the task (4 for very urgent).\n        :param due_string: The due date in natural language format.\n        :param due_lang: Language for parsing the due date (e.g., 'en').\n        :param due_date: The due date as a date object.\n        :param due_datetime: The due date and time as a datetime object.\n        :param assignee_id: User ID to whom the task is assigned.\n        :param description: Description for the task.\n        :param order: The order of task in the project or section.\n        :param auto_reminder: Whether to add default reminder if date with time is set.\n        :param auto_parse_labels: Whether to parse labels from task content.\n        :param duration: The amount of time the task will take.\n        :param duration_unit: The unit of time for duration.\n        :param deadline_date: The deadline date as a date object.\n        :param deadline_lang: Language for parsing the deadline date.\n        :return: The newly created task.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Task dictionary.\n        \"\"\"\n        endpoint = get_api_url(TASKS_PATH)\n\n        data = kwargs_without_none(\n            content=content,\n            description=description,\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            labels=labels,\n            priority=priority,\n            due_string=due_string,\n            due_lang=due_lang,\n            due_date=format_date(due_date) if due_date is not None else None,\n            due_datetime=(\n                format_datetime(due_datetime) if due_datetime is not None else None\n            ),\n            assignee_id=assignee_id,\n            order=order,\n            auto_reminder=auto_reminder,\n            auto_parse_labels=auto_parse_labels,\n            duration=duration,\n            duration_unit=duration_unit,\n            deadline_date=(\n                format_date(deadline_date) if deadline_date is not None else None\n            ),\n            deadline_lang=deadline_lang,\n        )\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Task.from_dict(data)\n\n    async def add_task_quick(\n        self,\n        text: str,\n        *,\n        note: str | None = None,\n        reminder: str | None = None,\n        auto_reminder: bool = True,\n    ) -&gt; Task:\n        \"\"\"\n        Create a new task using Todoist's Quick Add syntax.\n\n        This automatically parses dates, deadlines, projects, labels, priorities, etc,\n        from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").\n\n        :param text: The task text using Quick Add syntax.\n        :param note: Optional note to be added to the task.\n        :param reminder: Optional reminder date in free form text.\n        :param auto_reminder: Whether to add default reminder if date with time is set.\n        :return: A result object containing the parsed task data and metadata.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response cannot be parsed into a QuickAddResult.\n        \"\"\"\n        endpoint = get_api_url(TASKS_QUICK_ADD_PATH)\n\n        data = kwargs_without_none(\n            meta=True,\n            text=text,\n            auto_reminder=auto_reminder,\n            note=note,\n            reminder=reminder,\n        )\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Task.from_dict(data)\n\n    async def update_task(\n        self,\n        task_id: str,\n        *,\n        content: Annotated[str, MinLen(1), MaxLen(500)] | None = None,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        labels: list[Annotated[str, MaxLen(60)]] | None = None,\n        priority: Annotated[int, Ge(1), Le(4)] | None = None,\n        due_string: Annotated[str, MaxLen(150)] | None = None,\n        due_lang: LanguageCode | None = None,\n        due_date: date | None = None,\n        due_datetime: datetime | None = None,\n        assignee_id: str | None = None,\n        order: int | None = None,\n        day_order: int | None = None,\n        collapsed: bool | None = None,\n        duration: Annotated[int, Ge(1)] | None = None,\n        duration_unit: Literal[\"minute\", \"day\"] | None = None,\n        deadline_date: date | None = None,\n        deadline_lang: LanguageCode | None = None,\n    ) -&gt; Task:\n        \"\"\"\n        Update an existing task.\n\n        Only the fields to be updated need to be provided.\n\n        :param task_id: The ID of the task to update.\n        :param content: The text content of the task.\n        :param description: Description for the task.\n        :param labels: The task's labels (a list of names).\n        :param priority: The priority of the task (4 for very urgent).\n        :param due_string: The due date in natural language format.\n        :param due_lang: Language for parsing the due date (e.g., 'en').\n        :param due_date: The due date as a date object.\n        :param due_datetime: The due date and time as a datetime object.\n        :param assignee_id: User ID to whom the task is assigned.\n        :param order: The order of task in the project or section.\n        :param day_order: The order of the task inside Today or Next 7 days view.\n        :param collapsed: Whether the task's sub-tasks are collapsed.\n        :param duration: The amount of time the task will take.\n        :param duration_unit: The unit of time for duration.\n        :param deadline_date: The deadline date as a date object.\n        :param deadline_lang: Language for parsing the deadline date.\n        :return: the updated Task.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n\n        data = kwargs_without_none(\n            content=content,\n            description=description,\n            labels=labels,\n            priority=priority,\n            due_string=due_string,\n            due_lang=due_lang,\n            due_date=format_date(due_date) if due_date is not None else None,\n            due_datetime=(\n                format_datetime(due_datetime) if due_datetime is not None else None\n            ),\n            assignee_id=assignee_id,\n            order=order,\n            day_order=day_order,\n            collapsed=collapsed,\n            duration=duration,\n            duration_unit=duration_unit,\n            deadline_date=(\n                format_date(deadline_date) if deadline_date is not None else None\n            ),\n            deadline_lang=deadline_lang,\n        )\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Task.from_dict(data)\n\n    async def complete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Complete a task.\n\n        For recurring tasks, this schedules the next occurrence.\n        For non-recurring tasks, it marks them as completed.\n\n        :param task_id: The ID of the task to close.\n        :return: True if the task was closed successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/close\")\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    async def uncomplete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Uncomplete a (completed) task.\n\n        Any parent tasks or sections will also be uncompleted.\n\n        :param task_id: The ID of the task to reopen.\n        :return: True if the task was uncompleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/reopen\")\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    async def move_task(\n        self,\n        task_id: str,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n    ) -&gt; bool:\n        \"\"\"\n        Move a task to a different project, section, or parent task.\n\n        `project_id` takes predence, followed by\n        `section_id` (which also updates `project_id`),\n        and then `parent_id` (which also updates `section_id` and `project_id`).\n\n        :param task_id: The ID of the task to move.\n        :param project_id: The ID of the project to move the task to.\n        :param section_id: The ID of the section to move the task to.\n        :param parent_id: The ID of the parent to move the task to.\n        :return: True if the task was moved successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises ValueError: If neither `project_id`, `section_id`,\n                nor `parent_id` is provided.\n        \"\"\"\n        if project_id is None and section_id is None and parent_id is None:\n            raise ValueError(\n                \"Either `project_id`, `section_id`, or `parent_id` must be provided.\"\n            )\n\n        data = kwargs_without_none(\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n        )\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/move\")\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return response.is_success\n\n    async def delete_task(self, task_id: str) -&gt; bool:\n        \"\"\"\n        Delete a task.\n\n        :param task_id: The ID of the task to delete.\n        :return: True if the task was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n        response = await delete_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    async def get_completed_tasks_by_due_date(\n        self,\n        *,\n        since: datetime,\n        until: datetime,\n        workspace_id: str | None = None,\n        project_id: str | None = None,\n        section_id: str | None = None,\n        parent_id: str | None = None,\n        filter_query: str | None = None,\n        filter_lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of completed tasks within a due date range.\n\n        Retrieves tasks completed within a specific due date range (up to 6 weeks).\n        Supports filtering by workspace, project, section, parent task, or a query.\n\n        The response is an iterable of lists of completed tasks. Be aware that each\n        iteration fires off a network request to the Todoist API, and may result in\n        rate limiting or other API restrictions.\n\n        :param since: Start of the date range (inclusive).\n        :param until: End of the date range (inclusive).\n        :param workspace_id: Filter by workspace ID.\n        :param project_id: Filter by project ID.\n        :param section_id: Filter by section ID.\n        :param parent_id: Filter by parent task ID.\n        :param filter_query: Filter by a query string.\n        :param filter_lang: Language for the filter query (e.g., 'en').\n        :param limit: Maximum number of tasks per page (default 50).\n        :return: An iterable of lists of completed tasks.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_COMPLETED_BY_DUE_DATE_PATH)\n\n        params = kwargs_without_none(\n            since=format_datetime(since),\n            until=format_datetime(until),\n            workspace_id=workspace_id,\n            project_id=project_id,\n            section_id=section_id,\n            parent_id=parent_id,\n            filter_query=filter_query,\n            filter_lang=filter_lang,\n            limit=limit,\n        )\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"items\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def get_completed_tasks_by_completion_date(\n        self,\n        *,\n        since: datetime,\n        until: datetime,\n        workspace_id: str | None = None,\n        filter_query: str | None = None,\n        filter_lang: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Task]]:\n        \"\"\"\n        Get an iterable of lists of completed tasks within a date range.\n\n        Retrieves tasks completed within a specific date range (up to 3 months).\n        Supports filtering by workspace or a filter query.\n\n        The response is an iterable of lists of completed tasks. Be aware that each\n        iteration fires off a network request to the Todoist API, and may result in\n        rate limiting or other API restrictions.\n\n        :param since: Start of the date range (inclusive).\n        :param until: End of the date range (inclusive).\n        :param workspace_id: Filter by workspace ID.\n        :param filter_query: Filter by a query string.\n        :param filter_lang: Language for the filter query (e.g., 'en').\n        :param limit: Maximum number of tasks per page (default 50).\n        :return: An iterable of lists of completed tasks.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(TASKS_COMPLETED_BY_COMPLETION_DATE_PATH)\n\n        params = kwargs_without_none(\n            since=format_datetime(since),\n            until=format_datetime(until),\n            workspace_id=workspace_id,\n            filter_query=filter_query,\n            filter_lang=filter_lang,\n            limit=limit,\n        )\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"items\",\n            Task.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def get_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Get a project by its ID.\n\n        :param project_id: The ID of the project to retrieve.\n        :return: The requested project.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n        response = await get_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    async def get_projects(\n        self,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Project]]:\n        \"\"\"\n        Get an iterable of lists of active projects.\n\n        The response is an iterable of lists of active projects.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param limit: Maximum number of projects per page.\n        :return: An iterable of lists of projects.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(PROJECTS_PATH)\n        params = kwargs_without_none(limit=limit)\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Project.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def search_projects(\n        self,\n        query: Annotated[str, MinLen(1), MaxLen(1024)],\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Project]]:\n        \"\"\"\n        Search active projects by name.\n\n        The response is an iterable of lists of projects matching the query.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query string for project names.\n        :param limit: Maximum number of projects per page.\n        :return: An iterable of lists of projects.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{PROJECTS_SEARCH_PATH_SUFFIX}\")\n\n        params = kwargs_without_none(query=query, limit=limit)\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Project.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def add_project(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(120)],\n        *,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        parent_id: str | None = None,\n        color: ColorString | None = None,\n        is_favorite: bool | None = None,\n        view_style: ViewStyle | None = None,\n    ) -&gt; Project:\n        \"\"\"\n        Create a new project.\n\n        :param name: The name of the project.\n        :param description: Description for the project (up to 1024 characters).\n        :param parent_id: The ID of the parent project. Set to null for root projects.\n        :param color: The color of the project icon.\n        :param is_favorite: Whether the project is a favorite.\n        :param view_style: A string value (either 'list' or 'board', default is 'list').\n        :return: The newly created project.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(PROJECTS_PATH)\n\n        data = kwargs_without_none(\n            name=name,\n            parent_id=parent_id,\n            description=description,\n            color=color,\n            is_favorite=is_favorite,\n            view_style=view_style,\n        )\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    async def update_project(\n        self,\n        project_id: str,\n        *,\n        name: Annotated[str, MinLen(1), MaxLen(120)] | None = None,\n        description: Annotated[str, MaxLen(16383)] | None = None,\n        color: ColorString | None = None,\n        is_favorite: bool | None = None,\n        view_style: ViewStyle | None = None,\n    ) -&gt; Project:\n        \"\"\"\n        Update an existing project.\n\n        Only the fields to be updated need to be provided as keyword arguments.\n\n        :param project_id: The ID of the project to update.\n        :param name: The name of the project.\n        :param description: Description for the project (up to 1024 characters).\n        :param color: The color of the project icon.\n        :param is_favorite: Whether the project is a favorite.\n        :param view_style: A string value (either 'list' or 'board').\n        :return: the updated Project.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n\n        data = kwargs_without_none(\n            name=name,\n            description=description,\n            color=color,\n            is_favorite=is_favorite,\n            view_style=view_style,\n        )\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    async def archive_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Archive a project.\n\n        For personal projects, archives it only for the user.\n        For workspace projects, archives it for all members.\n\n        :param project_id: The ID of the project to archive.\n        :return: The archived project object.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(\n            f\"{PROJECTS_PATH}/{project_id}/{PROJECT_ARCHIVE_PATH_SUFFIX}\"\n        )\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    async def unarchive_project(self, project_id: str) -&gt; Project:\n        \"\"\"\n        Unarchive a project.\n\n        Restores a previously archived project.\n\n        :param project_id: The ID of the project to unarchive.\n        :return: The unarchived project object.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Project dictionary.\n        \"\"\"\n        endpoint = get_api_url(\n            f\"{PROJECTS_PATH}/{project_id}/{PROJECT_UNARCHIVE_PATH_SUFFIX}\"\n        )\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Project.from_dict(data)\n\n    async def delete_project(self, project_id: str) -&gt; bool:\n        \"\"\"\n        Delete a project.\n\n        All nested sections and tasks will also be deleted.\n\n        :param project_id: The ID of the project to delete.\n        :return: True if the project was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n        response = await delete_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    async def get_collaborators(\n        self,\n        project_id: str,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Collaborator]]:\n        \"\"\"\n        Get an iterable of lists of collaborators in shared projects.\n\n        The response is an iterable of lists of collaborators in shared projects,\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: The ID of the project.\n        :param limit: Maximum number of collaborators per page.\n        :return: An iterable of lists of collaborators.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}/{COLLABORATORS_PATH}\")\n        params = kwargs_without_none(limit=limit)\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Collaborator.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def get_section(self, section_id: str) -&gt; Section:\n        \"\"\"\n        Get a specific section by its ID.\n\n        :param section_id: The ID of the section to retrieve.\n        :return: The requested section.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Section dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        response = await get_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Section.from_dict(data)\n\n    async def get_sections(\n        self,\n        project_id: str | None = None,\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Section]]:\n        \"\"\"\n        Get an iterable of lists of active sections.\n\n        Supports filtering by `project_id` and pagination arguments.\n\n        The response is an iterable of lists of active sections.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: Filter sections by project ID.\n        :param limit: Maximum number of sections per page.\n        :return: An iterable of lists of sections.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(SECTIONS_PATH)\n\n        params = kwargs_without_none(project_id=project_id, limit=limit)\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Section.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def search_sections(\n        self,\n        query: Annotated[str, MinLen(1), MaxLen(1024)],\n        *,\n        project_id: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Section]]:\n        \"\"\"\n        Search active sections by name.\n\n        The response is an iterable of lists of sections matching the query.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query string for section names.\n        :param project_id: If set, search sections within the given project only.\n        :param limit: Maximum number of sections per page.\n        :return: An iterable of lists of sections.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{SECTIONS_SEARCH_PATH_SUFFIX}\")\n\n        params = kwargs_without_none(query=query, project_id=project_id, limit=limit)\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Section.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def add_section(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(2048)],\n        project_id: str,\n        *,\n        order: int | None = None,\n    ) -&gt; Section:\n        \"\"\"\n        Create a new section within a project.\n\n        :param name: The name of the section.\n        :param project_id: The ID of the project to add the section to.\n        :param order: The order of the section among all sections in the project.\n        :return: The newly created section.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Section dictionary.\n        \"\"\"\n        endpoint = get_api_url(SECTIONS_PATH)\n\n        data = kwargs_without_none(name=name, project_id=project_id, order=order)\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Section.from_dict(data)\n\n    async def update_section(\n        self,\n        section_id: str,\n        name: Annotated[str, MinLen(1), MaxLen(2048)],\n    ) -&gt; Section:\n        \"\"\"\n        Update an existing section.\n\n        Currently, only `name` can be updated.\n\n        :param section_id: The ID of the section to update.\n        :param name: The new name for the section.\n        :return: the updated Section.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data={\"name\": name},\n        )\n        data = response_json_dict(response)\n        return Section.from_dict(data)\n\n    async def delete_section(self, section_id: str) -&gt; bool:\n        \"\"\"\n        Delete a section.\n\n        All tasks within the section will also be deleted.\n\n        :param section_id: The ID of the section to delete.\n        :return: True if the section was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n        response = await delete_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    async def get_comment(self, comment_id: str) -&gt; Comment:\n        \"\"\"\n        Get a specific comment by its ID.\n\n        :param comment_id: The ID of the comment to retrieve.\n        :return: The requested comment.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Comment dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        response = await get_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Comment.from_dict(data)\n\n    async def get_comments(\n        self,\n        *,\n        project_id: str | None = None,\n        task_id: str | None = None,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Comment]]:\n        \"\"\"\n        Get an iterable of lists of comments for a task or project.\n\n        Requires either `project_id` or `task_id` to be set.\n\n        The response is an iterable of lists of comments.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param project_id: The ID of the project to retrieve comments for.\n        :param task_id: The ID of the task to retrieve comments for.\n        :param limit: Maximum number of comments per page.\n        :return: An iterable of lists of comments.\n        :raises ValueError: If neither `project_id` nor `task_id` is provided.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        if project_id is None and task_id is None:\n            raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n        endpoint = get_api_url(COMMENTS_PATH)\n\n        params = kwargs_without_none(\n            project_id=project_id,\n            task_id=task_id,\n            limit=limit,\n        )\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Comment.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def add_comment(\n        self,\n        content: Annotated[str, MaxLen(15000)],\n        *,\n        project_id: str | None = None,\n        task_id: str | None = None,\n        attachment: Attachment | None = None,\n        uids_to_notify: list[str] | None = None,\n    ) -&gt; Comment:\n        \"\"\"\n        Create a new comment on a task or project.\n\n        Requires either `project_id` or `task_id` to be set,\n        and can optionally include an `attachment` object.\n\n        :param content: The text content of the comment (supports Markdown).\n        :param project_id: The ID of the project to add the comment to.\n        :param task_id: The ID of the task to add the comment to.\n        :param attachment: The attachment object to include with the comment.\n        :param uids_to_notify: A list of user IDs to notify.\n        :return: The newly created comment.\n        :raises ValueError: If neither `project_id` nor `task_id` is provided.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Comment dictionary.\n        \"\"\"\n        if project_id is None and task_id is None:\n            raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n        endpoint = get_api_url(COMMENTS_PATH)\n\n        data = kwargs_without_none(\n            content=content,\n            project_id=project_id,\n            task_id=task_id,\n            attachment=attachment.to_dict() if attachment is not None else None,\n            uids_to_notify=uids_to_notify,\n        )\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Comment.from_dict(data)\n\n    async def update_comment(\n        self, comment_id: str, content: Annotated[str, MaxLen(15000)]\n    ) -&gt; Comment:\n        \"\"\"\n        Update an existing comment.\n\n        Currently, only `content` can be updated.\n\n        :param comment_id: The ID of the comment to update.\n        :param content: The new text content for the comment.\n        :return: the updated Comment.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data={\"content\": content},\n        )\n        data = response_json_dict(response)\n        return Comment.from_dict(data)\n\n    async def delete_comment(self, comment_id: str) -&gt; bool:\n        \"\"\"\n        Delete a comment.\n\n        :param comment_id: The ID of the comment to delete.\n        :return: True if the comment was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n        response = await delete_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    async def get_label(self, label_id: str) -&gt; Label:\n        \"\"\"\n        Get a specific personal label by its ID.\n\n        :param label_id: The ID of the label to retrieve.\n        :return: The requested label.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Label dictionary.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n        response = await get_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        data = response_json_dict(response)\n        return Label.from_dict(data)\n\n    async def get_labels(\n        self,\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Label]]:\n        \"\"\"\n        Get an iterable of lists of personal labels.\n\n        Supports pagination arguments.\n\n        The response is an iterable of lists of personal labels.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param limit: Maximum number of labels per page.\n        :return: An iterable of lists of personal labels.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(LABELS_PATH)\n\n        params = kwargs_without_none(limit=limit)\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Label.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def search_labels(\n        self,\n        query: Annotated[str, MinLen(1), MaxLen(1024)],\n        *,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[Label]]:\n        \"\"\"\n        Search personal labels by name.\n\n        The response is an iterable of lists of labels matching the query.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param query: Query string for label names.\n        :param limit: Maximum number of labels per page.\n        :return: An iterable of lists of labels.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{LABELS_SEARCH_PATH_SUFFIX}\")\n\n        params = kwargs_without_none(query=query, limit=limit)\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            Label.from_dict,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def add_label(\n        self,\n        name: Annotated[str, MinLen(1), MaxLen(60)],\n        *,\n        color: ColorString | None = None,\n        item_order: int | None = None,\n        is_favorite: bool | None = None,\n    ) -&gt; Label:\n        \"\"\"\n        Create a new personal label.\n\n        :param name: The name of the label.\n        :param color: The color of the label icon.\n        :param item_order: Label's order in the label list.\n        :param is_favorite: Whether the label is a favorite.\n        :return: The newly created label.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response is not a valid Label dictionary.\n        \"\"\"\n        endpoint = get_api_url(LABELS_PATH)\n\n        data = kwargs_without_none(\n            name=name,\n            color=color,\n            item_order=item_order,\n            is_favorite=is_favorite,\n        )\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Label.from_dict(data)\n\n    async def update_label(\n        self,\n        label_id: str,\n        *,\n        name: Annotated[str, MinLen(1), MaxLen(60)] | None = None,\n        color: ColorString | None = None,\n        item_order: int | None = None,\n        is_favorite: bool | None = None,\n    ) -&gt; Label:\n        \"\"\"\n        Update a personal label.\n\n        Only the fields to be updated need to be provided as keyword arguments.\n\n        :param label_id: The ID of the label.\n        :param name: The name of the label.\n        :param color: The color of the label icon.\n        :param item_order: Label's order in the label list.\n        :param is_favorite: Whether the label is a favorite.\n        :return: the updated Label.\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n\n        data = kwargs_without_none(\n            name=name,\n            color=color,\n            item_order=item_order,\n            is_favorite=is_favorite,\n        )\n\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        data = response_json_dict(response)\n        return Label.from_dict(data)\n\n    async def delete_label(self, label_id: str) -&gt; bool:\n        \"\"\"\n        Delete a personal label.\n\n        Instances of the label will be removed from tasks.\n\n        :param label_id: The ID of the label to delete.\n        :return: True if the label was deleted successfully,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n        response = await delete_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n        )\n        return response.is_success\n\n    async def get_shared_labels(\n        self,\n        *,\n        omit_personal: bool = False,\n        limit: Annotated[int, Ge(1), Le(200)] | None = None,\n    ) -&gt; AsyncIterator[list[str]]:\n        \"\"\"\n        Get an iterable of lists of shared label names.\n\n        Includes labels from collaborators on shared projects that are not in the\n        user's personal labels. Can optionally exclude personal label names using\n        `omit_personal=True`. Supports pagination arguments.\n\n        The response is an iterable of lists of shared label names.\n        Be aware that each iteration fires off a network request to the Todoist API,\n        and may result in rate limiting or other API restrictions.\n\n        :param omit_personal: Optional boolean flag to omit personal label names.\n        :param limit: Maximum number of labels per page.\n        :return: An iterable of lists of shared label names (strings).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        :raises TypeError: If the API response structure is unexpected.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_PATH)\n\n        params = kwargs_without_none(omit_personal=omit_personal, limit=limit)\n\n        return AsyncResultsPaginator(\n            self._client,\n            endpoint,\n            \"results\",\n            str,\n            self._token,\n            self._request_id_fn,\n            params,\n        )\n\n    async def rename_shared_label(\n        self,\n        name: Annotated[str, MaxLen(60)],\n        new_name: Annotated[str, MinLen(1), MaxLen(60)],\n    ) -&gt; bool:\n        \"\"\"\n        Rename all occurrences of a shared label across all projects.\n\n        :param name: The current name of the shared label to rename.\n        :param new_name: The new name for the shared label.\n        :return: True if the rename was successful,\n                 False otherwise (possibly raise `HTTPError` instead).\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_RENAME_PATH)\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            params={\"name\": name},\n            data={\"new_name\": new_name},\n        )\n        return response.is_success\n\n    async def remove_shared_label(self, name: Annotated[str, MaxLen(60)]) -&gt; bool:\n        \"\"\"\n        Remove all occurrences of a shared label across all projects.\n\n        This action removes the label string from all tasks where it appears.\n\n        :param name: The name of the shared label to remove.\n        :return: True if the removal was successful,\n        :raises httpx.HTTPStatusError: If the API request fails.\n        \"\"\"\n        endpoint = get_api_url(SHARED_LABELS_REMOVE_PATH)\n        data = {\"name\": name}\n        response = await post_async(\n            self._client,\n            endpoint,\n            self._token,\n            self._request_id_fn() if self._request_id_fn else None,\n            data=data,\n        )\n        return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_comment","title":"<code>add_comment(content, *, project_id=None, task_id=None, attachment=None, uids_to_notify=None)</code>  <code>async</code>","text":"<p>Create a new comment on a task or project.</p> <p>Requires either <code>project_id</code> or <code>task_id</code> to be set, and can optionally include an <code>attachment</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text content of the comment (supports Markdown).</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to add the comment to.</p> <code>None</code> <code>task_id</code> <code>str | None</code> <p>The ID of the task to add the comment to.</p> <code>None</code> <code>attachment</code> <code>Attachment | None</code> <p>The attachment object to include with the comment.</p> <code>None</code> <code>uids_to_notify</code> <code>list[str] | None</code> <p>A list of user IDs to notify.</p> <code>None</code> <p>Returns:</p> Type Description <code>Comment</code> <p>The newly created comment.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>project_id</code> nor <code>task_id</code> is provided.</p> <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Comment dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_comment(\n    self,\n    content: Annotated[str, MaxLen(15000)],\n    *,\n    project_id: str | None = None,\n    task_id: str | None = None,\n    attachment: Attachment | None = None,\n    uids_to_notify: list[str] | None = None,\n) -&gt; Comment:\n    \"\"\"\n    Create a new comment on a task or project.\n\n    Requires either `project_id` or `task_id` to be set,\n    and can optionally include an `attachment` object.\n\n    :param content: The text content of the comment (supports Markdown).\n    :param project_id: The ID of the project to add the comment to.\n    :param task_id: The ID of the task to add the comment to.\n    :param attachment: The attachment object to include with the comment.\n    :param uids_to_notify: A list of user IDs to notify.\n    :return: The newly created comment.\n    :raises ValueError: If neither `project_id` nor `task_id` is provided.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Comment dictionary.\n    \"\"\"\n    if project_id is None and task_id is None:\n        raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n    endpoint = get_api_url(COMMENTS_PATH)\n\n    data = kwargs_without_none(\n        content=content,\n        project_id=project_id,\n        task_id=task_id,\n        attachment=attachment.to_dict() if attachment is not None else None,\n        uids_to_notify=uids_to_notify,\n    )\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Comment.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_label","title":"<code>add_label(name, *, color=None, item_order=None, is_favorite=None)</code>  <code>async</code>","text":"<p>Create a new personal label.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the label.</p> required <code>color</code> <code>ColorString | None</code> <p>The color of the label icon.</p> <code>None</code> <code>item_order</code> <code>int | None</code> <p>Label's order in the label list.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the label is a favorite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>The newly created label.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Label dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_label(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(60)],\n    *,\n    color: ColorString | None = None,\n    item_order: int | None = None,\n    is_favorite: bool | None = None,\n) -&gt; Label:\n    \"\"\"\n    Create a new personal label.\n\n    :param name: The name of the label.\n    :param color: The color of the label icon.\n    :param item_order: Label's order in the label list.\n    :param is_favorite: Whether the label is a favorite.\n    :return: The newly created label.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Label dictionary.\n    \"\"\"\n    endpoint = get_api_url(LABELS_PATH)\n\n    data = kwargs_without_none(\n        name=name,\n        color=color,\n        item_order=item_order,\n        is_favorite=is_favorite,\n    )\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Label.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_project","title":"<code>add_project(name, *, description=None, parent_id=None, color=None, is_favorite=None, view_style=None)</code>  <code>async</code>","text":"<p>Create a new project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the project.</p> required <code>description</code> <code>str | None</code> <p>Description for the project (up to 1024 characters).</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent project. Set to null for root projects.</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the project icon.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the project is a favorite.</p> <code>None</code> <code>view_style</code> <code>ViewStyle | None</code> <p>A string value (either 'list' or 'board', default is 'list').</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>The newly created project.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_project(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(120)],\n    *,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    parent_id: str | None = None,\n    color: ColorString | None = None,\n    is_favorite: bool | None = None,\n    view_style: ViewStyle | None = None,\n) -&gt; Project:\n    \"\"\"\n    Create a new project.\n\n    :param name: The name of the project.\n    :param description: Description for the project (up to 1024 characters).\n    :param parent_id: The ID of the parent project. Set to null for root projects.\n    :param color: The color of the project icon.\n    :param is_favorite: Whether the project is a favorite.\n    :param view_style: A string value (either 'list' or 'board', default is 'list').\n    :return: The newly created project.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(PROJECTS_PATH)\n\n    data = kwargs_without_none(\n        name=name,\n        parent_id=parent_id,\n        description=description,\n        color=color,\n        is_favorite=is_favorite,\n        view_style=view_style,\n    )\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_section","title":"<code>add_section(name, project_id, *, order=None)</code>  <code>async</code>","text":"<p>Create a new section within a project.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the section.</p> required <code>project_id</code> <code>str</code> <p>The ID of the project to add the section to.</p> required <code>order</code> <code>int | None</code> <p>The order of the section among all sections in the project.</p> <code>None</code> <p>Returns:</p> Type Description <code>Section</code> <p>The newly created section.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Section dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_section(\n    self,\n    name: Annotated[str, MinLen(1), MaxLen(2048)],\n    project_id: str,\n    *,\n    order: int | None = None,\n) -&gt; Section:\n    \"\"\"\n    Create a new section within a project.\n\n    :param name: The name of the section.\n    :param project_id: The ID of the project to add the section to.\n    :param order: The order of the section among all sections in the project.\n    :return: The newly created section.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Section dictionary.\n    \"\"\"\n    endpoint = get_api_url(SECTIONS_PATH)\n\n    data = kwargs_without_none(name=name, project_id=project_id, order=order)\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Section.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_task","title":"<code>add_task(content, *, description=None, project_id=None, section_id=None, parent_id=None, labels=None, priority=None, due_string=None, due_lang=None, due_date=None, due_datetime=None, assignee_id=None, order=None, auto_reminder=None, auto_parse_labels=None, duration=None, duration_unit=None, deadline_date=None, deadline_lang=None)</code>  <code>async</code>","text":"<p>Create a new task.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The text content of the task.</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to add the task to.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>The ID of the section to add the task to.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent task.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>The task's labels (a list of names).</p> <code>None</code> <code>priority</code> <code>int | None</code> <p>The priority of the task (4 for very urgent).</p> <code>None</code> <code>due_string</code> <code>str | None</code> <p>The due date in natural language format.</p> <code>None</code> <code>due_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the due date (e.g., 'en').</p> <code>None</code> <code>due_date</code> <code>date | None</code> <p>The due date as a date object.</p> <code>None</code> <code>due_datetime</code> <code>datetime | None</code> <p>The due date and time as a datetime object.</p> <code>None</code> <code>assignee_id</code> <code>str | None</code> <p>User ID to whom the task is assigned.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the task.</p> <code>None</code> <code>order</code> <code>int | None</code> <p>The order of task in the project or section.</p> <code>None</code> <code>auto_reminder</code> <code>bool | None</code> <p>Whether to add default reminder if date with time is set.</p> <code>None</code> <code>auto_parse_labels</code> <code>bool | None</code> <p>Whether to parse labels from task content.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>The amount of time the task will take.</p> <code>None</code> <code>duration_unit</code> <code>Literal['minute', 'day'] | None</code> <p>The unit of time for duration.</p> <code>None</code> <code>deadline_date</code> <code>date | None</code> <p>The deadline date as a date object.</p> <code>None</code> <code>deadline_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the deadline date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Task</code> <p>The newly created task.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Task dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_task(\n    self,\n    content: Annotated[str, MinLen(1), MaxLen(500)],\n    *,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    labels: list[Annotated[str, MaxLen(100)]] | None = None,\n    priority: Annotated[int, Ge(1), Le(4)] | None = None,\n    due_string: Annotated[str, MaxLen(150)] | None = None,\n    due_lang: LanguageCode | None = None,\n    due_date: date | None = None,\n    due_datetime: datetime | None = None,\n    assignee_id: str | None = None,\n    order: int | None = None,\n    auto_reminder: bool | None = None,\n    auto_parse_labels: bool | None = None,\n    duration: Annotated[int, Ge(1)] | None = None,\n    duration_unit: Literal[\"minute\", \"day\"] | None = None,\n    deadline_date: date | None = None,\n    deadline_lang: LanguageCode | None = None,\n) -&gt; Task:\n    \"\"\"\n    Create a new task.\n\n    :param content: The text content of the task.\n    :param project_id: The ID of the project to add the task to.\n    :param section_id: The ID of the section to add the task to.\n    :param parent_id: The ID of the parent task.\n    :param labels: The task's labels (a list of names).\n    :param priority: The priority of the task (4 for very urgent).\n    :param due_string: The due date in natural language format.\n    :param due_lang: Language for parsing the due date (e.g., 'en').\n    :param due_date: The due date as a date object.\n    :param due_datetime: The due date and time as a datetime object.\n    :param assignee_id: User ID to whom the task is assigned.\n    :param description: Description for the task.\n    :param order: The order of task in the project or section.\n    :param auto_reminder: Whether to add default reminder if date with time is set.\n    :param auto_parse_labels: Whether to parse labels from task content.\n    :param duration: The amount of time the task will take.\n    :param duration_unit: The unit of time for duration.\n    :param deadline_date: The deadline date as a date object.\n    :param deadline_lang: Language for parsing the deadline date.\n    :return: The newly created task.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Task dictionary.\n    \"\"\"\n    endpoint = get_api_url(TASKS_PATH)\n\n    data = kwargs_without_none(\n        content=content,\n        description=description,\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n        labels=labels,\n        priority=priority,\n        due_string=due_string,\n        due_lang=due_lang,\n        due_date=format_date(due_date) if due_date is not None else None,\n        due_datetime=(\n            format_datetime(due_datetime) if due_datetime is not None else None\n        ),\n        assignee_id=assignee_id,\n        order=order,\n        auto_reminder=auto_reminder,\n        auto_parse_labels=auto_parse_labels,\n        duration=duration,\n        duration_unit=duration_unit,\n        deadline_date=(\n            format_date(deadline_date) if deadline_date is not None else None\n        ),\n        deadline_lang=deadline_lang,\n    )\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Task.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.add_task_quick","title":"<code>add_task_quick(text, *, note=None, reminder=None, auto_reminder=True)</code>  <code>async</code>","text":"<p>Create a new task using Todoist's Quick Add syntax.</p> <p>This automatically parses dates, deadlines, projects, labels, priorities, etc, from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The task text using Quick Add syntax.</p> required <code>note</code> <code>str | None</code> <p>Optional note to be added to the task.</p> <code>None</code> <code>reminder</code> <code>str | None</code> <p>Optional reminder date in free form text.</p> <code>None</code> <code>auto_reminder</code> <code>bool</code> <p>Whether to add default reminder if date with time is set.</p> <code>True</code> <p>Returns:</p> Type Description <code>Task</code> <p>A result object containing the parsed task data and metadata.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response cannot be parsed into a QuickAddResult.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def add_task_quick(\n    self,\n    text: str,\n    *,\n    note: str | None = None,\n    reminder: str | None = None,\n    auto_reminder: bool = True,\n) -&gt; Task:\n    \"\"\"\n    Create a new task using Todoist's Quick Add syntax.\n\n    This automatically parses dates, deadlines, projects, labels, priorities, etc,\n    from the provided text (e.g., \"Buy milk #Shopping @groceries tomorrow p1\").\n\n    :param text: The task text using Quick Add syntax.\n    :param note: Optional note to be added to the task.\n    :param reminder: Optional reminder date in free form text.\n    :param auto_reminder: Whether to add default reminder if date with time is set.\n    :return: A result object containing the parsed task data and metadata.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response cannot be parsed into a QuickAddResult.\n    \"\"\"\n    endpoint = get_api_url(TASKS_QUICK_ADD_PATH)\n\n    data = kwargs_without_none(\n        meta=True,\n        text=text,\n        auto_reminder=auto_reminder,\n        note=note,\n        reminder=reminder,\n    )\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Task.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.archive_project","title":"<code>archive_project(project_id)</code>  <code>async</code>","text":"<p>Archive a project.</p> <p>For personal projects, archives it only for the user. For workspace projects, archives it for all members.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to archive.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The archived project object.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def archive_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Archive a project.\n\n    For personal projects, archives it only for the user.\n    For workspace projects, archives it for all members.\n\n    :param project_id: The ID of the project to archive.\n    :return: The archived project object.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(\n        f\"{PROJECTS_PATH}/{project_id}/{PROJECT_ARCHIVE_PATH_SUFFIX}\"\n    )\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the underlying <code>httpx.AsyncClient</code>.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the underlying `httpx.AsyncClient`.\"\"\"\n    await self._client.aclose()\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.complete_task","title":"<code>complete_task(task_id)</code>  <code>async</code>","text":"<p>Complete a task.</p> <p>For recurring tasks, this schedules the next occurrence. For non-recurring tasks, it marks them as completed.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to close.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was closed successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def complete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Complete a task.\n\n    For recurring tasks, this schedules the next occurrence.\n    For non-recurring tasks, it marks them as completed.\n\n    :param task_id: The ID of the task to close.\n    :return: True if the task was closed successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/close\")\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_comment","title":"<code>delete_comment(comment_id)</code>  <code>async</code>","text":"<p>Delete a comment.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the comment was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_comment(self, comment_id: str) -&gt; bool:\n    \"\"\"\n    Delete a comment.\n\n    :param comment_id: The ID of the comment to delete.\n    :return: True if the comment was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    response = await delete_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_label","title":"<code>delete_label(label_id)</code>  <code>async</code>","text":"<p>Delete a personal label.</p> <p>Instances of the label will be removed from tasks.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the label was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_label(self, label_id: str) -&gt; bool:\n    \"\"\"\n    Delete a personal label.\n\n    Instances of the label will be removed from tasks.\n\n    :param label_id: The ID of the label to delete.\n    :return: True if the label was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n    response = await delete_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_project","title":"<code>delete_project(project_id)</code>  <code>async</code>","text":"<p>Delete a project.</p> <p>All nested sections and tasks will also be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the project was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_project(self, project_id: str) -&gt; bool:\n    \"\"\"\n    Delete a project.\n\n    All nested sections and tasks will also be deleted.\n\n    :param project_id: The ID of the project to delete.\n    :return: True if the project was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n    response = await delete_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_section","title":"<code>delete_section(section_id)</code>  <code>async</code>","text":"<p>Delete a section.</p> <p>All tasks within the section will also be deleted.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the section was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_section(self, section_id: str) -&gt; bool:\n    \"\"\"\n    Delete a section.\n\n    All tasks within the section will also be deleted.\n\n    :param section_id: The ID of the section to delete.\n    :return: True if the section was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    response = await delete_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.delete_task","title":"<code>delete_task(task_id)</code>  <code>async</code>","text":"<p>Delete a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was deleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def delete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Delete a task.\n\n    :param task_id: The ID of the task to delete.\n    :return: True if the task was deleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n    response = await delete_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.filter_tasks","title":"<code>filter_tasks(*, query=None, lang=None, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of active tasks matching the filter.</p> <p>The response is an iterable of lists of active tasks matching the criteria. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str | None</code> <p>Query tasks using Todoist's filter language.</p> <code>None</code> <code>lang</code> <code>str | None</code> <p>Language for task content (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Task]]</code> <p>An iterable of lists of tasks.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def filter_tasks(\n    self,\n    *,\n    query: Annotated[str, MaxLen(1024)] | None = None,\n    lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of active tasks matching the filter.\n\n    The response is an iterable of lists of active tasks matching the criteria.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query tasks using Todoist's filter language.\n    :param lang: Language for task content (e.g., 'en').\n    :param limit: Maximum number of tasks per page.\n    :return: An iterable of lists of tasks.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_FILTER_PATH)\n\n    params = kwargs_without_none(query=query, lang=lang, limit=limit)\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_collaborators","title":"<code>get_collaborators(project_id, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of collaborators in shared projects.</p> <p>The response is an iterable of lists of collaborators in shared projects, Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project.</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of collaborators per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Collaborator]]</code> <p>An iterable of lists of collaborators.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_collaborators(\n    self,\n    project_id: str,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Collaborator]]:\n    \"\"\"\n    Get an iterable of lists of collaborators in shared projects.\n\n    The response is an iterable of lists of collaborators in shared projects,\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: The ID of the project.\n    :param limit: Maximum number of collaborators per page.\n    :return: An iterable of lists of collaborators.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}/{COLLABORATORS_PATH}\")\n    params = kwargs_without_none(limit=limit)\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Collaborator.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_comment","title":"<code>get_comment(comment_id)</code>  <code>async</code>","text":"<p>Get a specific comment by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to retrieve.</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>The requested comment.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Comment dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_comment(self, comment_id: str) -&gt; Comment:\n    \"\"\"\n    Get a specific comment by its ID.\n\n    :param comment_id: The ID of the comment to retrieve.\n    :return: The requested comment.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Comment dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    response = await get_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Comment.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_comments","title":"<code>get_comments(*, project_id=None, task_id=None, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of comments for a task or project.</p> <p>Requires either <code>project_id</code> or <code>task_id</code> to be set.</p> <p>The response is an iterable of lists of comments. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>The ID of the project to retrieve comments for.</p> <code>None</code> <code>task_id</code> <code>str | None</code> <p>The ID of the task to retrieve comments for.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of comments per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Comment]]</code> <p>An iterable of lists of comments.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither <code>project_id</code> nor <code>task_id</code> is provided.</p> <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_comments(\n    self,\n    *,\n    project_id: str | None = None,\n    task_id: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Comment]]:\n    \"\"\"\n    Get an iterable of lists of comments for a task or project.\n\n    Requires either `project_id` or `task_id` to be set.\n\n    The response is an iterable of lists of comments.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: The ID of the project to retrieve comments for.\n    :param task_id: The ID of the task to retrieve comments for.\n    :param limit: Maximum number of comments per page.\n    :return: An iterable of lists of comments.\n    :raises ValueError: If neither `project_id` nor `task_id` is provided.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    if project_id is None and task_id is None:\n        raise ValueError(\"Either `project_id` or `task_id` must be provided.\")\n\n    endpoint = get_api_url(COMMENTS_PATH)\n\n    params = kwargs_without_none(\n        project_id=project_id,\n        task_id=task_id,\n        limit=limit,\n    )\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Comment.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_completed_tasks_by_completion_date","title":"<code>get_completed_tasks_by_completion_date(*, since, until, workspace_id=None, filter_query=None, filter_lang=None, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of completed tasks within a date range.</p> <p>Retrieves tasks completed within a specific date range (up to 3 months). Supports filtering by workspace or a filter query.</p> <p>The response is an iterable of lists of completed tasks. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>datetime</code> <p>Start of the date range (inclusive).</p> required <code>until</code> <code>datetime</code> <p>End of the date range (inclusive).</p> required <code>workspace_id</code> <code>str | None</code> <p>Filter by workspace ID.</p> <code>None</code> <code>filter_query</code> <code>str | None</code> <p>Filter by a query string.</p> <code>None</code> <code>filter_lang</code> <code>str | None</code> <p>Language for the filter query (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (default 50).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Task]]</code> <p>An iterable of lists of completed tasks.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_completed_tasks_by_completion_date(\n    self,\n    *,\n    since: datetime,\n    until: datetime,\n    workspace_id: str | None = None,\n    filter_query: str | None = None,\n    filter_lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of completed tasks within a date range.\n\n    Retrieves tasks completed within a specific date range (up to 3 months).\n    Supports filtering by workspace or a filter query.\n\n    The response is an iterable of lists of completed tasks. Be aware that each\n    iteration fires off a network request to the Todoist API, and may result in\n    rate limiting or other API restrictions.\n\n    :param since: Start of the date range (inclusive).\n    :param until: End of the date range (inclusive).\n    :param workspace_id: Filter by workspace ID.\n    :param filter_query: Filter by a query string.\n    :param filter_lang: Language for the filter query (e.g., 'en').\n    :param limit: Maximum number of tasks per page (default 50).\n    :return: An iterable of lists of completed tasks.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_COMPLETED_BY_COMPLETION_DATE_PATH)\n\n    params = kwargs_without_none(\n        since=format_datetime(since),\n        until=format_datetime(until),\n        workspace_id=workspace_id,\n        filter_query=filter_query,\n        filter_lang=filter_lang,\n        limit=limit,\n    )\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"items\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_completed_tasks_by_due_date","title":"<code>get_completed_tasks_by_due_date(*, since, until, workspace_id=None, project_id=None, section_id=None, parent_id=None, filter_query=None, filter_lang=None, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of completed tasks within a due date range.</p> <p>Retrieves tasks completed within a specific due date range (up to 6 weeks). Supports filtering by workspace, project, section, parent task, or a query.</p> <p>The response is an iterable of lists of completed tasks. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>datetime</code> <p>Start of the date range (inclusive).</p> required <code>until</code> <code>datetime</code> <p>End of the date range (inclusive).</p> required <code>workspace_id</code> <code>str | None</code> <p>Filter by workspace ID.</p> <code>None</code> <code>project_id</code> <code>str | None</code> <p>Filter by project ID.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>Filter by section ID.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter by parent task ID.</p> <code>None</code> <code>filter_query</code> <code>str | None</code> <p>Filter by a query string.</p> <code>None</code> <code>filter_lang</code> <code>str | None</code> <p>Language for the filter query (e.g., 'en').</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page (default 50).</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Task]]</code> <p>An iterable of lists of completed tasks.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_completed_tasks_by_due_date(\n    self,\n    *,\n    since: datetime,\n    until: datetime,\n    workspace_id: str | None = None,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    filter_query: str | None = None,\n    filter_lang: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of completed tasks within a due date range.\n\n    Retrieves tasks completed within a specific due date range (up to 6 weeks).\n    Supports filtering by workspace, project, section, parent task, or a query.\n\n    The response is an iterable of lists of completed tasks. Be aware that each\n    iteration fires off a network request to the Todoist API, and may result in\n    rate limiting or other API restrictions.\n\n    :param since: Start of the date range (inclusive).\n    :param until: End of the date range (inclusive).\n    :param workspace_id: Filter by workspace ID.\n    :param project_id: Filter by project ID.\n    :param section_id: Filter by section ID.\n    :param parent_id: Filter by parent task ID.\n    :param filter_query: Filter by a query string.\n    :param filter_lang: Language for the filter query (e.g., 'en').\n    :param limit: Maximum number of tasks per page (default 50).\n    :return: An iterable of lists of completed tasks.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_COMPLETED_BY_DUE_DATE_PATH)\n\n    params = kwargs_without_none(\n        since=format_datetime(since),\n        until=format_datetime(until),\n        workspace_id=workspace_id,\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n        filter_query=filter_query,\n        filter_lang=filter_lang,\n        limit=limit,\n    )\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"items\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_label","title":"<code>get_label(label_id)</code>  <code>async</code>","text":"<p>Get a specific personal label by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label to retrieve.</p> required <p>Returns:</p> Type Description <code>Label</code> <p>The requested label.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Label dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_label(self, label_id: str) -&gt; Label:\n    \"\"\"\n    Get a specific personal label by its ID.\n\n    :param label_id: The ID of the label to retrieve.\n    :return: The requested label.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Label dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n    response = await get_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Label.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_labels","title":"<code>get_labels(*, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of personal labels.</p> <p>Supports pagination arguments.</p> <p>The response is an iterable of lists of personal labels. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Label]]</code> <p>An iterable of lists of personal labels.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_labels(\n    self,\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Label]]:\n    \"\"\"\n    Get an iterable of lists of personal labels.\n\n    Supports pagination arguments.\n\n    The response is an iterable of lists of personal labels.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param limit: Maximum number of labels per page.\n    :return: An iterable of lists of personal labels.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(LABELS_PATH)\n\n    params = kwargs_without_none(limit=limit)\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Label.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_project","title":"<code>get_project(project_id)</code>  <code>async</code>","text":"<p>Get a project by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to retrieve.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The requested project.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Get a project by its ID.\n\n    :param project_id: The ID of the project to retrieve.\n    :return: The requested project.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n    response = await get_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_projects","title":"<code>get_projects(limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of active projects.</p> <p>The response is an iterable of lists of active projects. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int | None</code> <p>Maximum number of projects per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Project]]</code> <p>An iterable of lists of projects.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_projects(\n    self,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Project]]:\n    \"\"\"\n    Get an iterable of lists of active projects.\n\n    The response is an iterable of lists of active projects.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param limit: Maximum number of projects per page.\n    :return: An iterable of lists of projects.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(PROJECTS_PATH)\n    params = kwargs_without_none(limit=limit)\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Project.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_section","title":"<code>get_section(section_id)</code>  <code>async</code>","text":"<p>Get a specific section by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to retrieve.</p> required <p>Returns:</p> Type Description <code>Section</code> <p>The requested section.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Section dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_section(self, section_id: str) -&gt; Section:\n    \"\"\"\n    Get a specific section by its ID.\n\n    :param section_id: The ID of the section to retrieve.\n    :return: The requested section.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Section dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    response = await get_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Section.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_sections","title":"<code>get_sections(project_id=None, *, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of active sections.</p> <p>Supports filtering by <code>project_id</code> and pagination arguments.</p> <p>The response is an iterable of lists of active sections. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>Filter sections by project ID.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of sections per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Section]]</code> <p>An iterable of lists of sections.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_sections(\n    self,\n    project_id: str | None = None,\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Section]]:\n    \"\"\"\n    Get an iterable of lists of active sections.\n\n    Supports filtering by `project_id` and pagination arguments.\n\n    The response is an iterable of lists of active sections.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: Filter sections by project ID.\n    :param limit: Maximum number of sections per page.\n    :return: An iterable of lists of sections.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(SECTIONS_PATH)\n\n    params = kwargs_without_none(project_id=project_id, limit=limit)\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Section.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_shared_labels","title":"<code>get_shared_labels(*, omit_personal=False, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of shared label names.</p> <p>Includes labels from collaborators on shared projects that are not in the user's personal labels. Can optionally exclude personal label names using <code>omit_personal=True</code>. Supports pagination arguments.</p> <p>The response is an iterable of lists of shared label names. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>omit_personal</code> <code>bool</code> <p>Optional boolean flag to omit personal label names.</p> <code>False</code> <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[str]]</code> <p>An iterable of lists of shared label names (strings).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_shared_labels(\n    self,\n    *,\n    omit_personal: bool = False,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[str]]:\n    \"\"\"\n    Get an iterable of lists of shared label names.\n\n    Includes labels from collaborators on shared projects that are not in the\n    user's personal labels. Can optionally exclude personal label names using\n    `omit_personal=True`. Supports pagination arguments.\n\n    The response is an iterable of lists of shared label names.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param omit_personal: Optional boolean flag to omit personal label names.\n    :param limit: Maximum number of labels per page.\n    :return: An iterable of lists of shared label names (strings).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_PATH)\n\n    params = kwargs_without_none(omit_personal=omit_personal, limit=limit)\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        str,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_task","title":"<code>get_task(task_id)</code>  <code>async</code>","text":"<p>Get a specific task by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to retrieve.</p> required <p>Returns:</p> Type Description <code>Task</code> <p>The requested task.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Task dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_task(self, task_id: str) -&gt; Task:\n    \"\"\"\n    Get a specific task by its ID.\n\n    :param task_id: The ID of the task to retrieve.\n    :return: The requested task.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Task dictionary.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n    response = await get_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Task.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.get_tasks","title":"<code>get_tasks(*, project_id=None, section_id=None, parent_id=None, label=None, ids=None, limit=None)</code>  <code>async</code>","text":"<p>Get an iterable of lists of active tasks.</p> <p>The response is an iterable of lists of active tasks matching the criteria. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str | None</code> <p>Filter tasks by project ID.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>Filter tasks by section ID.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>Filter tasks by parent task ID.</p> <code>None</code> <code>label</code> <code>str | None</code> <p>Filter tasks by label name.</p> <code>None</code> <code>ids</code> <code>list[str] | None</code> <p>A list of the IDs of the tasks to retrieve.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of tasks per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Task]]</code> <p>An iterable of lists of tasks.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def get_tasks(\n    self,\n    *,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n    label: str | None = None,\n    ids: list[str] | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Task]]:\n    \"\"\"\n    Get an iterable of lists of active tasks.\n\n    The response is an iterable of lists of active tasks matching the criteria.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param project_id: Filter tasks by project ID.\n    :param section_id: Filter tasks by section ID.\n    :param parent_id: Filter tasks by parent task ID.\n    :param label: Filter tasks by label name.\n    :param ids: A list of the IDs of the tasks to retrieve.\n    :param limit: Maximum number of tasks per page.\n    :return: An iterable of lists of tasks.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(TASKS_PATH)\n\n    params = kwargs_without_none(\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n        label=label,\n        ids=\",\".join(str(i) for i in ids) if ids is not None else None,\n        limit=limit,\n    )\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Task.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.move_task","title":"<code>move_task(task_id, project_id=None, section_id=None, parent_id=None)</code>  <code>async</code>","text":"<p>Move a task to a different project, section, or parent task.</p> <p><code>project_id</code> takes predence, followed by <code>section_id</code> (which also updates <code>project_id</code>), and then <code>parent_id</code> (which also updates <code>section_id</code> and <code>project_id</code>).</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to move.</p> required <code>project_id</code> <code>str | None</code> <p>The ID of the project to move the task to.</p> <code>None</code> <code>section_id</code> <code>str | None</code> <p>The ID of the section to move the task to.</p> <code>None</code> <code>parent_id</code> <code>str | None</code> <p>The ID of the parent to move the task to.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was moved successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>ValueError</code> <p>If neither <code>project_id</code>, <code>section_id</code>, nor <code>parent_id</code> is provided.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def move_task(\n    self,\n    task_id: str,\n    project_id: str | None = None,\n    section_id: str | None = None,\n    parent_id: str | None = None,\n) -&gt; bool:\n    \"\"\"\n    Move a task to a different project, section, or parent task.\n\n    `project_id` takes predence, followed by\n    `section_id` (which also updates `project_id`),\n    and then `parent_id` (which also updates `section_id` and `project_id`).\n\n    :param task_id: The ID of the task to move.\n    :param project_id: The ID of the project to move the task to.\n    :param section_id: The ID of the section to move the task to.\n    :param parent_id: The ID of the parent to move the task to.\n    :return: True if the task was moved successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises ValueError: If neither `project_id`, `section_id`,\n            nor `parent_id` is provided.\n    \"\"\"\n    if project_id is None and section_id is None and parent_id is None:\n        raise ValueError(\n            \"Either `project_id`, `section_id`, or `parent_id` must be provided.\"\n        )\n\n    data = kwargs_without_none(\n        project_id=project_id,\n        section_id=section_id,\n        parent_id=parent_id,\n    )\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/move\")\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.remove_shared_label","title":"<code>remove_shared_label(name)</code>  <code>async</code>","text":"<p>Remove all occurrences of a shared label across all projects.</p> <p>This action removes the label string from all tasks where it appears.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the shared label to remove.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the removal was successful,</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def remove_shared_label(self, name: Annotated[str, MaxLen(60)]) -&gt; bool:\n    \"\"\"\n    Remove all occurrences of a shared label across all projects.\n\n    This action removes the label string from all tasks where it appears.\n\n    :param name: The name of the shared label to remove.\n    :return: True if the removal was successful,\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_REMOVE_PATH)\n    data = {\"name\": name}\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.rename_shared_label","title":"<code>rename_shared_label(name, new_name)</code>  <code>async</code>","text":"<p>Rename all occurrences of a shared label across all projects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The current name of the shared label to rename.</p> required <code>new_name</code> <code>str</code> <p>The new name for the shared label.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the rename was successful, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def rename_shared_label(\n    self,\n    name: Annotated[str, MaxLen(60)],\n    new_name: Annotated[str, MinLen(1), MaxLen(60)],\n) -&gt; bool:\n    \"\"\"\n    Rename all occurrences of a shared label across all projects.\n\n    :param name: The current name of the shared label to rename.\n    :param new_name: The new name for the shared label.\n    :return: True if the rename was successful,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(SHARED_LABELS_RENAME_PATH)\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        params={\"name\": name},\n        data={\"new_name\": new_name},\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.search_labels","title":"<code>search_labels(query, *, limit=None)</code>  <code>async</code>","text":"<p>Search personal labels by name.</p> <p>The response is an iterable of lists of labels matching the query. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string for label names.</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of labels per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Label]]</code> <p>An iterable of lists of labels.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def search_labels(\n    self,\n    query: Annotated[str, MinLen(1), MaxLen(1024)],\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Label]]:\n    \"\"\"\n    Search personal labels by name.\n\n    The response is an iterable of lists of labels matching the query.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query string for label names.\n    :param limit: Maximum number of labels per page.\n    :return: An iterable of lists of labels.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{LABELS_SEARCH_PATH_SUFFIX}\")\n\n    params = kwargs_without_none(query=query, limit=limit)\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Label.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.search_projects","title":"<code>search_projects(query, *, limit=None)</code>  <code>async</code>","text":"<p>Search active projects by name.</p> <p>The response is an iterable of lists of projects matching the query. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string for project names.</p> required <code>limit</code> <code>int | None</code> <p>Maximum number of projects per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Project]]</code> <p>An iterable of lists of projects.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def search_projects(\n    self,\n    query: Annotated[str, MinLen(1), MaxLen(1024)],\n    *,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Project]]:\n    \"\"\"\n    Search active projects by name.\n\n    The response is an iterable of lists of projects matching the query.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query string for project names.\n    :param limit: Maximum number of projects per page.\n    :return: An iterable of lists of projects.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{PROJECTS_SEARCH_PATH_SUFFIX}\")\n\n    params = kwargs_without_none(query=query, limit=limit)\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Project.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.search_sections","title":"<code>search_sections(query, *, project_id=None, limit=None)</code>  <code>async</code>","text":"<p>Search active sections by name.</p> <p>The response is an iterable of lists of sections matching the query. Be aware that each iteration fires off a network request to the Todoist API, and may result in rate limiting or other API restrictions.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>Query string for section names.</p> required <code>project_id</code> <code>str | None</code> <p>If set, search sections within the given project only.</p> <code>None</code> <code>limit</code> <code>int | None</code> <p>Maximum number of sections per page.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterator[list[Section]]</code> <p>An iterable of lists of sections.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response structure is unexpected.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def search_sections(\n    self,\n    query: Annotated[str, MinLen(1), MaxLen(1024)],\n    *,\n    project_id: str | None = None,\n    limit: Annotated[int, Ge(1), Le(200)] | None = None,\n) -&gt; AsyncIterator[list[Section]]:\n    \"\"\"\n    Search active sections by name.\n\n    The response is an iterable of lists of sections matching the query.\n    Be aware that each iteration fires off a network request to the Todoist API,\n    and may result in rate limiting or other API restrictions.\n\n    :param query: Query string for section names.\n    :param project_id: If set, search sections within the given project only.\n    :param limit: Maximum number of sections per page.\n    :return: An iterable of lists of sections.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response structure is unexpected.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{SECTIONS_SEARCH_PATH_SUFFIX}\")\n\n    params = kwargs_without_none(query=query, project_id=project_id, limit=limit)\n\n    return AsyncResultsPaginator(\n        self._client,\n        endpoint,\n        \"results\",\n        Section.from_dict,\n        self._token,\n        self._request_id_fn,\n        params,\n    )\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.unarchive_project","title":"<code>unarchive_project(project_id)</code>  <code>async</code>","text":"<p>Unarchive a project.</p> <p>Restores a previously archived project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to unarchive.</p> required <p>Returns:</p> Type Description <code>Project</code> <p>The unarchived project object.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> <code>TypeError</code> <p>If the API response is not a valid Project dictionary.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def unarchive_project(self, project_id: str) -&gt; Project:\n    \"\"\"\n    Unarchive a project.\n\n    Restores a previously archived project.\n\n    :param project_id: The ID of the project to unarchive.\n    :return: The unarchived project object.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    :raises TypeError: If the API response is not a valid Project dictionary.\n    \"\"\"\n    endpoint = get_api_url(\n        f\"{PROJECTS_PATH}/{project_id}/{PROJECT_UNARCHIVE_PATH_SUFFIX}\"\n    )\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.uncomplete_task","title":"<code>uncomplete_task(task_id)</code>  <code>async</code>","text":"<p>Uncomplete a (completed) task.</p> <p>Any parent tasks or sections will also be uncompleted.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to reopen.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the task was uncompleted successfully, False otherwise (possibly raise <code>HTTPError</code> instead).</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def uncomplete_task(self, task_id: str) -&gt; bool:\n    \"\"\"\n    Uncomplete a (completed) task.\n\n    Any parent tasks or sections will also be uncompleted.\n\n    :param task_id: The ID of the task to reopen.\n    :return: True if the task was uncompleted successfully,\n             False otherwise (possibly raise `HTTPError` instead).\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}/reopen\")\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n    )\n    return response.is_success\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_comment","title":"<code>update_comment(comment_id, content)</code>  <code>async</code>","text":"<p>Update an existing comment.</p> <p>Currently, only <code>content</code> can be updated.</p> <p>Parameters:</p> Name Type Description Default <code>comment_id</code> <code>str</code> <p>The ID of the comment to update.</p> required <code>content</code> <code>str</code> <p>The new text content for the comment.</p> required <p>Returns:</p> Type Description <code>Comment</code> <p>the updated Comment.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_comment(\n    self, comment_id: str, content: Annotated[str, MaxLen(15000)]\n) -&gt; Comment:\n    \"\"\"\n    Update an existing comment.\n\n    Currently, only `content` can be updated.\n\n    :param comment_id: The ID of the comment to update.\n    :param content: The new text content for the comment.\n    :return: the updated Comment.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{COMMENTS_PATH}/{comment_id}\")\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data={\"content\": content},\n    )\n    data = response_json_dict(response)\n    return Comment.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_label","title":"<code>update_label(label_id, *, name=None, color=None, item_order=None, is_favorite=None)</code>  <code>async</code>","text":"<p>Update a personal label.</p> <p>Only the fields to be updated need to be provided as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>label_id</code> <code>str</code> <p>The ID of the label.</p> required <code>name</code> <code>str | None</code> <p>The name of the label.</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the label icon.</p> <code>None</code> <code>item_order</code> <code>int | None</code> <p>Label's order in the label list.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the label is a favorite.</p> <code>None</code> <p>Returns:</p> Type Description <code>Label</code> <p>the updated Label.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_label(\n    self,\n    label_id: str,\n    *,\n    name: Annotated[str, MinLen(1), MaxLen(60)] | None = None,\n    color: ColorString | None = None,\n    item_order: int | None = None,\n    is_favorite: bool | None = None,\n) -&gt; Label:\n    \"\"\"\n    Update a personal label.\n\n    Only the fields to be updated need to be provided as keyword arguments.\n\n    :param label_id: The ID of the label.\n    :param name: The name of the label.\n    :param color: The color of the label icon.\n    :param item_order: Label's order in the label list.\n    :param is_favorite: Whether the label is a favorite.\n    :return: the updated Label.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{LABELS_PATH}/{label_id}\")\n\n    data = kwargs_without_none(\n        name=name,\n        color=color,\n        item_order=item_order,\n        is_favorite=is_favorite,\n    )\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Label.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_project","title":"<code>update_project(project_id, *, name=None, description=None, color=None, is_favorite=None, view_style=None)</code>  <code>async</code>","text":"<p>Update an existing project.</p> <p>Only the fields to be updated need to be provided as keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>str</code> <p>The ID of the project to update.</p> required <code>name</code> <code>str | None</code> <p>The name of the project.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the project (up to 1024 characters).</p> <code>None</code> <code>color</code> <code>ColorString | None</code> <p>The color of the project icon.</p> <code>None</code> <code>is_favorite</code> <code>bool | None</code> <p>Whether the project is a favorite.</p> <code>None</code> <code>view_style</code> <code>ViewStyle | None</code> <p>A string value (either 'list' or 'board').</p> <code>None</code> <p>Returns:</p> Type Description <code>Project</code> <p>the updated Project.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_project(\n    self,\n    project_id: str,\n    *,\n    name: Annotated[str, MinLen(1), MaxLen(120)] | None = None,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    color: ColorString | None = None,\n    is_favorite: bool | None = None,\n    view_style: ViewStyle | None = None,\n) -&gt; Project:\n    \"\"\"\n    Update an existing project.\n\n    Only the fields to be updated need to be provided as keyword arguments.\n\n    :param project_id: The ID of the project to update.\n    :param name: The name of the project.\n    :param description: Description for the project (up to 1024 characters).\n    :param color: The color of the project icon.\n    :param is_favorite: Whether the project is a favorite.\n    :param view_style: A string value (either 'list' or 'board').\n    :return: the updated Project.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{PROJECTS_PATH}/{project_id}\")\n\n    data = kwargs_without_none(\n        name=name,\n        description=description,\n        color=color,\n        is_favorite=is_favorite,\n        view_style=view_style,\n    )\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Project.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_section","title":"<code>update_section(section_id, name)</code>  <code>async</code>","text":"<p>Update an existing section.</p> <p>Currently, only <code>name</code> can be updated.</p> <p>Parameters:</p> Name Type Description Default <code>section_id</code> <code>str</code> <p>The ID of the section to update.</p> required <code>name</code> <code>str</code> <p>The new name for the section.</p> required <p>Returns:</p> Type Description <code>Section</code> <p>the updated Section.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_section(\n    self,\n    section_id: str,\n    name: Annotated[str, MinLen(1), MaxLen(2048)],\n) -&gt; Section:\n    \"\"\"\n    Update an existing section.\n\n    Currently, only `name` can be updated.\n\n    :param section_id: The ID of the section to update.\n    :param name: The new name for the section.\n    :return: the updated Section.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{SECTIONS_PATH}/{section_id}\")\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data={\"name\": name},\n    )\n    data = response_json_dict(response)\n    return Section.from_dict(data)\n</code></pre>"},{"location":"api_async/#todoist_api_python.api_async.TodoistAPIAsync.update_task","title":"<code>update_task(task_id, *, content=None, description=None, labels=None, priority=None, due_string=None, due_lang=None, due_date=None, due_datetime=None, assignee_id=None, order=None, day_order=None, collapsed=None, duration=None, duration_unit=None, deadline_date=None, deadline_lang=None)</code>  <code>async</code>","text":"<p>Update an existing task.</p> <p>Only the fields to be updated need to be provided.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>content</code> <code>str | None</code> <p>The text content of the task.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description for the task.</p> <code>None</code> <code>labels</code> <code>list[str] | None</code> <p>The task's labels (a list of names).</p> <code>None</code> <code>priority</code> <code>int | None</code> <p>The priority of the task (4 for very urgent).</p> <code>None</code> <code>due_string</code> <code>str | None</code> <p>The due date in natural language format.</p> <code>None</code> <code>due_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the due date (e.g., 'en').</p> <code>None</code> <code>due_date</code> <code>date | None</code> <p>The due date as a date object.</p> <code>None</code> <code>due_datetime</code> <code>datetime | None</code> <p>The due date and time as a datetime object.</p> <code>None</code> <code>assignee_id</code> <code>str | None</code> <p>User ID to whom the task is assigned.</p> <code>None</code> <code>order</code> <code>int | None</code> <p>The order of task in the project or section.</p> <code>None</code> <code>day_order</code> <code>int | None</code> <p>The order of the task inside Today or Next 7 days view.</p> <code>None</code> <code>collapsed</code> <code>bool | None</code> <p>Whether the task's sub-tasks are collapsed.</p> <code>None</code> <code>duration</code> <code>int | None</code> <p>The amount of time the task will take.</p> <code>None</code> <code>duration_unit</code> <code>Literal['minute', 'day'] | None</code> <p>The unit of time for duration.</p> <code>None</code> <code>deadline_date</code> <code>date | None</code> <p>The deadline date as a date object.</p> <code>None</code> <code>deadline_lang</code> <code>LanguageCode | None</code> <p>Language for parsing the deadline date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Task</code> <p>the updated Task.</p> <p>Raises:</p> Type Description <code>httpx.HTTPStatusError</code> <p>If the API request fails.</p> Source code in <code>todoist_api_python/api_async.py</code> <pre><code>async def update_task(\n    self,\n    task_id: str,\n    *,\n    content: Annotated[str, MinLen(1), MaxLen(500)] | None = None,\n    description: Annotated[str, MaxLen(16383)] | None = None,\n    labels: list[Annotated[str, MaxLen(60)]] | None = None,\n    priority: Annotated[int, Ge(1), Le(4)] | None = None,\n    due_string: Annotated[str, MaxLen(150)] | None = None,\n    due_lang: LanguageCode | None = None,\n    due_date: date | None = None,\n    due_datetime: datetime | None = None,\n    assignee_id: str | None = None,\n    order: int | None = None,\n    day_order: int | None = None,\n    collapsed: bool | None = None,\n    duration: Annotated[int, Ge(1)] | None = None,\n    duration_unit: Literal[\"minute\", \"day\"] | None = None,\n    deadline_date: date | None = None,\n    deadline_lang: LanguageCode | None = None,\n) -&gt; Task:\n    \"\"\"\n    Update an existing task.\n\n    Only the fields to be updated need to be provided.\n\n    :param task_id: The ID of the task to update.\n    :param content: The text content of the task.\n    :param description: Description for the task.\n    :param labels: The task's labels (a list of names).\n    :param priority: The priority of the task (4 for very urgent).\n    :param due_string: The due date in natural language format.\n    :param due_lang: Language for parsing the due date (e.g., 'en').\n    :param due_date: The due date as a date object.\n    :param due_datetime: The due date and time as a datetime object.\n    :param assignee_id: User ID to whom the task is assigned.\n    :param order: The order of task in the project or section.\n    :param day_order: The order of the task inside Today or Next 7 days view.\n    :param collapsed: Whether the task's sub-tasks are collapsed.\n    :param duration: The amount of time the task will take.\n    :param duration_unit: The unit of time for duration.\n    :param deadline_date: The deadline date as a date object.\n    :param deadline_lang: Language for parsing the deadline date.\n    :return: the updated Task.\n    :raises httpx.HTTPStatusError: If the API request fails.\n    \"\"\"\n    endpoint = get_api_url(f\"{TASKS_PATH}/{task_id}\")\n\n    data = kwargs_without_none(\n        content=content,\n        description=description,\n        labels=labels,\n        priority=priority,\n        due_string=due_string,\n        due_lang=due_lang,\n        due_date=format_date(due_date) if due_date is not None else None,\n        due_datetime=(\n            format_datetime(due_datetime) if due_datetime is not None else None\n        ),\n        assignee_id=assignee_id,\n        order=order,\n        day_order=day_order,\n        collapsed=collapsed,\n        duration=duration,\n        duration_unit=duration_unit,\n        deadline_date=(\n            format_date(deadline_date) if deadline_date is not None else None\n        ),\n        deadline_lang=deadline_lang,\n    )\n\n    response = await post_async(\n        self._client,\n        endpoint,\n        self._token,\n        self._request_id_fn() if self._request_id_fn else None,\n        data=data,\n    )\n    data = response_json_dict(response)\n    return Task.from_dict(data)\n</code></pre>"},{"location":"authentication/","title":"Authentication","text":"<p>This module provides helpers to authenticate with Todoist using OAuth.</p>"},{"location":"authentication/#quick-start","title":"Quick start","text":"<pre><code>import uuid\n\nfrom todoist_api_python.authentication import get_auth_token, get_authentication_url\n\n# 1. Generate a random state\nstate = str(uuid.uuid4())\n\n# 2. Build the authorization URL\nurl = get_authentication_url(\n    client_id=\"YOUR_CLIENT_ID\",\n    scopes=[\"data:read\", \"task:add\"],\n    state=state,\n)\n\n# 3. Redirect the user to `url`\n# 4. Handle the OAuth callback and obtain the auth code\ncode = \"CODE_YOU_OBTAINED\"\n\n# 5. Exchange code for an access token\nauth_result = get_auth_token(\n    client_id=\"YOUR_CLIENT_ID\",\n    client_secret=\"YOUR_CLIENT_SECRET\",\n    code=code,\n)\n\n# 6. Ensure state is consistent, and done!\nassert auth_result.state == state\naccess_token = auth_result.access_token\n</code></pre> <p>For detailed implementation steps and security considerations, refer to the Todoist OAuth documentation.</p>"},{"location":"authentication/#todoist_api_python.authentication.get_auth_token","title":"<code>get_auth_token(client_id, client_secret, code, client=None)</code>","text":"<p>Get access token using provided client ID, client secret, and auth code.</p> Source code in <code>todoist_api_python/authentication.py</code> <pre><code>def get_auth_token(\n    client_id: str,\n    client_secret: str,\n    code: str,\n    client: httpx.Client | None = None,\n) -&gt; AuthResult:\n    \"\"\"Get access token using provided client ID, client secret, and auth code.\"\"\"\n    endpoint = _get_access_token_url()\n    data = _build_auth_token_data(client_id, client_secret, code)\n\n    with _managed_client(client) as managed_client:\n        response = post(\n            client=managed_client,\n            url=endpoint,\n            data=data,\n        )\n\n    data = response_json_dict(response)\n    return AuthResult.from_dict(data)\n</code></pre>"},{"location":"authentication/#todoist_api_python.authentication.get_auth_token_async","title":"<code>get_auth_token_async(client_id, client_secret, code, client=None)</code>  <code>async</code>","text":"<p>Get access token asynchronously.</p> Source code in <code>todoist_api_python/authentication.py</code> <pre><code>async def get_auth_token_async(\n    client_id: str,\n    client_secret: str,\n    code: str,\n    client: httpx.AsyncClient | None = None,\n) -&gt; AuthResult:\n    \"\"\"Get access token asynchronously.\"\"\"\n    endpoint = _get_access_token_url()\n    data = _build_auth_token_data(client_id, client_secret, code)\n\n    async with _managed_async_client(client) as managed_client:\n        response = await post_async(\n            client=managed_client,\n            url=endpoint,\n            data=data,\n        )\n\n    data = response_json_dict(response)\n    return AuthResult.from_dict(data)\n</code></pre>"},{"location":"authentication/#todoist_api_python.authentication.get_authentication_url","title":"<code>get_authentication_url(client_id, scopes, state)</code>","text":"<p>Get authorization URL to initiate OAuth flow.</p> Source code in <code>todoist_api_python/authentication.py</code> <pre><code>def get_authentication_url(client_id: str, scopes: list[Scope], state: str) -&gt; str:\n    \"\"\"Get authorization URL to initiate OAuth flow.\"\"\"\n    if len(scopes) == 0:\n        raise ValueError(\"At least one authorization scope should be requested.\")\n\n    endpoint = get_oauth_url(AUTHORIZE_PATH)\n    query = {\n        \"client_id\": client_id,\n        \"scope\": \",\".join(scopes),\n        \"state\": state,\n    }\n    return f\"{endpoint}?{urlencode(query)}\"\n</code></pre>"},{"location":"authentication/#todoist_api_python.authentication.revoke_auth_token","title":"<code>revoke_auth_token(client_id, client_secret, token, client=None)</code>","text":"<p>Revoke an access token.</p> Source code in <code>todoist_api_python/authentication.py</code> <pre><code>def revoke_auth_token(\n    client_id: str,\n    client_secret: str,\n    token: str,\n    client: httpx.Client | None = None,\n) -&gt; bool:\n    \"\"\"Revoke an access token.\"\"\"\n    endpoint = _get_access_tokens_url()\n    params = _build_revoke_auth_token_params(client_id, client_secret, token)\n\n    with _managed_client(client) as managed_client:\n        response = delete(client=managed_client, url=endpoint, params=params)\n\n    return response.is_success\n</code></pre>"},{"location":"authentication/#todoist_api_python.authentication.revoke_auth_token_async","title":"<code>revoke_auth_token_async(client_id, client_secret, token, client=None)</code>  <code>async</code>","text":"<p>Revoke an access token asynchronously.</p> Source code in <code>todoist_api_python/authentication.py</code> <pre><code>async def revoke_auth_token_async(\n    client_id: str,\n    client_secret: str,\n    token: str,\n    client: httpx.AsyncClient | None = None,\n) -&gt; bool:\n    \"\"\"Revoke an access token asynchronously.\"\"\"\n    endpoint = _get_access_tokens_url()\n    params = _build_revoke_auth_token_params(client_id, client_secret, token)\n\n    async with _managed_async_client(client) as managed_client:\n        response = await delete_async(\n            client=managed_client, url=endpoint, params=params\n        )\n\n    return response.is_success\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>TodoistAPIAsync</code> now performs true async HTTP I/O with <code>httpx.AsyncClient</code>.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Breaking: <code>TodoistAPI</code> now accepts an optional <code>client: httpx.Client</code> instead of <code>session: requests.Session</code>.</li> <li>Breaking: <code>TodoistAPIAsync</code> now accepts an optional <code>client: httpx.AsyncClient</code> instead of <code>session: requests.Session</code>.</li> <li>Breaking: Async paginated return types now use <code>AsyncIterator[...]</code> instead of <code>AsyncGenerator[...]</code>.</li> <li>Breaking: API errors now raise <code>httpx.HTTPStatusError</code> instead of <code>requests.exceptions.HTTPError</code>.</li> <li>Breaking: Authentication helpers now accept optional <code>httpx.Client</code> / <code>httpx.AsyncClient</code> instances instead of <code>session: requests.Session</code>.</li> </ul>"},{"location":"changelog/#321-2026-01-22","title":"[3.2.1] - 2026-01-22","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Type hints for <code>Meta</code> class fields (<code>project</code>, <code>section</code>, <code>assignee</code>) now correctly indicate that tuple values can be <code>None</code></li> </ul>"},{"location":"changelog/#320-2026-01-16","title":"[3.2.0] - 2026-01-16","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for searching projects</li> <li>Support for searching sections</li> <li>Support for searching labels</li> </ul>"},{"location":"changelog/#310-2025-05-07","title":"[3.1.0] - 2025-05-07","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for moving tasks, courtesy of @radiant-tangent</li> <li>Support for <code>backups:read</code> scope</li> <li>Re-add support for <code>X-Request-ID</code></li> <li>Configurable via <code>request_id_fn</code> API constructor argument</li> <li>Defaults to random UUID v4</li> <li>Automatic testing across all supported Python versions</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Compatibility with Python 3.9 and Python 3.10</li> </ul>"},{"location":"changelog/#301-2025-04-15","title":"[3.0.1] - 2025-04-15","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Wheel and source distributions didn't include the package itself</li> <li>Project requiring Python 3.13 to be installed</li> </ul>"},{"location":"changelog/#300-2025-04-11","title":"[3.0.0] - 2025-04-11","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Support for deadlines</li> <li>Support for archiving and unarchiving projects</li> <li>Support for fetching completed tasks by due date range and by completion date range</li> <li>Support for <code>note</code>, <code>reminder</code>, and <code>auto_reminder</code> in <code>add_task_quick</code></li> <li>Documentation for all SDK functions, arguments, and return objects</li> <li>Types, type hints for all SDK functions, arguments, and return objects</li> <li>Function to obtain project URLs</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Use <code>dataclass-wizard</code> for object mapping</li> <li>Modernized SDK to use the Todoist API v1</li> <li>Remove deprecated <code>Task.sync_id</code>, <code>Task.comment_count</code>, and <code>Project.comment_count</code></li> <li>Replace <code>Task.is_completed</code> with <code>Task.completed_at</code></li> <li>Add support for <code>calendar</code> in <code>Project.view_style</code></li> <li>Rename <code>quick_add_task</code> to <code>add_task_quick</code></li> <li>Add <code>filter_tasks</code>, extracting that workflow from <code>get_tasks</code></li> <li>Paginate results via an <code>Iterator</code> in <code>get_tasks</code>, <code>filter_task</code>, <code>get_projects</code>,   <code>get_collaborators</code>, <code>get_sections</code>, <code>get_comments</code>, <code>get_labels</code>, <code>get_shared_labels</code></li> <li>Receive <code>date</code> and <code>datetime</code> arguments as objects, not strings</li> <li>Remove support for <code>X-Request-Id</code> header, unused on the API level</li> <li>\"Hide\" internal modules and functions</li> <li>Task URLs are now obtained on demand, improving performance when not needed</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>API requests configure appropriate timeouts to avoid connections hanging</li> </ul>"},{"location":"changelog/#217-2024-08-13","title":"[2.1.7] - 2024-08-13","text":""},{"location":"changelog/#fixes","title":"Fixes","text":"<ul> <li>Regression with some <code>Project</code> object attributes</li> </ul>"},{"location":"changelog/#216-2024-08-07","title":"[2.1.6] - 2024-08-07","text":""},{"location":"changelog/#fixes_1","title":"Fixes","text":"<ul> <li><code>TodoistAPIAsync</code> accepts a <code>session</code> parameter</li> <li>State becomes optional in <code>AuthResult.from_dict()</code></li> <li>Duration handling in <code>to_dict()</code> and tests</li> <li>Default value to <code>section_id</code></li> <li>Properly close requests <code>Session</code> object</li> </ul>"},{"location":"changelog/#215-2024-05-22","title":"[2.1.5] - 2024-05-22","text":""},{"location":"changelog/#fixes_2","title":"Fixes","text":"<ul> <li>Key error on <code>can_assign_tasks</code> in <code>Project</code> model</li> </ul>"},{"location":"changelog/#214-2024-05-07","title":"[2.1.4] - 2024-05-07","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Support <code>project.can_assign_tasks</code></li> <li>Add <code>duration</code> to <code>Task</code> object</li> <li>Pagination example</li> </ul>"},{"location":"changelog/#213-2023-08-15","title":"[2.1.3] - 2023-08-15","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Support for getting completed items through the items archive</li> </ul>"},{"location":"changelog/#212-2023-08-14","title":"[2.1.2] - 2023-08-14","text":""},{"location":"changelog/#fixes_3","title":"Fixes","text":"<ul> <li>Restore Python 3.9 compatibility</li> </ul>"},{"location":"changelog/#211-2023-08-09","title":"[2.1.1] - 2023-08-09","text":""},{"location":"changelog/#fixes_4","title":"Fixes","text":"<ul> <li>Building environment updates</li> </ul>"},{"location":"changelog/#210-2023-08-02","title":"[2.1.0] - 2023-08-02","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Use built-in data classes instead of <code>attrs</code></li> </ul>"},{"location":"changelog/#202-2022-11-02","title":"[2.0.2] - 2022-11-02","text":""},{"location":"changelog/#fixes_5","title":"Fixes","text":"<ul> <li>Task property <code>date_added</code> should be <code>added_at</code></li> </ul>"},{"location":"changelog/#201-2022-10-06","title":"[2.0.1] - 2022-10-06","text":""},{"location":"changelog/#fixes_6","title":"Fixes","text":"<ul> <li>Fixed a crash in <code>get_comments</code> if attachment is null.</li> </ul>"},{"location":"changelog/#200-2022-09-08","title":"[2.0.0] - 2022-09-08","text":"<p>Migrate to REST API v2.</p>"},{"location":"changelog/#111-2022-02-15","title":"[1.1.1] - 2022-02-15","text":""},{"location":"changelog/#fixes_7","title":"Fixes","text":"<ul> <li>Add missing <code>attrs</code> package dependency</li> </ul>"},{"location":"changelog/#security","title":"Security","text":"<ul> <li>Dependabot updates</li> </ul>"},{"location":"changelog/#110-2021-11-23","title":"[1.1.0] - 2021-11-23","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Public release</li> </ul>"},{"location":"models/","title":"Models","text":""},{"location":"models/#todoist_api_python.models.ApiDate","title":"<code>ApiDate = UTCDateTimePattern['%FT%T.%fZ']</code>","text":""},{"location":"models/#todoist_api_python.models.ApiDue","title":"<code>ApiDue = Union[DatePattern['%F'], DateTimePattern['%FT%T'], UTCDateTimePattern['%FT%TZ']]</code>","text":""},{"location":"models/#todoist_api_python.models.DurationUnit","title":"<code>DurationUnit = Literal['minute', 'day']</code>","text":""},{"location":"models/#todoist_api_python.models.ViewStyle","title":"<code>ViewStyle = Literal['list', 'board', 'calendar']</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment","title":"<code>Attachment</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Attachment(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    resource_type: str | None = None\n\n    file_name: str | None = None\n    file_size: int | None = None\n    file_type: str | None = None\n    file_url: str | None = None\n    file_duration: int | None = None\n    upload_state: str | None = None\n\n    image: str | None = None\n    image_width: int | None = None\n    image_height: int | None = None\n\n    url: str | None = None\n    title: str | None = None\n</code></pre>"},{"location":"models/#todoist_api_python.models.Attachment.file_duration","title":"<code>file_duration = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.file_name","title":"<code>file_name = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.file_size","title":"<code>file_size = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.file_type","title":"<code>file_type = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.file_url","title":"<code>file_url = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.image","title":"<code>image = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.image_height","title":"<code>image_height = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.image_width","title":"<code>image_width = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.resource_type","title":"<code>resource_type = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.title","title":"<code>title = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.upload_state","title":"<code>upload_state = None</code>","text":""},{"location":"models/#todoist_api_python.models.Attachment.url","title":"<code>url = None</code>","text":""},{"location":"models/#todoist_api_python.models.AuthResult","title":"<code>AuthResult</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass AuthResult(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    access_token: str\n    state: str | None\n</code></pre>"},{"location":"models/#todoist_api_python.models.AuthResult.access_token","title":"<code>access_token</code>","text":""},{"location":"models/#todoist_api_python.models.AuthResult.state","title":"<code>state</code>","text":""},{"location":"models/#todoist_api_python.models.Collaborator","title":"<code>Collaborator</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Collaborator(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    email: str\n    name: str\n</code></pre>"},{"location":"models/#todoist_api_python.models.Collaborator.email","title":"<code>email</code>","text":""},{"location":"models/#todoist_api_python.models.Collaborator.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Collaborator.name","title":"<code>name</code>","text":""},{"location":"models/#todoist_api_python.models.Comment","title":"<code>Comment</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Comment(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    content: str\n    poster_id: Annotated[str, Alias(load=(\"posted_uid\", \"poster_id\"))]\n    posted_at: ApiDate\n    task_id: Annotated[str | None, Alias(load=(\"item_id\", \"task_id\"))] = None\n    project_id: str | None = None\n    attachment: Annotated[\n        Attachment | None, Alias(load=(\"file_attachment\", \"attachment\"))\n    ] = None\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"\n        Finish initialization of the Comment object.\n\n        :raises ValueError: If neither `task_id` nor `project_id` is specified.\n        \"\"\"\n        if self.task_id is None and self.project_id is None:\n            raise ValueError(\"Must specify `task_id` or `project_id`\")\n</code></pre>"},{"location":"models/#todoist_api_python.models.Comment.attachment","title":"<code>attachment = None</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.content","title":"<code>content</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.posted_at","title":"<code>posted_at</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.poster_id","title":"<code>poster_id</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.project_id","title":"<code>project_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Comment.task_id","title":"<code>task_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Deadline","title":"<code>Deadline</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Deadline(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    date: ApiDue\n    lang: str = \"en\"\n</code></pre>"},{"location":"models/#todoist_api_python.models.Deadline.date","title":"<code>date</code>","text":""},{"location":"models/#todoist_api_python.models.Deadline.lang","title":"<code>lang = 'en'</code>","text":""},{"location":"models/#todoist_api_python.models.Due","title":"<code>Due</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Due(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    date: ApiDue\n    string: str\n    lang: str = \"en\"\n    is_recurring: bool = False\n    timezone: str | None = None\n</code></pre>"},{"location":"models/#todoist_api_python.models.Due.date","title":"<code>date</code>","text":""},{"location":"models/#todoist_api_python.models.Due.is_recurring","title":"<code>is_recurring = False</code>","text":""},{"location":"models/#todoist_api_python.models.Due.lang","title":"<code>lang = 'en'</code>","text":""},{"location":"models/#todoist_api_python.models.Due.string","title":"<code>string</code>","text":""},{"location":"models/#todoist_api_python.models.Due.timezone","title":"<code>timezone = None</code>","text":""},{"location":"models/#todoist_api_python.models.Duration","title":"<code>Duration</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Duration(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    amount: int\n    unit: DurationUnit\n</code></pre>"},{"location":"models/#todoist_api_python.models.Duration.amount","title":"<code>amount</code>","text":""},{"location":"models/#todoist_api_python.models.Duration.unit","title":"<code>unit</code>","text":""},{"location":"models/#todoist_api_python.models.Label","title":"<code>Label</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Label(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    name: str\n    color: str\n    order: int\n    is_favorite: bool\n</code></pre>"},{"location":"models/#todoist_api_python.models.Label.color","title":"<code>color</code>","text":""},{"location":"models/#todoist_api_python.models.Label.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Label.is_favorite","title":"<code>is_favorite</code>","text":""},{"location":"models/#todoist_api_python.models.Label.name","title":"<code>name</code>","text":""},{"location":"models/#todoist_api_python.models.Label.order","title":"<code>order</code>","text":""},{"location":"models/#todoist_api_python.models.Meta","title":"<code>Meta</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Meta(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    project: tuple[str | None, str | None]\n    section: tuple[str | None, str | None]\n    assignee: tuple[str | None, str | None]\n    labels: dict[int, str]\n    due: Due | None\n    deadline: Deadline | None\n</code></pre>"},{"location":"models/#todoist_api_python.models.Meta.assignee","title":"<code>assignee</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.deadline","title":"<code>deadline</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.due","title":"<code>due</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.labels","title":"<code>labels</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.project","title":"<code>project</code>","text":""},{"location":"models/#todoist_api_python.models.Meta.section","title":"<code>section</code>","text":""},{"location":"models/#todoist_api_python.models.Project","title":"<code>Project</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Project(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    name: str\n    description: str\n    order: Annotated[int, Alias(load=(\"child_order\", \"order\"))]\n    color: str\n    is_collapsed: Annotated[bool, Alias(load=(\"collapsed\", \"is_collapsed\"))]\n    is_shared: Annotated[bool, Alias(load=(\"shared\", \"is_shared\"))]\n    is_favorite: bool\n    is_archived: bool\n    can_assign_tasks: bool\n    view_style: ViewStyle\n    created_at: ApiDate\n    updated_at: ApiDate\n\n    parent_id: str | None = None\n    is_inbox_project: Annotated[\n        bool | None, Alias(load=(\"inbox_project\", \"is_inbox_project\"))\n    ] = None\n\n    workspace_id: str | None = None\n    folder_id: str | None = None\n\n    @property\n    def url(self) -&gt; str:\n        if self.is_inbox_project:\n            return INBOX_URL\n        return get_project_url(self.id, self.name)\n</code></pre>"},{"location":"models/#todoist_api_python.models.Project.can_assign_tasks","title":"<code>can_assign_tasks</code>","text":""},{"location":"models/#todoist_api_python.models.Project.color","title":"<code>color</code>","text":""},{"location":"models/#todoist_api_python.models.Project.created_at","title":"<code>created_at</code>","text":""},{"location":"models/#todoist_api_python.models.Project.description","title":"<code>description</code>","text":""},{"location":"models/#todoist_api_python.models.Project.folder_id","title":"<code>folder_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Project.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_archived","title":"<code>is_archived</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_collapsed","title":"<code>is_collapsed</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_favorite","title":"<code>is_favorite</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_inbox_project","title":"<code>is_inbox_project = None</code>","text":""},{"location":"models/#todoist_api_python.models.Project.is_shared","title":"<code>is_shared</code>","text":""},{"location":"models/#todoist_api_python.models.Project.name","title":"<code>name</code>","text":""},{"location":"models/#todoist_api_python.models.Project.order","title":"<code>order</code>","text":""},{"location":"models/#todoist_api_python.models.Project.parent_id","title":"<code>parent_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Project.updated_at","title":"<code>updated_at</code>","text":""},{"location":"models/#todoist_api_python.models.Project.url","title":"<code>url</code>","text":""},{"location":"models/#todoist_api_python.models.Project.view_style","title":"<code>view_style</code>","text":""},{"location":"models/#todoist_api_python.models.Project.workspace_id","title":"<code>workspace_id = None</code>","text":""},{"location":"models/#todoist_api_python.models.Section","title":"<code>Section</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Section(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    name: str\n    project_id: str\n    is_collapsed: Annotated[bool, Alias(load=(\"collapsed\", \"is_collapsed\"))]\n    order: Annotated[int, Alias(load=(\"section_order\", \"order\"))]\n</code></pre>"},{"location":"models/#todoist_api_python.models.Section.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Section.is_collapsed","title":"<code>is_collapsed</code>","text":""},{"location":"models/#todoist_api_python.models.Section.name","title":"<code>name</code>","text":""},{"location":"models/#todoist_api_python.models.Section.order","title":"<code>order</code>","text":""},{"location":"models/#todoist_api_python.models.Section.project_id","title":"<code>project_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task","title":"<code>Task</code>","text":"<p>               Bases: <code>JSONPyWizard</code></p> Source code in <code>todoist_api_python/models.py</code> <pre><code>@dataclass\nclass Task(JSONPyWizard):\n    class _(JSONPyWizard.Meta):  # noqa:N801\n        v1 = True\n\n    id: str\n    content: str\n    description: str\n    project_id: str\n    section_id: str | None\n    parent_id: str | None\n    labels: list[str] | None\n    priority: int\n    due: Due | None\n    deadline: Deadline | None\n    duration: Duration | None\n    is_collapsed: Annotated[bool, Alias(load=(\"collapsed\", \"is_collapsed\"))]\n    order: Annotated[int, Alias(load=(\"child_order\", \"order\"))]\n    assignee_id: Annotated[str | None, Alias(load=(\"responsible_uid\", \"assignee_id\"))]\n    assigner_id: Annotated[str | None, Alias(load=(\"assigned_by_uid\", \"assigner_id\"))]\n    completed_at: Optional[ApiDate]  # noqa: UP007 # https://github.com/rnag/dataclass-wizard/issues/189\n    creator_id: Annotated[str, Alias(load=(\"added_by_uid\", \"creator_id\"))]\n    created_at: Annotated[ApiDate, Alias(load=(\"added_at\", \"created_at\"))]\n    updated_at: ApiDate\n\n    meta: Meta | None = None\n\n    @property\n    def url(self) -&gt; str:\n        return get_task_url(self.id, self.content)\n\n    @property\n    def is_completed(self) -&gt; bool:\n        return self.completed_at is not None\n</code></pre>"},{"location":"models/#todoist_api_python.models.Task.assignee_id","title":"<code>assignee_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.assigner_id","title":"<code>assigner_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.completed_at","title":"<code>completed_at</code>","text":""},{"location":"models/#todoist_api_python.models.Task.content","title":"<code>content</code>","text":""},{"location":"models/#todoist_api_python.models.Task.created_at","title":"<code>created_at</code>","text":""},{"location":"models/#todoist_api_python.models.Task.creator_id","title":"<code>creator_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.deadline","title":"<code>deadline</code>","text":""},{"location":"models/#todoist_api_python.models.Task.description","title":"<code>description</code>","text":""},{"location":"models/#todoist_api_python.models.Task.due","title":"<code>due</code>","text":""},{"location":"models/#todoist_api_python.models.Task.duration","title":"<code>duration</code>","text":""},{"location":"models/#todoist_api_python.models.Task.id","title":"<code>id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.is_collapsed","title":"<code>is_collapsed</code>","text":""},{"location":"models/#todoist_api_python.models.Task.is_completed","title":"<code>is_completed</code>","text":""},{"location":"models/#todoist_api_python.models.Task.labels","title":"<code>labels</code>","text":""},{"location":"models/#todoist_api_python.models.Task.meta","title":"<code>meta = None</code>","text":""},{"location":"models/#todoist_api_python.models.Task.order","title":"<code>order</code>","text":""},{"location":"models/#todoist_api_python.models.Task.parent_id","title":"<code>parent_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.priority","title":"<code>priority</code>","text":""},{"location":"models/#todoist_api_python.models.Task.project_id","title":"<code>project_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.section_id","title":"<code>section_id</code>","text":""},{"location":"models/#todoist_api_python.models.Task.updated_at","title":"<code>updated_at</code>","text":""},{"location":"models/#todoist_api_python.models.Task.url","title":"<code>url</code>","text":""}]}